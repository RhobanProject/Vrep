<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<title>API Functions</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>

<div align="center">
<table class=allEncompassingTable >
 <tr>
  <td >
<p><a href="../index.html" TARGET="_top"><img src="images/homeImg.png"></a></p>



<h1><a href="apiOverview.htm">Regular API</a> Functions</h1>

<p class=warningBox>The list of API functions below allows you to access many V-REP parameters<a href="settings.htm"></a>. There are however too many parameters in V-REP to have a specific API function for each one of them. <em>Auxiliary</em> parameters can be accessed via a set of given functions that use <a href="objectParameterIDs.htm">object parameter IDs described here (click)</a>.<br>
</p>

<h3><a name="simAddBanner" id="simAddBanner"></a>simAddBanner</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Adds a banner to the scene. Banners  created in the <a href="mainScript.htm">main script</a> or in a <a href="childScripts.htm">child script</a> will be automatically removed at simulation end. See also <a href="#simRemoveBanner">simRemoveBanner</a> and <a href="#simAddDrawingObject">simAddDrawingObject</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddBanner(const simChar* label,simFloat size,simInt options,const simFloat* positionAndEulerAngles,simInt parentObjectHandle,const simFloat* labelColors,const simFloat* backgroundColors)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>label</strong>: the label to display on the banner</div>
<div><strong>size</strong>: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this argument represents the banner height in pixels instead<br>
</div>
<div><strong>options</strong>: a combination of <a href="apiConstants.htm#banners">banner options</a></div>
<div><strong>positionAndEulerAngles</strong>: 6 values representing the banner's position and orientation in space. Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the parent object's position and orientation. This argument can be NULL, in which case the identity transformation is assumed<br>
</div>
<div><strong>parentObjectHandle</strong>: the handle of a scene object you wish to attach the banner to, or -1 if the banner should be independent.<br>
</div>
<div><strong>labelColors</strong>: 12 values representing the RGB values (0-1) for the 4 color components of the text (ambient, diffuse, specular and emissive). Can be NULL, in which case a black color will be used<br>
</div>
<div><strong>backgroundColors</strong>: 12 values representing the RGB values (0-1) for the 4 color components of the text background (ambient, diffuse, specular and emissive). Can be NULL, in which case a white color will be used<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the banner if successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number bannerID=simAddBanner(string label,number size,number options,table_6 positionAndEulerAngles=nil,number parentObjectHandle=nil,table_12 labelColors=nil,table_12 backgroundColors=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>



<h3><a name="simAddDrawingObject" id="simAddDrawingObject"></a>simAddDrawingObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a drawing object that will be displayed in the scene. Drawing objects are containers that hold several items of a given type. This can be used for several different applications (simulation of paint, simulation of welding seam, display of 3D objects, etc.). Drawing objects created in the <a href="mainScript.htm">main script</a> or in a <a href="childScripts.htm">child script</a> will be automatically removed at simulation end. See also <a href="#simAddDrawingObjectItem">simAddDrawingObjectItem</a> and <a href="#simRemoveDrawingObject">simRemoveDrawingObject</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddDrawingObject(simInt objectType,simFloat size,simFloat duplicateTolerance,simInt parentObjectHandle,simInt maxItemCount,const simFloat* ambient,const simFloat* diffuse,const simFloat* specular,const simFloat* emission)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectType</strong>: a <a href="apiConstants.htm#customDrawingObjects">drawing object type combined with attributes</a></div>
<div><strong>size</strong>: size of the item (width of lines or size of points are in pixels, other sizes are in meters</div>
<div><strong>duplicateTolerance</strong>: if different from 0.0, then a call to <a href="#simAddDrawingObjectItem">simAddDrawingObjectItem</a> will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.<br>
</div>
<div><strong>parentObjectHandle</strong>: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)<br>
</div>
<div><strong>maxItemCount</strong>: maximum number of items this object can hold.</div>
<div><strong>ambient</strong>: default ambient color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>diffuse</strong>: default diffuse color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>specular</strong>: default specular color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>emission</strong>: default emissive color (pointer to 3 rgb values). Can be NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the drawing object if successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number drawingObjectHandle=simAddDrawingObject(number objectType,number size,number duplicateTolerance,number parentObjectHandle,number maxItemCount,table_3 ambient=nil,table_3 diffuse=nil,table_3 specular=nil,table_3 emission=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>



<h3><a name="simAddDrawingObjectItem" id="simAddDrawingObjectItem"></a>simAddDrawingObjectItem</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds an item (or clears all items) to a previously inserted drawing object. See also <a href="#simAddDrawingObject">simAddDrawingObject</a> and <a href="#simRemoveDrawingObject">simRemoveDrawingObject</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddDrawingObjectItem(simInt objectHandle,const simFloat* itemData)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a previously added drawing object</div>
<div><strong>itemData</strong>: data relative to an item. If the item is a point item, 3 values are required (x;y;z). If the item is a line item, 6 values are required, and if the item is a triangle item, 9 values are required. Additional values (auxiliary values) might be required depending on the drawing object attributes. See the <a href="apiConstants.htm#customDrawingObjects">drawing object types and attributes</a> for more information. If NULL the drawing object is emptied of all its items<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAddDrawingObjectItem(number drawingObjectHandle,table itemData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>



<h3><a name="simAddForce" id="simAddForce"></a>simAddForce</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a non-central force to a shape object that is dynamically enabled. Added forces are cumulative, and are reset to zero after <a href="#simHandleDynamics">simHandleDynamics</a> was called. See also <a href="#simAddForceAndTorque">simAddForceAndTorque</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddForce (simInt shapeHandle,const simFloat* position,const simFloat* force)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of a dynamically enabled shape</div>
<div><strong>position</strong>: pointer to 3 values that represent the relative position where the force should be applied.</div>
<div><strong>force</strong>: pointer to 3 values that represent the force (in relative coordinates) to add.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAddForce(number shapeHandle,table_3 position,table_3 force)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>



<h3><a name="simAddForceAndTorque" id="simAddForceAndTorque"></a>simAddForceAndTorque</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a force and/or torque to a shape object that is dynamically enabled. Forces are applied at the center of mass. Added forces and torques are cumulative, and are reset to zero after <a href="#simHandleDynamics">simHandleDynamics</a> was called. See also <a href="#simAddForce">simAddForce</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddForceAndTorque(simInt shapeHandle,const simFloat* force,const simFloat* torque)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of a dynamically enabled shape</div>
<div><strong>force</strong>: pointer to 3 values that represent the force (in absolute coordinates) to add. Can be NULL.</div>
<div><strong>torque</strong>: pointer to 3 values that represent the torque (in absolute coordinates) to add. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAddForceAndTorque(number shapeHandle,table_3 force,table_3 torque)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>



<h3><a name="simAddModuleMenuEntry" id="simAddModuleMenuEntry"></a>simAddModuleMenuEntry</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Attaches a menu entry in the simulator's module menu. This is useful if you created an plugin that can display a custom dialog in V-REP for specific settings/operations. If the user selects an item in the simulator's module menu, a <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_menuitemselected</a> message is generated. See also the <a href="plugins.htm">plugin v_repMessage entry point</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddModuleMenuEntry(const simChar* entryLabel,simInt itemCount,simInt* itemHandles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>entryLabel</strong>: entry label. The same label can be used in consecutive calls (also from different plugins), in which case a sub-menu will group all items under the same label. If you do not plan adding several items, use &quot;&quot; for entryLabel.<br>
</div>
<div><strong>itemCount</strong>: number of items, including separators. If entryLabel is &quot;&quot;, then itemCount should be 1<br>
</div>
<div><strong>itemHandles</strong>: pointer to the item handles. Make sure the pointer can hold &quot;itemCount&quot; number of elements. Use <a href="#simSetModuleMenuItemState">simSetModuleMenuItemState</a> to set-up the individual items.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>



<h3><a name="simAddObjectCustomData" id="simAddObjectCustomData"></a>simAddObjectCustomData</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds or removes custom data to be stored and saved together with an object. This function is useful for external applications or plugin which want to save their data together with an object. Use in conjunction with <a href="#simGetObjectCustomData">simGetObjectCustomData</a> and <a href="#simGetObjectCustomDataLength">simGetObjectCustomDataLength</a>. See also <a href="#simAddSceneCustomData">simAddSceneCustomData</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddObjectCustomData(simInt objectHandle,simInt header,const simChar* data,simInt dataLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object where you want to store your data</div>
<div><strong>header</strong>: identifier for the custom data. If you plan to add custom data (as a company or individual), always use the same header (because only you will know what data type is stored under that header) and stick to it. The best is to use the serial number of your V-REP copy (check the &quot;Help&quot; menu, in the &quot;About&quot; item for the serial number). Otherwise, you risk collision with other developer's data which might use the same header as yours.<br>
</div>
<div><strong>data</strong>: your custom data. If NULL, the current data under that header will be removed. If you have several items or data types to save, it is your responsibility to pack and code it in data (don't use various headers for each of your items that you want to save with an object (risk of collision with other developers data (see above))!)<br>
</div>
<div><strong>dataLength</strong>: the length of your custom data</div>
<br>
<div>The data will be copied to an internal buffer inside of the object, and next time a scene or model is saved, will also be saved. The data buffer can be released after this call.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAddObjectCustomData(number objectHandle,number header,string data)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. (remember  that a string in Lua might contain any character, also embedded zeros)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simAddObjectToSelection" id="simAddObjectToSelection"></a>simAddObjectToSelection</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Adds an object to the selection 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddObjectToSelection(simInt what,simInt objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>what</strong>: indicates what we want to add. Valid values are sim_handle_single (adds just one object), sim_handle_all (adds all objects in the scene), sim_handle_tree (adds the tree with base objectHandle (inclusive)) and sim_handle_chain (adds the chain with tip objectHandle (inclusive))<br>
</div>
<div><strong>objectHandle</strong>: handle of an object. Doesn't have a meaning if &quot;what&quot; is sim_handle_all</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>There are two versions of this function:</div>
<div>(1) number result=simAddObjectToSelection(number what,number objectHandle)</div>
<div>(2) number result=simAddObjectToSelection(table objectHandles)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>(1) Same as C-function. The second argument can be omitted if &quot;what&quot; is sim_handle_all</div>
<div>(2) <strong>objectHandles</strong>: table of object handles. Can be nil</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simAddParticleObject" id="simAddParticleObject"></a>simAddParticleObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a particle object that will be simulated and displayed in the scene. Particle objects are containers that hold several items (particles) of a given type. This can be used for several different applications (e.g. simulation of air/water jets) See also <a href="#simAddParticleObjectItem">simAddParticleObjectItem</a> and <a href="#simRemoveParticleObject">simRemoveParticleObject</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddParticleObject(simInt objectType,simFloat size,simFloat density,const simVoid* parameters,simFloat lifeTime,simInt maxItemCount,const simFloat* ambient,const simFloat* diffuse,const simFloat* specular,const simFloat* emission)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectType</strong>: a <a href="apiConstants.htm#particleObjects">particle object type combined with attributes</a></div>
<div><strong>size</strong>: diameter of the particles (spheres)</div>
<div><strong>density</strong>: density of the particles</div>
<div><strong>parameters</strong>: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (and integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:
</div>
<div class=tab>0: Bullet fricition coefficient (default: 0.0)</div>
<div class=tab>1: Bullet restitution coefficient (default: 0.0)</div>
<div class=tab>2: ODE friction coefficient (default: 0.0)</div>
<div class=tab>3: ODE soft ERP value (default: 0.2)</div>
<div class=tab>4: ODE soft CFM values (default: 0.0)</div>
<div class=tab>5: Bullet and ODE linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)</div>
<div class=tab>6: Bullet and ODE quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)</div>
<div class=tab>7: Bullet and ODE linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)</div>
<div class=tab>8: Bullet and ODE quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)</div>
<div class=tab>If a parameter is not set, then its default value is used. As an example, following array: 2,0,0.5,2,0.5 will set Bullet's and ODE's friction coefficients to 0.5<br>
</div>
<div><strong>lifeTime</strong>: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.</div>
<div><strong>maxItemCount</strong>: the maximum number of particles that this object can hold</div>
<div><strong>ambient</strong>: default ambient color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>diffuse</strong>: default diffuse color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>specular</strong>: default specular color (pointer to 3 rgb values). Can be NULL</div>
<div><strong>emission</strong>: default emissive color (pointer to 3 rgb values). Can be NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the particle object if successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number particleObjectHandle=simAddParticleObject(number objectType,number size,number density,table parameters,number lifeTime,number maxItemCount,table_3 ambient=nil,table_3 diffuse=nil,table_3 specular=nil,table_3 emission=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simAddParticleObjectItem" id="simAddParticleObjectItem"></a>simAddParticleObjectItem</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds an item (or clears all items) to a previously inserted particle object. See also <a href="#simAddParticleObject">simAddParticleObject</a> and <a href="#simRemoveParticleObject">simRemoveParticleObject</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddParticleObjectItem(simInt objectHandle,const simFloat* itemData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a previously added particle object</div>
<div><strong>itemData</strong>: data relative to an item. All items (particles) require at least 6 values:Â p1x, p1y, p1z, p2x, p2y, p2z with p1 is the particle start position, p2-p1 is the particle initial velocity vector. Auxiliary values might be required depending on the particle object attributes. See the <a href="apiConstants.htm#particleObjects">particle object type combined with attributes</a> for more information. If NULL the particle object is emptied of all its items<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAddParticleObjectItem(number particleObjectHandle,table itemData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simAddSceneCustomData" id="simAddSceneCustomData"></a>simAddSceneCustomData</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds or removes custom data to be saved together with a scene. This function is useful for external applications or plugins which want to save their data together with a scene. Use in conjunction with <a href="#simGetSceneCustomData">simGetSceneCustomData</a> and <a href="#simGetSceneCustomDataLength">simGetSceneCustomDataLength</a>. See also <a href="#simAddObjectCustomData">simAddObjectCustomData</a> and <a href="#simPersistentDataWrite">simPersistentDataWrite</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddSceneCustomData(simInt header,const simChar* data,simInt dataLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>header</strong>: identifier for the custom data. If you plan to add custom data (as a company or individual), always use the same header (because only you will know what data type is stored under that header) and stick to it. The best is to use the serial number of your V-REP copy (check the &quot;Help&quot; menu, in the &quot;About&quot; item for the serial number). Otherwise, you risk collision with other developer's data which might use the same header as yours.<br>
</div>
<div><strong>data</strong>: your custom data. If NULL, the current data under that header will be removed. If you have several items or data types to save, it is your responsibility to pack and code it in data (don't use various headers for each of your items that you want to save with a scene (risk of collision with other developers data (see above))!)<br>
</div>
<div><strong>dataLength</strong>: the length of your custom data<br>
</div>
<br>
<div>The data will be copied to an internal buffer, and next time a scene is saved, will also be saved. The data buffer can be released after this call.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAddSceneCustomData(number header,string data)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. (remember  that a string in Lua might contain any character, also embedded zeros)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-Function.</div>
<div></div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simAddScript" id="simAddScript"></a>simAddScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inserts a new script. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddScript(simInt scriptProperty)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptProperty</strong>: property of the script. See the script type values.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the new script, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simAddStatusbarMessage" id="simAddStatusbarMessage"></a>simAddStatusbarMessage
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxAddStatusbarMessage">simxAddStatusbarMessage</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosAddStatusbarMessage">simRosAddStatusbarMessage</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Adds a message to the status bar 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAddStatusbarMessage(const simChar* message)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>message</strong>: message</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAddStatusbarMessage(string message)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simAdjustRealTimeTimer" id="simAdjustRealTimeTimer"></a>simAdjustRealTimeTimer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adjusts the real time timer of a simulation. This allows correcting for effects that might appear if for a reason or another the <a href="#simAdvanceSimulationByOneStep">simAdvanceSimulationByOneStep</a> cannot be called for some time (for instance during a resize action of the simulator window (the main thread is captured in a modal-type message loop)). This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAdjustRealTimeTimer(simInt instanceIndex,simFloat deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>instanceIndex</strong>: no use anymore. set to 0.<br>
</div>
<div><strong>deltaTime</strong>: time correction value in seconds</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simAdjustView" id="simAdjustView"></a>simAdjustView</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adjusts parameters of a view. See also the <a href="#simFloatingViewAdd">simFloatingViewAdd</a> and <a href="#simCameraFitToView">simCameraFitToView</a> functions.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAdjustView(simInt viewHandleOrIndex,simInt associatedViewableObjectHandle,simInt options,const simChar* viewLabel)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>viewHandleOrIndex</strong>: the handle of the view (can also be a floating view), or the index of the view.</div>
<div><strong>associatedViewableObjectHandle</strong>: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptied<br>
</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab><strong>bit0-bit3</strong>=the 3D display mode (0=solid rendering, 1=wireframe rendering)<br>
</div>
<div class=tab><strong>bit4</strong> set=orthogonal projection (otherwise perspective projection)<br>
</div>
<div class=tab><strong>bit5</strong> set=x/y graph display (otherwise time-graph display)</div>
<div class=tab><strong>bit6</strong> set=floating view is removed at simulation end</div>
<div><strong>viewLabel</strong>: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>A value &gt;0 in case of success</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAdjustView(number viewHandleOrIndex,number associatedViewableObjectHandle,number options,string viewLabel=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simAdvanceSimulationByOneStep" id="simAdvanceSimulationByOneStep"></a>simAdvanceSimulationByOneStep</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Advances the simulation time by one time step. Call this function only if the simulation is advancing (see <a href="#simGetSimulationState">simGetSimulationState</a>) and after having called <a href="#simHandleMainScript">simHandleMainScript</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAdvanceSimulationByOneStep()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simAnnounceSceneContentChange" id="simAnnounceSceneContentChange"></a>simAnnounceSceneContentChange</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Announces a change in the scene. This is required for the undo/redo function to operate properly with plugins. Only call this function directly after a change was made through a dialog element (e.g. a checkbox was checked/unchecked) and that change was reported to the scene (e.g. with <a href="#simAddSceneCustomData">simAddSceneCustomData</a> or <a href="#simAddObjectCustomData">simAddObjectCustomData</a>). What this call will do is following: the whole scene will be serialized (saved) to memory as a &quot;scene image&quot; and compared to a previously memorized &quot;scene image&quot;. If both images are same, then the last image is discarded, otherwise only the changes between the two images are memorized. A call to this function has no effect (and doesn't generate any error) when called during simulation or when in edit mode. This function is not available in the Lua-API  <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAnnounceSceneContentChange()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if nothing was memorized, or 1 if changes were memorized.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simApplyMilling" id="simApplyMilling"></a>simApplyMilling</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Applies changes made during milling operations to a cuttable object (e.g. a shape). This requires some calculation time. Once changes were applied, they cannot be reset anymore. If the milling operation milled away the whole object, then the object is removed from the scene. The calculation structure linked to the object is removed and an updated calculation structure might be calculated (might take some calculation time). See also <a href="#simResetMilling">simResetMilling</a>, <a href="#simHandleMill">simHandleMill</a> and <a href="#simResetMill">simResetMill</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simApplyMilling(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the cut object or sim_handle_all to apply changes to all cut objects. <br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if operation was successful but the object was removed from the scene (because entirely cut away) (only available when sim_handle_all is not specified), or 1 if operation was successful and the object still exists in the scene.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simApplyMilling(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simAssociateScriptWithObject" id="simAssociateScriptWithObject"></a>simAssociateScriptWithObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the associated object of a child script. See also <a href="#simGetObjectAssociatedWithScript">simGetObjectAssociatedWithScript</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAssociateScriptWithObject(simInt scriptHandle,simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the child script</div>
<div><strong>objectHandle</strong>: handle of the associated object, or -1 to remove the association</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>











<h3><a name="simAuxiliaryConsoleClose" id="simAuxiliaryConsoleClose"></a>simAuxiliaryConsoleClose
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxAuxiliaryConsoleClose">simxAuxiliaryConsoleClose</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosAuxiliaryConsoleClose">simRosAuxiliaryConsoleClose</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes an auxiliary console window. See also <a href="#simAuxiliaryConsoleOpen">simAuxiliaryConsoleOpen</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAuxiliaryConsoleClose(simInt consoleHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>consoleHandle</strong>: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen command<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window was closed.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAuxiliaryConsoleClose(number consoleHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simAuxiliaryConsoleOpen" id="simAuxiliaryConsoleOpen"></a>simAuxiliaryConsoleOpen
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxAuxiliaryConsoleOpen">simxAuxiliaryConsoleOpen</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosAuxiliaryConsoleOpen">simRosAuxiliaryConsoleOpen</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens an auxiliary console window for text display. This console window is different from the application main console window. Console window handles are shared across all simulator scenes. See also <a href="#simAuxiliaryConsolePrint">simAuxiliaryConsolePrint</a> and <a href="#simAuxiliaryConsoleClose">simAuxiliaryConsoleClose</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAuxiliaryConsoleOpen(const simChar* title,simInt maxLines,simInt mode,const simInt* position,const simInt* size,const simFloat* textColor,const simFloat* backgroundColor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>title</strong>: the title of the console window</div>
<div><strong>maxLines</strong>: the number of text lines that can be displayed and buffered</div>
<div><strong>mode</strong>: bit-coded value. Bit0 set indicates that the console window will automatically close at simulation end (when called from a <a href="mainScript.htm">main script</a> or a <a href="childScripts.htm">child script</a>, the consle window will always automatically close at simulation end), bit1 set indicates that lines will be wrapped, bit2 set indicates that the user can close the console window, bit3 set indicates that the console will automatically be hidden during simulation pause, bit4 set indicates that the console will not automatically hide when the user switches to another scene.<br>
</div>
<div><strong>position</strong>: the initial position of the console window (x and y value). Can be NULL<br>
</div>
<div><strong>size</strong>: the initial size of the console window (x and y value). Can be NULL<br>
</div>
<div><strong>textColor</strong>: the color of the text (rgb values, 0-1). Can be NULL<br>
</div>
<div><strong>backgroundColor</strong>: the background color of the console window (rgb values, 0-1). Can be NULL<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. Otherwise a console window handle</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number consoleHandle=simAuxiliaryConsoleOpen(string title,number maxLines,number mode,table_2 position=nil,table_2 size=nil,table_3 textColor=nil,table_3 backgroundColor=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. Last 4 parameters can be omitted too.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simAuxiliaryConsolePrint" id="simAuxiliaryConsolePrint"></a>simAuxiliaryConsolePrint
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxAuxiliaryConsolePrint">simxAuxiliaryConsolePrint</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosAuxiliaryConsolePrint">simRosAuxiliaryConsolePrint</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Prints to an auxiliary console window. See also <a href="#simAuxiliaryConsoleOpen">simAuxiliaryConsoleOpen</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAuxiliaryConsolePrint(simInt consoleHandle,const simChar* text)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>consoleHandle</strong>: the handle of the console window, previously returned by the <a href="#simAuxiliaryConsoleOpen">simAuxiliaryConsoleOpen</a> command<br>
</div>
<div><strong>text</strong>: the text to append, or NULL to clear the console window<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the operation was successful.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAuxiliaryConsolePrint(number consoleHandle,string text)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simAuxiliaryConsoleShow" id="simAuxiliaryConsoleShow"></a>simAuxiliaryConsoleShow
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxAuxiliaryConsoleShow">simxAuxiliaryConsoleShow</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosAuxiliaryConsoleShow">simRosAuxiliaryConsoleShow</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Shows or hides an auxiliary console window. See also <a href="#simAuxiliaryConsoleOpen">simAuxiliaryConsoleOpen</a> and <a href="#simAuxiliaryConsoleClose">simAuxiliaryConsoleClose</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simAuxiliaryConsoleShow(simInt consoleHandle,simBool showState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>consoleHandle</strong>: the handle of the console window, previously returned by the <a href="#simAuxiliaryConsoleOpen">simAuxiliaryConsoleOpen</a> command<br>
</div>
<div><strong>showState</strong>: indicates whether the console should be hidden (0) or shown (!=0)</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window's show state was changed.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simAuxiliaryConsoleShow(number consoleHandle,Boolean showState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simBoolAnd16" id="simBoolAnd16"></a>simBoolAnd16</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Performs a 16-bit Boolean AND operation between two numbers<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simBoolAnd16(number value1,number value2)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>value1</strong>: first value</div>
<div><strong>value2</strong>: second value</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Result of the Boolean operation or -1 in case of an error<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simBoolOr16" id="simBoolOr16"></a>simBoolOr16</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Performs a 16-bit Boolean OR operation between two numbers<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simBoolOr16(number value1,number value2)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>value1</strong>: first value</div>
<div><strong>value2</strong>: second value</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Result of the Boolean operation or -1 in case of an error<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simBoolXor16" id="simBoolXor16"></a>simBoolXor16</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Performs a 16-bit Boolean exclusive-OR operation between two numbers<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simBoolXor16(number value1,number value2)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>value1</strong>: first value</div>
<div><strong>value2</strong>: second value</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Result of the Boolean operation or -1 in case of an error<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simBreakForceSensor" id="simBreakForceSensor"></a>simBreakForceSensor
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxBreakForceSensor">simxBreakForceSensor</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosBreakForceSensor">simRosBreakForceSensor</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows breaking a force sensor during simulation. A broken force sensor will lose its positional and orientational constraints. See also <a href="#simReadForceSensor">simReadForceSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simBreakForceSensor(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object (must be a force sensor)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simBreakForceSensor(number objectHandle,number desiredBreakState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simBroadcastMessage" id="simBroadcastMessage"></a>simBroadcastMessage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows a plugin to communicate with other plugins by broadcasting messages or data that other plugins can intercept. The message is also sent to the plugin that originally broadcasted the message (that module is free to ignore its own message). See V-REP's main client application source code for more details. See also <a href="#simSendModuleMessage">simSendModuleMessage</a>. This function is not available in the Lua-API <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simVoid* simBroadcastMessage(simInt* auxiliaryData,simVoid* customData,simInt* replyData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>auxiliaryData</strong>: pointer to 4 integers. auxiliaryData[0] should be a unique identifier different from 0. Use the same identifier as the header you would use in the <a href="#simAddSceneCustomData">simAddSceneCustomData</a> or <a href="#simAddObjectCustomData">simAddObjectCustomData</a> function (i.e. your v-rep's serial number) if the message is yours. Otherwise, use the identifier of some other module. auxiliaryData[1] could be the messageID of the message you wish to send to another module. auxiliaryData[2] and auxiliaryData[3] can be any values specific to your application.<br>
</div>
<div><strong>customData</strong>: customData of your application (the broadcaster is in charge to release that buffer). Can be NULL.<br>
</div>
<div><strong>replyData</strong>: pointer to 4 integers that can be used by a module to reply to a broadcasted message. Can be NULL. If not NULL, all 4 values are automatically initialized to -1.<br>
</div>
<br>
<div>Broadcasted messages can be intercepted in a plugin's "v_repMessage"-function. In the function, broadcasted messages can be recognized when the function's first argument ("message") is sim_message_module_broadcast.
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to custom reply data that can be used by a module to reply to a broadcasted message. The module that replies is in charge of allocating the data with <a href="#simCreateBuffer">simCreateBuffer</a> and the original broadcaster is in charge of releasing that data with <a href="#simReleaseBuffer">simReleaseBuffer</a>. A reply to a broadcasted message is triggered by a module that writes a value different from -1 into auxiliaryData[0]-auxiliaryData[3], thus aborting further broadcast of the original message and returning to the broadcaster. If the return value is different from NULL, the broadcast is also interrupted.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simBuildIdentityMatrix" id="simBuildIdentityMatrix"></a>simBuildIdentityMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Builds an identity transformation matrix<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simBuildIdentityMatrix(simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=simBuildIdentityMatrix()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrix</strong>: table containing the identity matrix (except for the last row), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simBuildMatrix" id="simBuildMatrix"></a>simBuildMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Builds a transformation matrix based on a position vector and Euler angles. See also <a href="#simBuildMatrixQ">simBuildMatrixQ</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simBuildMatrix(const simFloat* position,const simFloat* eulerAngles,simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>position</strong>: pointer to 3 simFloat values representing the position component</div>
<div><strong>eulerAngles</strong>: pointer to 3 simFloat values representing the angular component</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values representing the transformation matrix</div>
<div class=tab>The x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component of the matrix is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=simBuildMatrix(table_3 position,table_3 eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>position</strong>: table to 3 numbers representing the position component</div>
<div><strong>eulerAngles</strong>: table to 3 numbers representing the angular component</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrix</strong>: table containing the transformation matrix (except for the last row), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>







<h3><a name="simBuildMatrixQ" id="simBuildMatrixQ"></a>simBuildMatrixQ</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Builds a transformation matrix based on a position vector and a quaternion. See also <a href="#simBuildMatrix">simBuildMatrix</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simBuildMatrixQ(const simFloat* position,const simFloat* quaternion,simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>position</strong>: pointer to 3 simFloat values representing the position component</div>
<div><strong>quaternion</strong>: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values representing the transformation matrix</div>
<div class=tab>The x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component of the matrix is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=simBuildMatrixQ(table_3 position,table_4 quaternion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>position</strong>: table of 3 numbers representing the position component</div>
<div><strong>quaternion</strong>: table of 4 numbers representing the orientation quaternion (x,y,z,w)</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrix</strong>: table containing the transformation matrix (except for the last row), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>







<h3><a name="simCameraFitToView" id="simCameraFitToView"></a>simCameraFitToView</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Shifts and adjusts a camera associated with a view to fill the view entirely with the specified objects or models. See also the <a href="#simAdjustView">simAdjustView</a> and <a href="#simFloatingViewAdd">simFloatingViewAdd</a> functions.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCameraFitToView(simInt viewHandleOrIndex,simInt objectCount,const simInt* objectHandles,simInt options,simFloat scaling)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>viewHandleOrIndex</strong>: the handle of the view (can also be a floating view), or the index of the view.</div>
<div><strong>objectCount</strong>: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.</div>
<div><strong>objectHandles</strong>: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.</div>
<div><strong>options</strong>: bit0: if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be included</div>
<div><strong>scaling</strong>: scaling factor. Use '1' for normal behaviour.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 for a silent error (e.g. when the indicated view doesn't exist anymore), 1 for success<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simCameraFitToView(number viewHandleOrIndex,table objectHandles=nil,simInt options=0,simFloat scaling=1)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function </div>
<div></div></td> 
</tr> 
</table> 
<br>







<h3><a name="simCheckCollision" id="simCheckCollision"></a>simCheckCollision</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether two entities are colliding. Detection is silent (no visual feedback) compared to <a href="#simHandleCollision">simHandleCollision</a>. Also, the collidable flags of the entities are overridden if the entities are objects. See also <a href="#simCheckCollisionEx">simCheckCollisionEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckCollision(simInt entity1Handle,simInt entity2Handle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objects<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 or 1 to indicate a collision state<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simCheckCollision(number entity1Handle,number entity2Handle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCheckCollisionEx" id="simCheckCollisionEx"></a>simCheckCollisionEx</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether two entities are colliding. This is the extended functionality version of <a href="#simCheckCollision">simCheckCollision</a>, and will return all intersections between the two entities. Detection is silent (no visual feedback) compared to <a href="#simHandleCollision">simHandleCollision</a>. Also, the collidable flags of the entities are overridden if the entities are objects.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckCollisionEx(simInt entity1Handle,simInt entity2Handle,simFloat** intersectionSegments)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objects<br>
</div>
<div><strong>intersectionSegments</strong>: pointer to an array of simFloat values that represent the intersections (segments) between the two entities (pt1(x,y,z), pt2(x,y,z), pt1(x,y,z), etc). This can be NULL. The user should use <a href="#simReleaseBuffer">simReleaseBuffer</a> to delete the returned data. That data is only valid if return value is &gt;0<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise the number of segments returned<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table intersections=simCheckCollisionEx(number entity1Handle,number entity2Handle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objects<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 for error, otherwise the number of segments returned</div>
<div><strong>intersections</strong>: a table that contains the intersection segments between the two entities.</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCheckDistance" id="simCheckDistance"></a>simCheckDistance</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks the minimum distance between two entities. Detection is silent (no visual feedback) compared to <a href="#simHandleDistance">simHandleDistance</a>. Also, the measurable flags of the entities are overridden if the entities are objects.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckDistance(simInt entity1Handle,simInt entity2Handle,simFloat threshold,simFloat* distanceData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)<br>
</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other measurable objects<br>
</div>
<div><strong>threshold</strong>: if distance is bigger than the threshold, the distance is not calculated and return value is 0. If threshold is 0 or negative, then no threshold is used.<br>
</div>
<div><strong>distanceData</strong>: distanceData[0]-distanceData[5] represents the distance segment, distanceData[6] is the distance between the entities. This data is valid only if return value is 1<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>0 or 1 if operation was successful (1 if distance is smaller than threshold), -1 otherwise<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table_7 distanceData=simCheckDistance(number entity1Handle,number entity2Handle,number threshold)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>entity1Handle</strong>: handle of entity 1 (can be an object handle or a collection handle)<br>
</div>
<div><strong>entity2Handle</strong>: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other measurable objects<br>
</div>
<div><strong>threshold</strong>: if distance is bigger than the threshold, the distance is not calculated and result is 0. If threshold is 0 or negative, then no threshold is used.<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 0 or 1 if operation was successful (1 if distance is smaller than threshold), -1 otherwise<br>
</div>
<div><strong>distanceData</strong>: distanceData[1]-distanceData[6] represents the distance segment, distanceData[7] is the distance between the entities. distanceData is nil if result is different from 1<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCheckProximitySensor" id="simCheckProximitySensor"></a>simCheckProximitySensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the proximity sensor detects the indicated entity. Detection is silent (no visual feedback) compared to <a href="#simHandleProximitySensor">simHandleProximitySensor</a>. Also, the detectable flags of the entity are overridden if the entity is an object. See also <a href="#simCheckProximitySensorEx">simCheckProximitySensorEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckProximitySensor(simInt sensorHandle,simInt entityHandle,simFloat* detectedPoint)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>detectedPoint</strong>: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULL<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint=simCheckProximitySensor(number sensorHandle,number entityHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 (error), 0 (not detected) or 1 (detected)</div>
<div><strong>distance</strong>: distance from the sensor origin to the detected point. Is nil if result is different from 1<br>
</div>
<div><strong>detectedPoint</strong>: position of the detected point relative to the sensor origin. Is nil if result is different from 1<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCheckProximitySensorEx" id="simCheckProximitySensorEx"></a>simCheckProximitySensorEx</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the proximity sensor detects the indicated entity. This is the extended functionality version of <a href="#simCheckProximitySensor">simCheckProximitySensor</a>. Detection is silent (no visual feedback) compared to <a href="#simHandleProximitySensor">simHandleProximitySensor</a>. Also, the detectable flags of the entity are overridden if the entity is an object. see also <a href="#simCheckProximitySensorEx2">simCheckProximitySensorEx2</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckProximitySensorEx(simInt sensorHandle,simInt entityHandle,simInt detectionMode,simFloat detectionThreshold,simFloat maxAngle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* surfaceNormalVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object<br>
</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>detectionMode</strong>: bit coded: bit0 for front face detection, bit1 for back face detection (bit0|bit1 needs to be true), bit2 for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 for limited angle detection (if set, maxAngle is taken into account), bit4 for occlusion check.<br>
</div>
<div><strong>detectionThreshold</strong>: doesn't detect objects farther than detectionThreshold distance from sensor origin<br>
</div>
<div><strong>maxAngle</strong>: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.<br>
</div>
<div><strong>detectedPoint</strong>: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULL<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULL<br>
</div>
<div><strong>surfaceNormalVector</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULL<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint,number detectedObjectHandle, table_3 surfaceNormalVector=simCheckProximitySensorEx(number sensorHandle,number entityHandle,number detectionMode,number detectionthreshold,number maxAngle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object<br>
</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>detectionMode</strong>: bit coded: bit0 for front face detection, bit1 for back face detection (bit0|bit1 needs to be true), bit2 for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 for limited angle detection (if set, maxAngle is taken into account).<br>
</div>
<div><strong>detectionThreshold</strong>: doesn't detect objects farther than detectionThreshold distance from sensor origin<br>
</div>
<div><strong>maxAngle</strong>: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 (error), 0 (not detected) or 1 (detected)</div>
<div><strong>distance</strong>: distance from the sensor origin to the detected point. Is nil if result is different from 1<br>
</div>
<div><strong>detectedPoint</strong>: position of the detected point relative to the sensor origin. Is nil if result is different from 1<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of detected object. Is nil if result is different from 1<br>
</div>
<div><strong>surfaceNormalVector</strong>: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Is nil if result is different from 1<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCheckProximitySensorEx2" id="simCheckProximitySensorEx2"></a>simCheckProximitySensorEx2</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the proximity sensor detects the indicated points, segments or triangles. Detection is silent (no visual feedback). See also <a href="#simCheckProximitySensorEx">simCheckProximitySensorEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckProximitySensorEx2(simInt sensorHandle,simFloat* vertexPointer,simInt itemType,simInt itemCount,simInt detectionMode,simFloat detectionThreshold,simFloat maxAngle,simFloat* detectedPoint,simFloat* normalVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object</div>
<div><strong>vertexPointer</strong>: a pointer to vertices</div>
<div><strong>itemType</strong>: 0 for points, 1 for segments and 2 for triangles</div>
<div><strong>itemCount</strong>: the number of items that vertexPointer points at</div>
<br>
<div>For the other parameters, see the description in <a href="#simCheckProximitySensorEx">simCheckProximitySensorEx</a>. (simCheckProximitySensorEx2 doesn't support occlusion checking)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint,table_3 normalVector=simCheckProximitySensorEx2(number sensorHandle,table vertices,number itemType,number itemCount,number mode,number threshold,number maxAngle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object</div>
<div><strong>vertices</strong>: a table containing vertices</div>
<div><strong>itemType</strong>: 0 for points, 1 for segments and 2 for triangles</div>
<div><strong>itemCount</strong>: the number of items that the 'vertices' table contains</div>
<br>
<div>For the other parameters, see the description in <a href="#simCheckProximitySensorEx">simCheckProximitySensorEx</a>. (simCheckProximitySensorEx2 doesn't support occlusion checking)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 (error), 0 (not detected) or 1 (detected)</div>
<br>
<div>For the other return values, see the description in <a href="#simCheckProximitySensorEx">simCheckProximitySensorEx</a>.<br>
</div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCheckVisionSensor" id="simCheckVisionSensor"></a>simCheckVisionSensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the vision sensor detects the indicated entity. Detection is silent (no visual feedback) compared to <a href="#simHandleVisionSensor">simHandleVisionSensor</a>. Also, the renderable flag of the entity is overridden if the entity is an object. See also <a href="#simCheckVisionSensorEx">simCheckVisionSensorEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCheckVisionSensor(simInt sensorHandle,simInt entityHandle,simFloat** auxValues,simInt** auxValuesCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>auxValues</strong>: auxiliary values returned from the applied filters (refer to the filter's documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValues).<br>
</div>
<div><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValuesCount).<br>
</div>
<br>
<div>Usage example:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
float* auxValues=NULL;
int* auxValuesCount=NULL;
float averageColor[3]={0.0f,0.0f,0.0f};
if (simCheckVisionSensor(sensorHandle,entityHandle,&auxValues,&auxValuesCount)>=0)
{
    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))
    {
        averageColor[0]=auxValues[11];
        averageColor[1]=auxValues[12];
        averageColor[2]=auxValues[13];
    }
    simReleaseBuffer((char*)auxValues);
    simReleaseBuffer((char*)auxValuesCount);
}</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table auxiliaryValuePacket1,table auxiliaryValuePacket2, etc.=simCheckVisionSensor(number sensorHandle,number entityHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the vision sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)</div>
<div><strong>auxiliaryValuePacket1</strong>: default auxiliary value packet (same as for the C-function) (table values in Lua are indexed from 1, not 0!)</div>
<div><strong>auxiliaryValuePacket2</strong>: additional auxiliary value packet (e.g. from a filter component)</div>
<div><strong>auxiliaryValuePacket3</strong>: etc. (the function returns as many tables as there are auxiliary value packets)</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCheckVisionSensorEx" id="simCheckVisionSensorEx"></a>simCheckVisionSensorEx</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the vision sensor detects the indicated entity. This is the extended functionality version of <a href="#simCheckVisionSensor">simCheckVisionSensor</a>. Detection is silent (no visual feedback) compared to <a href="#simHandleVisionSensor">simHandleVisionSensor</a>. Also, the renderable flag of the entity is overridden if the entity is an object. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat* simCheckVisionSensorEx(simInt sensorHandle,simInt entityHandle,simBool returnImage)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object</div>
<div><strong>entityHandle</strong>: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objects<br>
</div>
<div><strong>returnImage</strong>: specifies what should be returned. If true, the sensor's image buffer is returned, otherwise its depth buffer is returned<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>image or depth buffer (use <a href="#simGetVisionSensorResolution">simGetVisionSensorResolution</a> for correct size), or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table buffer=simCheckVisionSensorEx(number sensorHandle,number entityHandle,boolean returnImage)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to C-function: a table containing the image or depth buffer is returned (or nil in case of an error)<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simClearFloatSignal" id="simClearFloatSignal"></a>simClearFloatSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxClearFloatSignal">simxClearFloatSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosClearFloatSignal">simRosClearFloatSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears a float signal (removes it). See also <a href="#simSetFloatSignal">simSetFloatSignal</a>, <a href="#simClearIntegerSignal">simClearIntegerSignal</a> and <a href="#simClearStringSignal">simClearStringSignal</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simClearFloatSignal(const simChar* signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal or NULL to clear all float signals</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of signals cleared</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simClearFloatSignal(string signalName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simClearIntegerSignal" id="simClearIntegerSignal"></a>simClearIntegerSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxClearIntegerSignal">simxClearIntegerSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosClearIntegerSignal">simRosClearIntegerSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears an integer signal (removes it). See also <a href="#simSetIntegerSignal">simSetIntegerSignal</a>, <a href="#simClearFloatSignal">simClearFloatSignal</a> and <a href="#simClearStringSignal">simClearStringSignal</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simClearIntegerSignal(const simChar* signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal or NULL to clear all integer signals</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of signals cleared</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simClearIntegerSignal(string signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simClearStringSignal" id="simClearStringSignal"></a>simClearStringSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxClearStringSignal">simxClearStringSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosClearStringSignal">simRosClearStringSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears a string signal (removes it). See also <a href="#simSetStringSignal">simSetStringSignal</a>, <a href="#simClearIntegerSignal">simClearIntegerSignal</a> and <a href="#simClearFloatSignal">simClearFloatSignal</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simClearStringSignal(const simChar* signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal or NULL to clear all string signals</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of signals cleared</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simClearStringSignal(string signalName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCloseModule" id="simCloseModule"></a>simCloseModule</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Releases resources reserved with the <a href="#simOpenModule">simOpenModule</a> command. This command can only be called from the main script. Call it from the <a href="mainScript.htm">main script</a> in the last simulation pass (usually with sim_handle_all argument). simCloseModule is not available in the C-API. Look at the default main script to get an idea about how to use <a href="#simOpenModule">simOpenModule</a>, <a href="#simHandleModule">simHandleModule</a> and simCloseModule.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>number result=simCloseModule(number sim_handle_all)</div>
<div>number result=simCloseModule(string moduleName)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sim_handle_all</strong>: indicates that all plugins should be closed</div>
<div><strong>moduleName</strong>: the name of a specific plugin that should be closed</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, otherwise result is the number of plugins that executed the command.</div>
<div></div></td> 
</tr> 
</table> 
<br>




<h3><a name="simCloseScene" id="simCloseScene"></a>simCloseScene
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxCloseScene">simxCloseScene</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosCloseScene">simRosCloseScene</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes current scene, and switches to another open scene. If there is no other open scene, a new scene is then created. See also <a href="#simLoadScene">simLoadScene</a> and <a href="#simSaveScene">simSaveScene</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCloseScene()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>none</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the current scene index.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simConvexDecompose" id="simConvexDecompose"></a>simConvexDecompose</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calculates the <a href="convexDecomposition.htm">convex decomposition</a> of a <a href="shapes.htm">shape</a>. See also <a href="#simUngroupShape">simUngroupShape</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simConvexDecompose(simInt shapeHandle,simInt options,const simInt* intParams,const simFloat* floatParams)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape to operate on</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set: the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scene</div>
<div class=tab>bit1 set: specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.</div>
<div class=tab>bit2 set: same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.</div>
<div class=tab>bit3 set: extra points will be added when computing the concavity</div>
<div class=tab>bit4 set: faces points will be added when computing the concavity</div>
<div class=tab>bit5 set: each individual mesh of a grouped shape will be handled on its own during decomposition, otherwise the grouped shape is considered as a single mesh</div>
<div class=tab>bit6 set: convex elements have random colors for easier distinction</div>

<div><strong>intParams</strong>: 5 int values:</div>
<div class=tab>intParams[0]: the minimum number of clusters to be generated (e.g. 1)</div>
<div class=tab>intParams[1]: the targeted number of triangles of the decimated mesh (e.g. 500)</div>
<div class=tab>intParams[2]: the maximum number of vertices for each generated convex hull (e.g. 100)</div>
<div class=tab>intParams[3]: reserved. Set to 0.</div>
<div class=tab>intParams[4]: reserved. Set to 0.</div>

<div><strong>floatParams</strong>: 5 float values:</div>
<div class=tab>intParams[0]: the maximum allowed concavity (e.g. 100.0)</div>
<div class=tab>intParams[1]: the maximum allowed distance to get convex clusters connected (e.g. 30)</div>
<div class=tab>intParams[2]:  the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)</div>
<div class=tab>intParams[3]: reserved. Set to 0.0</div>
<div class=tab>intParams[4]: reserved. Set to 0.0</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. Otherwise the handle of the new shape, or the handle of the original shape when morphing.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number shapeHandle=simConvexDecompose(number shapeHandle,number options,table_3 intParams,table_3 floatParams)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCopyMatrix" id="simCopyMatrix"></a>simCopyMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Copies a transformation matrix<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCopyMatrix(const simFloat* matrixIn,simFloat* matrixOut)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixIn</strong>: matrix to be copied</div>
<div><strong>matrixOut</strong>: copy of matrixIn (after the call)</div>
<br>
<div>matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)<br>
</div>
<div>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])<br>
</div>
<div>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])<br>
</div>
<div>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])<br>
</div>
<div>The position component is (matrix[3],matrix[7],matrix[11])<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrixOut=simCopyMatrix(table_12 matrixIn)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>matrixIn</strong>: matrix to be copied</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>matrixOut</strong>: copied matrix, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCopyPasteSelectedObjects" id="simCopyPasteSelectedObjects"></a>simCopyPasteSelectedObjects
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxCopyPasteObjects">simxCopyPasteObjects</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosCopyPasteObjects">simRosCopyPasteObjects</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Copies and pastes all selected objects, together with all their associated calculation objects and child scripts. Pasted objects will then be selected. Objects marked as 'model base' will be copied, together will all their related objects (i.e. their hierarchy tree). You can TEMPORARILY disable this behaviour by setting the bool parameter <a href="apiConstants.htm#booleanParameters">sim_boolparam_full_model_copy_from_api</a> to false.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCopyPasteSelectedObjects()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simCopyPasteSelectedObjects()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateBuffer" id="simCreateBuffer"></a>simCreateBuffer (remote API equivalent: <a href="remoteApiFunctions.htm#simxCreateBuffer">simxCreateBuffer</a>)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a buffer. The buffer needs to be released with <a href="#simReleaseBuffer">simReleaseBuffer</a> except otherwise explicitly specified. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simCreateBuffer(simInt size)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>size</strong>: size of the buffer</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>buffer if operation was successful, NULL otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>











<h3><a name="simCreateDummy" id="simCreateDummy"></a>simCreateDummy</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="dummies.htm">dummy</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateDummy(simFloat size,const simFloat* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>size</strong>: the dummy size<br>
</div>
<div><strong>color</strong>: pointer to 4x3 values representing the dummy color (ambient rgb, diffuse rgb, specular rgb and emission rgb). Can be NULL for default values<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the dummy</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number dummyHandle=simCreateDummy(number size,table_12 color=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateForceSensor" id="simCreateForceSensor"></a>simCreateForceSensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="forceSensors.htm">force sensor</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateForceSensor(simInt options,const simInt* intParams,const simFloat* floatParams,const float* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set: force threshold enabled</div>
<div class=tab>bit 1 set: torque threshold enabled</div>
<div><strong>intParams (input)</strong>: 5 integer parameters:</div>
<div class=tab>intParams[0]: filter type (0=average, 1=median)</div>
<div class=tab>intParams[1]: value count the filter operates on</div>
<div class=tab>intParams[2]: number of consecutive threshold violation for the sensor to break</div>
<div class=tab>intParams[3]: reserved. Set to 0</div>
<div class=tab>intParams[4]: reserved. Set to 0</div>
<div><strong>floatParams (input)</strong>: 5 floating point parameters:</div>
<div class=tab>floatParams[0]: sensor size</div>
<div class=tab>floatParams[1]: force threshold value</div>
<div class=tab>floatParams[2]: torque threshold value</div>
<div class=tab>floatParams[3]: reserved. Set to 0.0</div>
<div class=tab>floatParams[4]: reserved. Set to 0.0</div>
<div><strong>color</strong>: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient rgb, diffuse rgb, specular rgb and emission rgb)). Can be NULL for default values<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the force sensor</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sensorHandle=simCreateForceSensor(number options,table_5 intParams,table_5 floatParams,table_24 color=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateHeightfieldShape" id="simCreateHeightfieldShape"></a>simCreateHeightfieldShape</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a heightfield <a href="shapes.htm">shape</a>. See also <a href="#simCreatePureShape">simCreatePureShape</a>, <a href="#simCreateMeshShape">simCreateMeshShape</a> and <a href="#simAddParticleObject">simAddParticleObject</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateHeightfieldShape(simInt options,simFloat shadingAngle,simInt xPointCount,simInt yPointCount,simFloat xSize,const simFloat* heights)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: Bit-coded: if bit0 is set, backfaces are culled. If bit1 is set, edges are visible.<br>
</div>
<div><strong>shadingAngle</strong>: the shading angle</div>
<div><strong>xPointCount/yPointCount</strong>: the number of rows and lines of the heightfield.</div>
<div><strong>xSize</strong>: the length of the x side of the heightfield</div>
<div><strong>heights</strong>: a pointer to xPointCount*yPointCount height values.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the newly created shape<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=simCreateHeightfieldShape(number options,number shadingAngle,number xPointCount,number yPointCount,number xSize,table heights)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateJoint" id="simCreateJoint"></a>simCreateJoint</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="joints.htm">joint</a>. See also <a href="#simSetJointInterval">simSetJointInterval</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateJoint(simInt jointType,simInt jointMode,simInt options,const simFloat* sizes,const simFloat* colorA,const simFloat* colorB)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointType</strong>: <a href="apiConstants.htm#sceneObjectSubTypes">sim_joint_revolute_subtype</a>, <a href="apiConstants.htm#sceneObjectSubTypes">sim_joint_prismatic_subtype</a> or <a href="apiConstants.htm#sceneObjectSubTypes">sim_joint_spherical_subtype</a><br>
</div>
<div><strong>jointMode</strong>: a <a href="apiConstants.htm#jointModes">joint mode</a> value</div>
<div><strong>options</strong>: bit-coded. For now only bit 0 is used (if set, the joint operates in hybrid mode)</div>
<div><strong>sizes</strong>: pointer to 2 values indicating the joint length and diameter. Can be NULL for default values<br>
</div>
<div><strong>colorA</strong>: pointer to 4x3 values for joint color A (ambient rgb, diffuse rgb, specular rgb and emission rgb). Can be NULL for default values<br>
</div>
<div><strong>colorB</strong>: pointer to 4x3 values for joint color B (ambient rgb, diffuse rgb, specular rgb and emission rgb). Can be NULL for default values<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the joint</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number jointHandle=simCreateJoint(number jointType,number jointMode,number options,table_2 sizes=nil,table_12 colorA=nil,table_12 colorB=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateMeshShape" id="simCreateMeshShape"></a>simCreateMeshShape</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a mesh shape. See also <a href="#simCreatePureShape">simCreatePureShape</a>, <a href="#simCreateHeightfieldShape">simCreateHeightfieldShape</a> and <a href="#simGetShapeMesh">simGetShapeMesh</a>, and see <a href="#simImportMesh">simImportMesh</a> for a usage example.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateMeshShape(simInt options,simFloat shadingAngle,const simFloat* vertices,simInt verticesSize,const simInt* indices,simInt indicesSize,simFloat* reserved)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: Bit-coded: if bit0 is set, backfaces are culled. If bit1 is set, edges are visible</div>
<div><strong>shadingAngle</strong>: the shading angle</div>
<div><strong>vertices</strong>: an array of vertices</div>
<div><strong>verticesSize</strong>: the size of the vertice array</div>
<div><strong>indices</strong>: an array of indices</div>
<div><strong>indicesSize</strong>: the size of the indice array</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the newly created shape<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=simCreateMeshShape(number options,number shadingAngle,table vertices,table indices)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>options</strong>: Bit-coded: if bit0 is set, backfaces are culled. If bit1 is set, edges are visible</div>
<div><strong>shadingAngle</strong>: the shading angle</div>
<div><strong>vertices</strong>: a table of vertices</div>
<div><strong>indices</strong>: a table of indices</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateProximitySensor" id="simCreateProximitySensor"></a>simCreateProximitySensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="proximitySensors.htm">proximity sensor</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateProximitySensor(simInt sensorType,simInt subType,simInt options,const simInt* intParams,const simFloat* floatParams,const simFloat* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorType</strong>: the desired <a href="apiConstants.htm#sceneObjectSubTypes">proximity sensor type</a> (e.g. sim_proximitysensor_cone_subtype)</div>
<div><strong>subType</strong>: the desired <a href="apiConstants.htm#sceneObjectSpecialProperties">proximity sensor sub-type</a> (e.g. sim_objectspecialproperty_detectable_ultrasonic)</div>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set: the sensor will be explicitely handled</div>
<div class=tab>bit 1 set: the detection volumes are not shown when detecting something</div>
<div class=tab>bit 2 set: the detection volumes are not shown when not detecting anything</div>
<div class=tab>bit 3 set: front faces are not detected</div>
<div class=tab>bit 4 set: back faces are not detected</div>
<div class=tab>bit 5 set: fast detection (i.e. not exact detection)</div>
<div class=tab>bit 6 set: the normal of the detected surface with the detection ray will have to lie below a specified threshold angle</div>
<div class=tab>bit 7 set: occlusion check is active</div>
<div class=tab>bit 8 set: smallest distance threshold will be active</div>
<div class=tab>bit 9 set: randomized detection (only with ray-type proximity sensors)</div>
<div><strong>intParams (input)</strong>: 8 integer parameters:</div>
<div class=tab>intParams[0]: face count (volume description)</div>
<div class=tab>intParams[1]: face count far (volume description)</div>
<div class=tab>intParams[2]: subdivisions (volume description)</div>
<div class=tab>intParams[3]: subdivisions far (volume description)</div>
<div class=tab>intParams[4]: randomized detection, sample count per reading</div>
<div class=tab>intParams[5]: randomized detection, individual ray detection count for triggering</div>
<div class=tab>intParams[6]: reserved. Set to 0</div>
<div class=tab>intParams[7]: reserved. Set to 0</div>
<div><strong>floatParams (input)</strong>: 15 floating point parameters:</div>
<div class=tab>floatParams[0]: offset (volume description)</div>
<div class=tab>floatParams[1]: range (volume description)</div>
<div class=tab>floatParams[2]: x size (volume description)</div>
<div class=tab>floatParams[3]: y size (volume description)</div>
<div class=tab>floatParams[4]: x size far (volume description)</div>
<div class=tab>floatParams[5]: y size far (volume description)</div>
<div class=tab>floatParams[6]: inside gap (volume description)</div>
<div class=tab>floatParams[7]: radius (volume description)</div>
<div class=tab>floatParams[8]: radius far (volume description)</div>
<div class=tab>floatParams[9]: angle (volume description)</div>
<div class=tab>floatParams[10]: threshold angle for limited angle detection (see bit 6 above)</div>
<div class=tab>floatParams[11]: smallest detection distance (see bit 8 above)</div>
<div class=tab>floatParams[12]: sensing point size</div>
<div class=tab>floatParams[13]: reserved. Set to 0.0</div>
<div class=tab>floatParams[14]: reserved. Set to 0.0</div>
<div><strong>color</strong>: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient rgb, diffuse rgb, specular rgb and emission rgb)). Can be NULL for default values<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the force sensor</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sensorHandle=simCreateProximitySensor(number sensorType,number subType,number options,table_8 intParams,table_15 floatParams,table_48 color=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCreatePureShape" id="simCreatePureShape"></a>simCreatePureShape</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a pure primitive shape. See also <a href="#simCreateMeshShape">simCreateMeshShape</a>, <a href="#simCreateHeightfieldShape">simCreateHeightfieldShape</a> and <a href="#simAddParticleObject">simAddParticleObject</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreatePureShape(simInt primitiveType,simInt options,const simFloat* sizes,simFloat mass,const simInt* precision)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>primitiveType</strong>: 0 for a cuboid, 1 for a sphere, 2 for a cylinder and 3 for a cone</div>
<div><strong>options</strong>: Bit-coded: if bit0 is set, backfaces are culled. If bit1 is set, edges are visible. If bit2 is set, the shape appears smooth. If bit3 is set, the shape is respondable. If bit4 is set, the shape is static. If bit5 is set, the cylinder has open ends<br>
</div>
<div><strong>sizes</strong>: 3 values indicating the size of the shape</div>
<div><strong>mass</strong>: the mass of the shape</div>
<div><strong>precision</strong>: 2 values that allow specifying the number of sides and faces of a cylinder or sphere. Can be NULL for default values<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the newly created shape<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=simCreatePureShape(number primitiveType,number options,table_3 sizes,number mass,table_2 precision=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateUI" id="simCreateUI"></a>simCreateUI</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Creates an empty custom user interface. See also <a href="#simRemoveUI">simRemoveUI</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateUI(const simChar* uiName,simInt menuAttributes,const simInt* clientSize,const simInt* cellSize,simInt* buttonHandles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiName</strong>: name of the custom user interface. If custom user interface with such a name already exists, a new name is generated and no error produced<br>
</div>
<div><strong>menuAttributes</strong>: combination of <a href="apiConstants.htm#uiMenuAttributes">custom user interface menu attributes</a>. Set to 0 for a menuless custom user interface<br>
</div>
<div><strong>clientSize</strong>: sizes (in terms of cells (x and y)) of the client surface. (client surface=surface minus the menu bar space)<br>
</div>
<div><strong>cellSize</strong>: cell sizes (x and y). must be a multiple of 2<br>
</div>
<div><strong>buttonHandles</strong>: handles of buttons as specified in the menuAttributes. Array size must be appropriate</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of custom user interface if value &gt;=0, -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number uiHandle,table buttonHandles=simCreateUI(string uiName,number menuAttributes,table_2 clientSize,table_2 cellSize)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>uiName</strong>: name of the custom user interface. If a custom user interface with such a name already exists, a new name is generated and no error produced<br>
</div>
<div><strong>menuAttributes</strong>: combination of <a href="apiConstants.htm#uiMenuAttributes">custom user interface menu attributes</a>. Set to 0 for a menuless custom user interface<br>
</div>
<div><strong>clientSize</strong>: sizes (in terms of cells (x and y)) of the client surface. (client surface=surface minus the menu bar space)<br>
</div>
<div><strong>cellSize</strong>: cell sizes (x and y). must be a multiple of 2</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>uiHandle</strong>: handle of the newly created custom user interface if value &gt;=0, error otherwise</div>
<div><strong>buttonHandles</strong>: handles of the created buttons. Is nil if uiHandle is -1.</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateUIButton" id="simCreateUIButton"></a>simCreateUIButton</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a button inside of a custom user interface<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateUIButton(simInt uiHandle,const simInt* position,const simInt* size,simInt buttonProperty)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle to a valid custom user interface</div>
<div><strong>position</strong>: position of the button (in terms of cells (x and y))</div>
<div><strong>size</strong>: size of the button (in terms of cells (x and y))</div>
<div><strong>buttonProperty</strong>: button property. Combination of <a href="apiConstants.htm#uiButtonProperties">button property values</a>.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the button, or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number buttonHandle=simCreateUIButton(number uiHandle,table_2 position,table_2 size,number buttonProperty)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateUIButtonArray" id="simCreateUIButtonArray"></a>simCreateUIButtonArray</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates an array inside a custom user interface button. Use this to display big arrays instead of creating an array with individual buttons (slower and not memory efficient). The size of the array is the number of cells inside of the button horizontally and vertically. See also <a href="#simDeleteUIButtonArray">simDeleteUIButtonArray</a> and <a href="#simSetUIButtonArrayColor">simSetUIButtonArrayColor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateUIButtonArray(simInt uiHandle,simInt buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle of a valid custom user interface</div>
<div><strong>buttonHandle</strong>: handle of a valid button in the specified custom user interface</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simCreateUIButtonArray(number uiHandle,number buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simCreateVisionSensor" id="simCreateVisionSensor"></a>simCreateVisionSensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Creates a <a href="visionSensors.htm">vision sensor</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simCreateVisionSensor(simInt options,const simInt* intParams,const simFloat* floatParams,const simFloat* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>options</strong>: bit-coded options:</div>
<div class=tab>bit 0 set: the sensor will be explicitely handled</div>
<div class=tab>bit 1 set: the sensor will be in perspective operation mode</div>
<div class=tab>bit 2 set: the sensor volume will not be shown when not detecting anything</div>
<div class=tab>bit 3 set: the sensor volume will not be shown when detecting something</div>
<div class=tab>bit 4 set: the sensor will be passive (use an external image)</div>
<div class=tab>bit 5 set: the sensor will use local lights</div>
<div class=tab>bit 6 set: the sensor will not render any fog</div>
<div class=tab>bit 7 set: the sensor will use a specific color for default background (i.e. "null" pixels)</div>
<div><strong>intParams (input)</strong>: 4 integer parameters:</div>
<div class=tab>intParams[0]: sensor resolution x</div>
<div class=tab>intParams[1]: sensor resolution y</div>
<div class=tab>intParams[2]: reserved. Set to 0</div>
<div class=tab>intParams[3]: reserved. Set to 0</div>
<div><strong>floatParams (input)</strong>: 11 floating point parameters:</div>
<div class=tab>floatParams[0]: near clipping plane</div>
<div class=tab>floatParams[1]: far clipping plane</div>
<div class=tab>floatParams[2]: view angle / ortho view size</div>
<div class=tab>floatParams[3]: sensor size x</div>
<div class=tab>floatParams[4]: sensor size y</div>
<div class=tab>floatParams[5]: sensor size z</div>
<div class=tab>floatParams[6]: "null" pixel red-value</div>
<div class=tab>floatParams[7]: "null" pixel green-value</div>
<div class=tab>floatParams[8]: "null" pixel blue-value</div>
<div class=tab>floatParams[9]: reserved. Set to 0.0</div>
<div class=tab>floatParams[10]: reserved. Set to 0.0</div>
<div><strong>color</strong>: pointer to 4x4x3 values representing the various colors of the sensor ((body passive, body active, volume passive, volume active) x (ambient rgb, diffuse rgb, specular rgb and emission rgb)). Can be NULL for default values<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the handle of the force sensor</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sensorHandle=simCreateVisionSensor(number options,table_4 intParams,table_11 floatParams,table_48 color=nil)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simDelegateChildScriptExecution" id="simDelegateChildScriptExecution"></a>simDelegateChildScriptExecution</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Delegates the non-explicit <a href="childScripts.htm">child script</a> executions to the <a href="mainScript.htm">main script</a>. This should always be called as the first instruction in scripts that launch a thread, in order to make sure their child scripts will always be called, no matter what (e.g. if the script that launches a thread calls simWait(1000), then its child scripts will not be called during 1000 seconds, unless simDelegateChildScriptExecution was called previously). What effectively happens when this function is called is following: the script calls a single time <a href="#simHandleChildScript">simHandleChildScript</a>(sim_handle_all_except_explicit) (it previously temporarily elevates the thread switch timing to 1 second) and then instructs the main script to take over the handling of its non-explicit child scripts every time the main script calls <a href="#simHandleChildScript">simHandleChildScript</a>. Repeated calls from the same script to simDelegateChildScriptExecution are ignored. Once simDelegateChildScriptExecution was called, the script can only make explicit calls to <a href="#simHandleChildScript">simHandleChildScript</a>. This function can only be called from child scripts that launch a thread and is not available from the C-API.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simDelegateChildScriptExecution()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simDeleteSelectedObjects" id="simDeleteSelectedObjects"></a>simDeleteSelectedObjects</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Deletes all selected objects. A script that is calling this function might also get deleted. In that case, in order to avoid Lua call error messages, directly call &quot;return&quot; after this function.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simDeleteSelectedObjects()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simDeleteSelectedObjects()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simDeleteUIButtonArray" id="simDeleteUIButtonArray"></a>simDeleteUIButtonArray</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Deletes (removes) a custom user interface button array previously created with <a href="#simCreateUIButtonArray">simCreateUIButtonArray</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simDeleteUIButtonArray(simInt uiHandle,simInt buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle of a valid custom user interface</div>
<div><strong>buttonHandle</strong>: handle of a valid button in the specified custom user interface</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simDeleteUIButtonArray(number uiHandle,number buttonHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simDisplayDialog" id="simDisplayDialog"></a>simDisplayDialog
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxDisplayDialog">simxDisplayDialog</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosDisplayDialog">simRosDisplayDialog</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Displays a generic dialog box. Use in conjunction with <a href="#simGetDialogResult">simGetDialogResult</a> ,<a href="#simGetDialogInput">simGetDialogInput</a> and <a href="#simEndDialog">simEndDialog</a>. From C, the function will only create non-modal dialogs (non-blocking), from Lua, modal dialogs can be created if called from a child script that runs in a thread. Use custom user interfaces instead if a higher customization level is required. Dialogs displayed from a <a href="mainScript.htm">main script</a> or a <a href="childScripts.htm">child script</a> will automatically close at simulation end. See also <a href="#simMsgBox">simMsgBox</a> and <a href="#simFileDialog">simFileDialog</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simDisplayDialog(const simChar* titleText,const simChar* mainText,simInt dialogType,const simChar* initialText,const simFloat* titleColors,const simFloat* dialogColors,simInt* uiHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>titleText</strong>: Title bar text</div>
<div><strong>mainText</strong>: Information text</div>
<div><strong>dialogType</strong>: <a href="apiConstants.htm#genericDialogStyles">generic dialog style</a></div>
<div><strong>initialText</strong>: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULL</div>
<div><strong>titleColors</strong>: Title bar color (6 simFloat values for RGB for background and foreground), can be NULL for default colors</div>
<div><strong>dialogColors</strong>: Dialog color (6 simFloat values for RGB for background and foreground), can be NULL for default colors</div>
<div><strong>uiHandle</strong>: corresponding custom user interface handle. Can be NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of generic dialog (different from custom user interface handle!!) if operation was successful, -1 otherwise. The handle should be used with following functions: <a href="#simGetDialogResult">simGetDialogResult</a> ,<a href="#simGetDialogInput">simGetDialogInput</a> and <a href="#simEndDialog">simEndDialog</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number dialogHandle,number uiHandle=simDisplayDialog(string titleText,string mainText,number dialogType,boolean modalDialog,string initialText,table_6 titleColors,table_6 dialogColors,number uiHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>titleText</strong>: Title bar text</div>
<div><strong>mainText</strong>: information text</div>
<div><strong>dialogType</strong>: generic dialog style</div>
<div><strong>modalDialog</strong>: specifies whether the dialog is modal. Modal dialogs are only allowed when not called from the main thread.<br>
</div>
<div><strong>initialText</strong>: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be nil or omitted<br>
</div>
<div><strong>titleColors</strong>: Title bar color (6 values for RGB for background and foreground), can be nil for default colors, or omitted<br>
</div>
<div><strong>dialogColors</strong>: Dialog color (6 values for RGB for background and foreground), can be nil for default colors, or omitted<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>dialogHandle</strong>: handle of generic dialog (different from custom user interface handle!!), or nil if operation failed</div>
<div><strong>uiHandle</strong>: handle of corresponding custom user interface, or nil if operation failed</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simDoesFileExist" id="simDoesFileExist"></a>simDoesFileExist</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Indicates whether a file exists. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simDoesFileExist(const simChar* filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: The filename extension is required</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if the filename exists, 0 if it does not exist, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simEndDialog" id="simEndDialog"></a>simEndDialog
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxEndDialog">simxEndDialog</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosEndDialog">simRosEndDialog</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes and releases resource from a previous call to <a href="#simDisplayDialog">simDisplayDialog</a>. Even if the dialog is not visible anymore, you should release resources by using this function (however at the end of a simulation, all dialog resources allocated from a <a href="mainScript.htm">main script</a> or a <a href="childScripts.htm">child script</a> are automatically released).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simEndDialog(simInt genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>genericDialogHandle</strong>: handle of generic dialog (return value of simDisplayDialog)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simEndDialog(number genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simExportMesh" id="simExportMesh"></a>simExportMesh</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Exports a mesh to a file. See also <a href="#simImportMesh">simImportMesh</a> and <a href="#simGetShapeMesh">simGetShapeMesh</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simExportMesh(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat scalingFactor,simInt elementCount,simFloat** vertices,const simInt* verticesSizes,simInt** indices,const simInt* indicesSizes,simFloat** reserved,simChar** names)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>fileformat</strong>: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL format</div>
<div><strong>pathAndFilename</strong>: the location of the file to create.</div>
<div><strong>options</strong>: keep at 0</div>
<div><strong>scalingFactor</strong>: the scaling factor to apply to the vertices to export</div>
<div><strong>vertices</strong>: an array to vertice arrays. See the example below</div>
<div><strong>verticesSizes</strong>: an array indicating the individual vertice array sizes. See the example below</div>
<div><strong>indices</strong>: an array to indice arrays. See the example below</div>
<div><strong>indicesSizes</strong>: an array indicating the individual indice array sizes. See the example below</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL.</div>
<div><strong>names</strong>: an array to mesh names. See the example below</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
// Exports all shapes in the scene
simInt shapeCount=0;
while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);
shapeCount--;
simFloat** vertices=new simFloat*[shapeCount];
simInt* verticesSizes=new simInt[shapeCount];
simInt** indices=new simInt*[shapeCount];
simInt* indicesSizes=new simInt[shapeCount];
simChar** names=new simChar*[shapeCount];
simInt index=0;
while (true)
{
    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);
    if (shapeHandle&#60;0)
        break;
    simFloat* vert;
    simInt vertS;
    simInt* ind;
    simInt indS;
    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);
    vertices[index-1]=vert;
    verticesSizes[index-1]=vertS;
    indices[index-1]=ind;
    indicesSizes[index-1]=indS;
    names[index-1]=simGetObjectName(shapeHandle);
    simFloat m[12];
    simGetObjectMatrix(shapeHandle,-1,m);
    for (simInt i=0;i&#60;vertS/3;i++)
    {
        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};
        simTransformVector(m,v);
        vert[3*i+0]=v[0];
        vert[3*i+1]=v[1];
        vert[3*i+2]=v[2];
    }
}
simExportMesh(1,"d:\\example.dxf",0,1,shapeCount,vertices,
                 verticesSizes,indices,indicesSizes,NULL,names);
for (simInt i=0;i&#60;shapeCount;i++)
{
    simReleaseBuffer((simChar*)vertices[i]);
    simReleaseBuffer((simChar*)indices[i]);
    simReleaseBuffer(names[i]);
}
delete[] vertices;
delete[] verticesSizes;
delete[] indices;
delete[] indicesSizes;
delete[] names;</pre>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simExportMesh(number fileformat,string pathAndFilename,number options,number scalingFactor,table_of_table vertices,table_of_table indices,nil,table names)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>fileformat</strong>: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL format</div>
<div><strong>pathAndFilename</strong>: the location of the file to create.</div>
<div><strong>options</strong>: keep at 0</div>
<div><strong>scalingFactor</strong>: the scaling factor to apply to the vertices to export</div>
<div><strong>vertices</strong>: a table of vertice tables. See the example below</div>
<div><strong>indices</strong>: a table of indice tables. See the example below</div>
<div><strong>nil</strong>: reserved for future extensions.</div>
<div><strong>names</strong>: a table of mesh names. See the example below</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightRedBoxNoMarginAndSmall>
-- Exports all shapes in the scene
if (simGetScriptExecutionCount()==0) then
    allVertices={}
    allIndices={}
    allNames={}
    shapeIndex=0
    while (true) do
        h=simGetObjects(shapeIndex,sim_object_shape_type)
        if (h&#60;0) then
            break
        end
        shapeIndex=shapeIndex+1
        vertices,indices=simGetShapeMesh(h)
        m=simGetObjectMatrix(h,-1)
        for i=1,#vertices/3,1 do
            v={vertices[3*(i-1)+1],vertices[3*(i-1)+2],vertices[3*(i-1)+3]}
            v=simMultiplyVector(m,v)
            vertices[3*(i-1)+1]=v[1]
            vertices[3*(i-1)+2]=v[2]
            vertices[3*(i-1)+3]=v[3]
        end
        table.insert(allVertices,vertices)
        table.insert(allIndices,indices)
        table.insert(allNames,simGetObjectName(h))
    end
    if (#allVertices>0) then
        simExportMesh(1,"d:\\example.dxf",0,1,allVertices,allIndices,nil,allNames)
    end
end</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simFileDialog" id="simFileDialog"></a>simFileDialog</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a dialog that allows selecting a file for save or load operations. Should only be called from the main thread. See also <a href="#simMsgBox">simMsgBox</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simFileDialog(simInt dlgType,const simChar* title,const simChar* startPath,const simChar* initName,const simChar* extName,const simChar* ext)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dlgType</strong>: the <a href="apiConstants.htm#fileDlgTypes">file dialog type</a>.</div>
<div><strong>title</strong>: title of the dialog</div>
<div><strong>startPath</strong>: the initial path. Indicate an empty string for the path to V-REP's application</div>
<div><strong>initName</strong>: the initial name. Can be an empty string</div>
<div><strong>extName</strong>: the extension name, e.g. &quot;text file&quot;</div>
<div><strong>ext</strong>: the extension, e.g. &quot;txt&quot;</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to a string representing the selected file name and path. The user is in charge of releasing the buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string pathAndName=simFileDialog(number mode,string title,string startPath,string initName,string extName,string ext)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simFloatingViewAdd" id="simFloatingViewAdd"></a>simFloatingViewAdd</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Adds a floating view to current page. See also the <a href="#simFloatingViewRemove">simFloatingViewRemove</a>, <a href="#simAdjustView">simAdjustView</a> and <a href="#simCameraFitToView">simCameraFitToView</a> functions.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simFloatingViewAdd(simFloat posX,simFloat posY,simFloat sizeX,simFloat sizeY,simInt options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>posX &amp; posY</strong>: relative position of the center of the floating view. Accepted values are between 0 and 1.</div>
<div><strong>sizeX &amp; sizeY</strong>: relative size of the floating view. Accepted values are between 0 and 1.</div>
<div><strong>options</strong>: bit-coded:</div>
<div class=tab>bit0 set=double click allows swapping the floating view with the main view</div>
<div class=tab>bit1 set=the floating view doesn't have a close button</div>
<div class=tab>bit2 set=the floating view cannot be shifted</div>
<div class=tab>bit3 set=the floating view cannot be resized</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the floating view, or -1 in case of an error. <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number floatingViewHandle=simFloatingViewAdd(number posX,number posY,number sizeX,number sizeY,number options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>










<h3><a name="simFloatingViewRemove" id="simFloatingViewRemove"></a>simFloatingViewRemove</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a floating view previously added with <a href="#simFloatingViewAdd">simFloatingViewAdd</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simFloatingViewRemove(simInt floatingViewHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>floatingViewHandle</strong>: handle of the floating view to be removed</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the floating view could not be found (e.g. because closed by the user), or 1 if the floating view was closed. <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simFloatingViewRemove(number floatingViewHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>







<h3><a name="simFollowPath" id="simFollowPath"></a>simFollowPath</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Moves an object along a path object. This function can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is a blocking operation) and is not available from the C-API. See also <a href="#simRMLPosition">simRMLPosition</a>, <a href="#simRMLVelocity">simRMLVelocity</a> and <a href="#simMoveToObject">simMoveToObject</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number deltaTimeLeft =simFollowPath(number objectHandle,number pathHandle,number positionAndOrOrientation,number relativeDistanceOnPath,number velocity,number accel)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the object to be moved<br>
</div>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>positionAndOrOrientation</strong>: a value between 1 and 3 (1: only position is modified, 2: only orientation is modified, 3: position and orientation is modified). Can be nil in which case 3 is applied.<br>
</div>
<div><strong>relativeDistanceOnPath</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method (refer to the <a href="pathPositionCalculationMethod.htm">path position calculation method</a> section).<br>
</div>
<div><strong>velocity</strong>: movement nominal velocity. </div>
<div><strong>accel</strong>: the acceleration/deceleration.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>deltaTimeLeft</strong>: if the time needed to follow the path is not a multiple of the simulation time step, then deltatimeLeft is the execution time left at current simulation time. deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is nil in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetArrayParameter" id="simGetArrayParameter"></a>simGetArrayParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetArrayParameter">simxGetArrayParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetArrayParameter">simRosGetArrayParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves 3 values from an array. See the <a href="apiConstants.htm#arrayParameters">array parameter identifiers</a>. See also <a href="#simSetArrayParameter">simSetArrayParameter</a>, <a href="#simGetBooleanParameter">simGetBooleanParameter</a>, <a href="#simGetIntegerParameter">simGetIntegerParameter</a>, <a href="#simGetFloatingParameter">simGetFloatingParameter</a> and <a href="#simGetStringParameter">simGetStringParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetArrayParameter(simInt parameter,simVoid* parameterValues)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#arrayParameters">array parameter identifier</a></div>
<div><strong>parameterValues</strong>: a simFloat pointer  (simVoid is kept for backward compatibility). The 3 values will be copied to that location</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table parameterValues=simGetArrayParameter(number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>parameterValues</strong>: a table that holds the returned values, or nil in case of an error</div>
<div></div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simGetBooleanParameter" id="simGetBooleanParameter"></a>simGetBooleanParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetBooleanParameter">simxGetBooleanParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetBooleanParameter">simRosGetBooleanParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a boolean value. See the <a href="apiConstants.htm#booleanParameters">Boolean parameter identifiers</a>. See also <a href="#simSetBooleanParameter">simSetBooleanParameter</a>, <a href="#simGetIntegerParameter">simGetIntegerParameter</a>, <a href="#simGetFloatingParameter">simGetFloatingParameter</a>, <a href="#simGetArrayParameter">simGetArrayParameter</a> and <a href="#simGetStringParameter">simGetStringParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetBooleanParameter(simInt parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#booleanParameters">boolean parameter identifier</a></div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>value of the parameter (0 or 1) or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>boolean boolState=simGetBooleanParameter(number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>boolState</strong>: value of the Boolean parameter, or nil in case of an error</div>
<div></div>
</td> 
</tr> 
</table> 
<br>






<h3><a name="simGetClosestPositionOnPath" id="simGetClosestPositionOnPath"></a>simGetClosestPositionOnPath</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic relative position on a path that is closest to the specified point. The returned value is dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a> for the given path object. See also <a href="#simGetPathPosition">simGetPathPosition</a>, <a href="#simGetPathLength">simGetPathLength</a>, <a href="#simGetPositionOnPath">simGetPositionOnPath</a> and <a href="#simGetOrientationOnPath">simGetOrientationOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetClosestPositionOnPath(simInt pathHandle,simFloat* relativePosition,simFloat* pathPosition)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativePosition</strong>: a point in coordinates (x, y and z) relative to the path object position</div>
<div><strong>pathPosition</strong>: (return value). The intrinsic relative position on the path, a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path (that value is dependent on the selected path length calculation method).<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number positionOnPath=simGetClosestPositionOnPath(number pathHandle,table_3 relativePosition)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativePosition</strong>: a table containing a point in relative coordinates (x, y and z)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>positionOnPath</strong>: the intrinsic relative position on the path, a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path (value is dependent on the selected path length calculation method), or nil in case of an error. <br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetCollectionHandle" id="simGetCollectionHandle"></a>simGetCollectionHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a collection handle based on its name. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">simIsHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetCollectionHandle(const simChar* collectionName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionName</strong>: name of the collection</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the collection, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collectionHandle=simGetCollectionHandle(string collectionName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simGetCollectionName" id="simGetCollectionName"></a>simGetCollectionName</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the name of a collection based on its handle. See also <a href="#simSetCollectionName">simSetCollectionName</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetCollectionName(simInt collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: handle of the collection<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to the name of the collection or NULL if an error occurred. The user is in charge of destroying the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string collectionName=simGetCollectionName(number collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetCollisionHandle" id="simGetCollisionHandle"></a>simGetCollisionHandle
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetCollisionHandle">simxGetCollisionHandle</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetCollisionHandle">simRosGetCollisionHandle</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a collision object. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">simIsHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetCollisionHandle(const simChar* collisionObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collisionObjectName</strong>: name of the collision object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of collision object or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collisionObjectHandle=simGetCollisionObject(string collisionObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetConfigurationTree" id="simGetConfigurationTree"></a>simGetConfigurationTree</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves configuration information for a hierarchy tree (object relative positions/orientations, joint/path values). Calling <a href="#simSetConfigurationTree">simSetConfigurationTree</a> at a later time, will restore the object configuration (use this function to temporarily save object positions/orientations/joint/path values)<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetConfigurationTree(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that is at the base of the tree (all objects built on top of this one (including this one)) will have their configuration retrieved. sim_handle_all will retrieve the configuration for the whole scene<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Configuration data if operation was successful, NULL otherwise. The returned data should be deleted with <a href="#simReleaseBuffer">simReleaseBuffer</a> when not used anymore<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number rawBufferHandle=simGetConfigurationTree(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. In addition, child scripts can use the argument sim_handle_self to retrieved the configuration tree of the object that the child script is attached to<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>rawBufferHandle</strong>: handle to a block of raw memory, or -1 in case of an error. Use that value to restore the configuration tree with <a href="#simSetConfigurationTree">simSetConfigurationTree</a>. The raw buffer is attached to the script until the simulation ends, at which time it is automatically released. Alternatively, you can release that buffer with the <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a>-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetContactInfo" id="simGetContactInfo"></a>simGetContactInfo</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves contact point information of a dynamic simulation pass. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetContactInfo(simInt dynamicPass,simInt objectHandle,simInt index,simInt* objectHandles,simFloat* contactInfo)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dynamicPass</strong>: a specific dynamic sub-step index or sim_handle_all. By default a call to <a href="#simHandleDynamics">simHandleDynamics</a> executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim_handle_all to retrieve the contacts of all sub-steps. See also <a href="#simGetIntegerParameter">simGetIntegerParameter</a>(sim_intparam_dynamic_step_divider).<br>
</div>
<div><strong>objectHandle</strong>: handle of a specific object you wish to retrieve contacts from, or sim_handle_all to retrieve all contacts in the scene.<br>
</div>
<div><strong>index</strong>: zero-based index of the contact to retrieve.<br>
</div>
<div><strong>objectHandles</strong>: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.<br>
</div>
<div><strong>contactInfo</strong>: pointer to 6 values, where the 3 first values represent the contact position, and the 3 last values represent the force generated by the contact.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if no contact was found at the given index or 1 if a contact was returned.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_2 collidingObjects,table_3 collisionPoint,table_3 reactionForce=simGetContactInfo(number dynamicPass,number objectHandle,number index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>collidingObjects</strong>: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.<br>
</div>
<div><strong>collisionPoint</strong>: coordinates of the contact<br>
</div>
<div><strong>reactionForce</strong>: vector that represents the force generated by the contact<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetDialogInput" id="simGetDialogInput"></a>simGetDialogInput
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetDialogInput">simxGetDialogInput</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetDialogInput">simRosGetDialogInput</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Queries the text of the edit box of a generic dialog box of style sim_dlgstyle_input. To be used after <a href="#simDisplayDialog">simDisplayDialog</a> was called and after <a href="#simGetDialogResult">simGetDialogResult</a> returned sim_dlgret_ok<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetDialogInput(simInt genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>genericDialogHandle</strong>: handle of the generic dialog<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to a text buffer or NULL in case of an error. The user is in charge of releasing the returned string with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string input=simGetDialogInput(number genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetDialogResult" id="simGetDialogResult"></a>simGetDialogResult
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetDialogResult">simxGetDialogResult</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetDialogResult">simRosGetDialogResult</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Queries the result of a dialog box. To be used after <a href="#simDisplayDialog">simDisplayDialog</a> was called<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetDialogResult(simInt genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>genericDialogHandle</strong>: handle of the generic dialog<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#genericDialogReturnValues">result of the dialog</a> or -1 in case of an error.<br>
</div>
<br>
<div>Note. If the return value is sim_dlgret_still_open, the dialog was not closed and no button was pressed. Otherwise, you should free resources with <a href="#simEndDialog">simEndDialog</a> (the dialog might not be visible anymore, but is still present)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simGetDialogResult(number genericDialogHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetDistanceHandle" id="simGetDistanceHandle"></a>simGetDistanceHandle
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetDistanceHandle">simxGetDistanceHandle</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetDistanceHandle">simRosGetDistanceHandle</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a distance object. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">simIsHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetDistanceHandle(const simChar* distanceObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>distanceObjectName</strong>: name of distance object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the distance object or -1 if operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number distanceObjectHandle=simGetDistanceHandle(string distanceObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetEulerAnglesFromMatrix" id="simGetEulerAnglesFromMatrix"></a>simGetEulerAnglesFromMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the Euler angles from a transformation matrix. See also <a href="#simGetQuaternionFromMatrix">simGetQuaternionFromMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetEulerAnglesFromMatrix(const simFloat* matrix,simFloat* eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
<div><strong>eulerAngles</strong>: pointer to 3 simFloat values representing the Euler angles of the matrix</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 eulerAngles=simGetEulerAnglesFromMatrix(table_12 matrix)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>matrix</strong>: table to 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not needed). Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>eulerAngles</strong>: table to 3 numbers representing the Euler angles, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>











<h3><a name="simGetExplicitHandling" id="simGetExplicitHandling"></a>simGetExplicitHandling</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the explicit handling flags for a general object. See also <a href="#simSetExplicitHandling">simSetExplicitHandling</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetExplicitHandling(simInt generalObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>generalObjectHandle</strong>: handle of a general object. Can be a scene object, collision object, distance object, etc.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if command was not successful, otherwise the explicit handling flags for the specified general object (for now only bit 0 is used)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number explicitHandlingFlags=simGetExplicitHandling(number generalObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetFloatingParameter" id="simGetFloatingParameter"></a>simGetFloatingParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetFloatingParameter">simxGetFloatingParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetFloatingParameter">simRosGetFloatingParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a floating point value. See the <a href="apiConstants.htm#floatingParameters">floating-point parameter identifiers</a>. See also <a href="#simSetFloatingParameter">simSetFloatingParameter</a>, <a href="#simGetBooleanParameter">simGetBooleanParameter</a>, <a href="#simGetIntegerParameter">simGetIntegerParameter</a>, <a href="#simGetArrayParameter">simGetArrayParameter</a> and <a href="#simGetStringParameter">simGetStringParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetFloatingParameter(simInt parameter,simFloat* floatState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#floatingParameters">floating parameter identifier</a></div>
<div><strong>floatState</strong>: value of the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number parameterValue=simGetFloatingParameter(number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>parameter</strong>: parameter identifier (sim_floatparam_...)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>parameterValue</strong>: value of the parameter or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetFloatSignal" id="simGetFloatSignal"></a>simGetFloatSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetFloatSignal">simxGetFloatSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetFloatSignal">simRosGetFloatSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the value of a float signal. Signals are cleared at simulation start.  See also <a href="#simSetFloatSignal">simSetFloatSignal</a>, <a href="#simClearFloatSignal">simClearFloatSignal</a>, <a href="#simGetIntegerSignal">simGetIntegerSignal</a>, <a href="#simGetStringSignal">simGetStringSignal</a>, <a href="#simGetSignalName">simGetSignalName</a>,  <a href="#simWaitForSignal">simWaitForSignal</a> and <a href="#simPersistentDataRead">simPersistentDataRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetFloatSignal(const simChar* signalName,simFloat* signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if signal does not exist, 1 if signalValue was retrieved<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number signalValue=simGetFloatSignal(string signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>signalName</strong>: name of the signal</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>signalValue</strong>: value of the signal. nil if operation was not successful or if signal does not exist<br>
</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetIkGroupHandle" id="simGetIkGroupHandle"></a>simGetIkGroupHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of an IK group. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">simIsHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetIkGroupHandle(const simChar* ikGroupName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupName</strong>: name of an IK group</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the IK group or -1 if operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number ikGroupHandle=simGetIkGroupHandle(string ikGroupName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetIntegerParameter" id="simGetIntegerParameter"></a>simGetIntegerParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetIntegerParameter">simxGetIntegerParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetIntegerParameter">simRosGetIntegerParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an integer value. See the <a href="apiConstants.htm#integerParameters">integer parameter identifiers</a>. See also <a href="#simSetIntegerParameter">simSetIntegerParameter</a>, <a href="#simGetBooleanParameter">simGetBooleanParameter</a>, <a href="#simGetFloatingParameter">simGetFloatingParameter</a>, <a href="#simGetArrayParameter">simGetArrayParameter</a> and <a href="#simGetStringParameter">simGetStringParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetIntegerParameter(simInt parameter,simInt* intState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#integerParameters">integer parameter identifier</a></div>
<div><strong>intState</strong>: value of the parameter</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number parameterValue=simGetIntegerParameter(number parameter)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>parameter</strong>: parameter identifier (sim_intparam_...)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet><div><strong>parameterValue</strong>: value of the parameter or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetIntegerSignal" id="simGetIntegerSignal"></a>simGetIntegerSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetIntegerSignal">simxGetIntegerSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetIntegerSignal">simRosGetIntegerSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the value of an integer signal. Signals are cleared at simulation start.  See also <a href="#simSetIntegerSignal">simSetIntegerSignal</a>, <a href="#simClearIntegerSignal">simClearIntegerSignal</a>, <a href="#simGetFloatSignal">simGetFloatSignal</a>, <a href="#simGetStringSignal">simGetStringSignal</a>, <a href="#simGetSignalName">simGetSignalName</a>,  <a href="#simWaitForSignal">simWaitForSignal</a> and <a href="#simPersistentDataRead">simPersistentDataRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetIntegerSignal(const simChar* signalName,simInt* signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if signal does not exist, 1 if signalValue was retrieved</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number signalValue=simGetIntegerSignal(string signalName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>signalName</strong>: name of the signal</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>signalValue</strong>: value of the signal. nil if operation was not successful or if signal does not exist<br>
</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetInvertedMatrix" id="simGetInvertedMatrix"></a>simGetInvertedMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Returns the inverse of a transformation matrix 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>See <a href="#simInvertMatrix">simInvertMatrix</a> for the C-equivalent function</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 invertedMatrix=simGetInvertedMatrix(table_12 matrix)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>matrix</strong>: table to 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The y-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The z-axis of the orientation component is (matrix[3],matrix[7],matrix[11])</div>
<div class=tab>The position component is (matrix[4],matrix[8],matrix[12])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>invertedMatrix</strong>: inverse of the input matrix, or nil in case of an error</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetJointInterval" id="simGetJointInterval"></a>simGetJointInterval</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the interval parameters of a joint. See also <a href="#simSetJointInterval">simSetJointInterval</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointInterval(simInt objectHandle,simBool* cyclic,simFloat* interval)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div><strong>cyclic</strong>: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner)<br>
</div>
<div><strong>interval</strong>: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is &quot;cyclic&quot;, then the interval parameters don't have any meaning.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>boolean cyclic,table_2 interval=simGetJointInterval(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>cyclic</strong>: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner). Is nil in case of an error.<br>
</div>
<div><strong>interval</strong>: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is &quot;cyclic&quot;, then the interval parameters don't have any meaning. Is nil in case of an error.<br>
</div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simGetJointMatrix" id="simGetJointMatrix"></a>simGetJointMatrix
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetJointMatrix">simxGetJointMatrix</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetJointMatrix">simRosGetJointMatrix</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic transformation matrix of a joint (the transformation caused by the joint movement). See also <a href="#simSetSphericalJointMatrix">simSetSphericalJointMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointMatrix(simInt objectHandle,simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The translation component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=simGetJointMatrix(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div><strong>objectHandle</strong>: handle of the joint</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrix</strong>: table of 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not returned), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetJointPosition" id="simGetJointPosition"></a>simGetJointPosition
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetJointPosition">simxGetJointPosition</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetJointState">simRosGetJointState</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic position of a joint. This function cannot be used with spherical joints (use <a href="#simGetJointMatrix">simGetJointMatrix</a> instead). See also <a href="#simSetJointPosition">simSetJointPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointPosition(simInt objectHandle,simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div><strong>position</strong>: intrinsic position of the joint. This is a one-dimensional value: if the joint is revolute, the rotation angle is returned, if the joint is prismatic, the translation amount is returned, etc.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number position=simGetJointPosition(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>objectHandle</strong>: handle of the joint</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>position</strong>: intrinsic position of the joint or nil in case of an error</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetJointType" id="simGetJointType"></a>simGetJointType</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves the type of a joint 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetJointType(simInt objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Type of the joint (sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtype), or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number jointType=simGetJointType(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetLastError" id="simGetLastError"></a>simGetLastError
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetLastErrors">simxGetLastErrors</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetLastErrors">simRosGetLastErrors</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the last generated error message. By calling this function, the last error message is reset and a subsequent call to this function returns NULL. Errors are memorized on a thread-basis (e.g. threads originating from threaded scripts have each an individual error handler). See also <a href="#simSetLastError">simSetLastError</a>, the <a href="apiConstants.htm#integerParameters">sim_intparam_error_report_mode</a> and the <a href="apiConstants.htm#errorReportModes">error report modes</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetLastError()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Error message buffer or NULL if no error message is present. The user has to delete the returned buffer with a call to <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string lastError=simGetLastError()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetLightParameters" id="simGetLightParameters"></a>simGetLightParameters</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves various parameters of a light object. See also <a href="#simSetLightParameters">simSetLightParameters</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetLightParameters(simInt objectHandle,simFloat* ambientPart,simFloat* diffusePart,simFloat* specularPart)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the light</div>
<div><strong>ambientPart</strong>: red, green and blue component of the light's ambient part. Can be NULL</div>
<div><strong>diffusePart</strong>: red, green and blue component of the light's diffuse part. Can be NULL</div>
<div><strong>specularPart</strong>: red, green and blue component of the light's specular part. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise bit-coded: for now, only bit 0 is used: 1=light on<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number state,table_3 ambientPart,table_3 diffusePart,table_3 specularPart=simGetLightParameters(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the light</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>state</strong>: -1 in case of an error, otherwise bit-coded: for now, only bit 0 is used: 1=light on</div>
<div><strong>ambientPart</strong>: red, green and blue component of the light's ambient part</div>
<div><strong>diffusePart</strong>: red, green and blue component of the light's diffuse part</div>
<div><strong>specularPart</strong>: red, green and blue component of the light's specular part</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetLinkDummy" id="simGetLinkDummy"></a>simGetLinkDummy</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the object handle of the dummy linked to this one. See also <a href="#simSetLinkDummy">simSetLinkDummy</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetLinkDummy(simInt dummyHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dummyHandle</strong>: handle of the dummy whose linked dummy has to be retrieved.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the dummy linked to the specified dummy object, or -1 if the dummy is not linked or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number linkedDummyHandle=simGetLinkDummy(number dummyHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetMainWindow" id="simGetMainWindow"></a>simGetMainWindow</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle or pointer of the main window. This function is not available in the Lua-API</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simVoid* simGetMainWindow(simInt type)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>type</strong>: type of the desired return value. 0 for a native window handle, 1 for a pointer to a QWidget object.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a native window handle or  a pointer to a QWidget object.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetMechanismHandle" id="simGetMechanismHandle"></a>simGetMechanismHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a mechanism to be solved by the geometric constraint solver. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">simIsHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetMechanismHandle(const simChar* mechanismName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>mechanismName</strong>: name of the mechanism</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the mechanism if operation was successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number mechanismHandle=simGetMechanismHandle(string mechanismName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetModelProperty" id="simGetModelProperty"></a>simGetModelProperty
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetModelProperty">simxGetModelProperty</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetModelProperty">simRosGetModelProperty</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the properties of a model. See also <a href="#simSetModelProperty">simSetModelProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetModelProperty(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that serves as the model base</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#modelProperties">model property values</a>, or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number property=simGetModelProperty(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetModuleName" id="simGetModuleName"></a>simGetModuleName</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a plugin name that was previously registered with <a href="#simLoadModule">simLoadModule</a>. The simulator normally automatically loads and registers plugins present in the application directory. Users can use the simGetModuleName to verify if a specific module is present<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetModuleName(simInt index,sumUChar* moduleVersion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>index</strong>: index to a module. To list-up all module names, start with index=0 and increment index until return value is NULL<br>
</div>
<div><strong>moduleVersion</strong>: version of the plugin. Can be NULL.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Name of the module or NULL if no module is available at index position, or in case of an error. The user is in charge of destroying the returned name with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string moduleName,number moduleVersion=simGetModuleName(number index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>index</strong>: index to a module. To list-up all module names, start with index=0 and increment index until return value is nil<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>moduleName</strong>: name of the module or nil if no module is available at that index position, or in case of an error.<br>
</div>
<div><strong>moduleVersion</strong>: version of the plugin, or nil if moduleName is also nil<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetNameSuffix" id="simGetNameSuffix"></a>simGetNameSuffix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the name suffix for an object name (e.g. &quot;myRobot#42&quot;'s name suffix is 42), or retrieves the name suffix set for the current script or for c/c++ API calls. See also <a href="#simSetNameSuffix">simSetNameSuffix</a>, and read the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetNameSuffix(const simChar* nameWithSuffix)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>nameWithSuffix</strong>: full name (e.g. &quot;myRobot#42&quot;), or NULL to retrieve the name suffix for all c/c++ API calls<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Name suffix of nameWithSuffix, or current name suffix for c/c++ API calls</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number nameSuffix,string name=simGetNameSuffix(string nameWithSuffix): retieves the name suffix of nameWithSuffix<br>
</div>
<div>(2) number nameSuffix=simGetNameSuffix(nil): retrieves the name suffix set for current script<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>nameWithSuffix</strong>: full name (e.g. &quot;myRobot#42&quot;)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>nameSuffix</strong>: name suffix (e.g. 42) of nameWithSuffix, or name suffix that is set for current script</div>
<div><strong>name</strong>: name without suffix (e.g. &quot;myRobot&quot;) or nil if the simGetNameSuffix argument was nil</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetNavigationMode" id="simGetNavigationMode"></a>simGetNavigationMode</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the navigation and selection mode for the mouse. See also <a href="#simSetNavigationMode">simSetNavigationMode</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetNavigationMode()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#navigationModes">navigation mode</a> if operation was successful, -1 otherwise<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number navigationMode=simGetNavigationMode()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectAssociatedWithScript" id="simGetObjectAssociatedWithScript"></a>simGetObjectAssociatedWithScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrives the handle of the object the script is attached to. See also <a href="#simGetScriptAssociatedWithObject">simGetScriptAssociatedWithObject</a> and <a href="#simAssociateScriptWithObject">simAssociateScriptWithObject</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectAssociatedWithScript(simInt scriptHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Handle of the object that is associated with the script, or -1 if no object is associated with the script, or in case of an error.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=simGetObjectAssociatedWithScript (number scriptHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>scriptHandle</strong>: handle of the script, or sim_handle_self for the handle of the current script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>objectHandle</strong>: handle of the object that the script is associated with, or -1 if the script is not associated (e.g. <a href="mainScript.htm">main scripts</a> or <a href="addOns.htm">add-ons</a> don't have associated objects) or in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectChild" id="simGetObjectChild"></a>simGetObjectChild
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjectChild">simxGetObjectChild</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjectChild">simRosGetObjectChild</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of an object's child object. See also <a href="#simGetObjectParent">simGetObjectParent</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectChild(simInt objectHandle,simInt index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>index</strong>: zero-based index of the child's position. To retrieve all children of an object, call the function by increasing the index until the return value is -1<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of child object or -1 if the child doesn't exist at that index or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number childHandle=simGetObjectChild(number objectHandle,number index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectConfiguration" id="simGetObjectConfiguration"></a>simGetObjectConfiguration</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves configuration information for an object (object relative position/orientation, joint/path value). See also <a href="#simSetObjectConfiguration">simSetObjectConfiguration</a> and <a href="#simGetConfigurationTree">simGetConfigurationTree</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetObjectConfiguration(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to configuration data if operation was successful, NULL otherwise. The returned data should be deleted with <a href="#simReleaseBuffer">simReleaseBuffer</a> when not used anymore<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number rawBufferHandle=simGetObjectConfiguration(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>rawBufferHandle</strong>: handle to a raw data buffer, or -1 in case of an error. The raw buffer is attached to the script until the simulation ends, at which time it is automatically released. Alternatively, you can release that buffer with the <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a>-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectCustomData" id="simGetObjectCustomData"></a>simGetObjectCustomData</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an object's custom data previously added with the <a href="#simAddObjectCustomData">simAddObjectCustomData</a> function.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectCustomData(simInt objectHandle,simInt header,simChar* data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>header</strong>: identifier of the custom data. See <a href="#simAddObjectCustomData">simAddObjectCustomData</a> for details.</div>
<div><strong>data</strong>: pointer to a data buffer allocated by the user. Use <a href="#simGetObjectCustomDataLength">simGetObjectCustomDataLength</a> to adjust the buffer size.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=simGetObjectCustomData(number objectHandle,number header)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>nil if operation was not successful. Otherwise the custom data (might be an empty string if custom data doesn't exist).</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectCustomDataLength" id="simGetObjectCustomDataLength"></a>simGetObjectCustomDataLength</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the length of an object's custom data previously added with the <a href="#simAddObjectCustomData">simAddObjectCustomData</a> function. See also <a href="#simGetObjectCustomData">simGetObjectCustomData</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectCustomDataLength(simInt objectHandle,simInt header)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>header</strong>: identifier of the custom data. See <a href="#simAddObjectCustomData">simAddObjectCustomData</a> for details.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>length of the custom data, 0 if there is no data under that header, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectFloatParameter" id="simGetObjectFloatParameter"></a>simGetObjectFloatParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjectFloatParameter">simxGetObjectFloatParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjectFloatParameter">simRosGetObjectFloatParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a floating-point parameter of a object. See also <a href="#simSetObjectFloatParameter">simSetObjectFloatParameter</a>, <a href="#simGetObjectIntParameter">simGetObjectIntParameter</a> and <a href="#simGetObjectStringParameter">simGetObjectStringParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectFloatParameter(simInt objectHandle,simInt parameterID,simFloat* parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a><br>
</div>
<div><strong>parameter</strong>: retrieved parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number parameter=simGetObjectFloatParameter(number objectHandle,number parameterID)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><span class="apiTableRightLSyn"><strong>result</strong></span>: -1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful </div>
<div><strong>parameter</strong>: retrieved parameter</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectHandle" id="simGetObjectHandle"></a>simGetObjectHandle
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjectHandle">simxGetObjectHandle</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjectHandle">simRosGetObjectHandle</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an object handle based on its name. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">simIsHandleValid</a> and <a href="#simGetObjectUniqueIdentifier">simGetObjectUniqueIdentifier</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectHandle(const simChar* objectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectName</strong>: name of object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of object or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=simGetObjectHandle(string objectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectIntParameter" id="simGetObjectIntParameter"></a>simGetObjectIntParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjectIntParameter">simxGetObjectIntParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjectIntParameter">simRosGetObjectIntParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an integer parameter of a object. See also <a href="#simSetObjectIntParameter">simSetObjectIntParameter</a>, <a href="#simGetObjectFloatParameter">simGetObjectFloatParameter</a> and <a href="#simGetObjectStringParameter">simGetObjectStringParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectIntParameter(simInt objectHandle,simInt parameterID,simInt* parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a><br>
</div>
<div><strong>parameter</strong>: retrieved parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number parameter=simGetObjectIntParameter(number objectHandle,number parameterID)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
<div><strong>parameter</strong>: retrieved parameter</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectLastSelection" id="simGetObjectLastSelection"></a>simGetObjectLastSelection</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the handle of the last selected object. See also <a href="#simGetObjectSelection">simGetObjectSelection</a> and <a href="#simGetObjectSelectionSize">simGetObjectSelectionSize</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectLastSelection()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>last selected object handle or -1 if selection is empty or operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=simGetObjectLastSelection()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectMatrix" id="simGetObjectMatrix"></a>simGetObjectMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the transformation matrix of an object. See also <a href="#simSetObjectMatrix">simSetObjectMatrix</a>, <a href="#simGetObjectPosition">simGetObjectPosition</a> and <a href="#simGetObjectOrientation">simGetObjectOrientation</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectMatrix(simInt objectHandle,simInt relativeToObjectHandle,simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.<br>
</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)<br>
</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The translation component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrix=simGetObjectMatrix(number objectHandle,number relativeToObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>matrix</strong>: table of 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not returned), or nil in case of an error. Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectName" id="simGetObjectName"></a>simGetObjectName</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the name of an object based on its handle. See also <a href="#simSetObjectName">simSetObjectName</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetObjectName(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Name of the object if operation was successful, NULL otherwise. The user is in charge of destroying the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string objectName=simGetObjectName(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectOrientation" id="simGetObjectOrientation"></a>simGetObjectOrientation
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjectOrientation">simxGetObjectOrientation</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjectPose">simRosGetObjectPose</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the orientation (Euler angles) of an object. See also <a href="#simGetObjectQuaternion">simGetObjectQuaternion</a>, <a href="#simSetObjectOrientation">simSetObjectOrientation</a>, <a href="#simGetObjectPosition">simGetObjectPosition</a> and <a href="#simGetObjectMatrix">simGetObjectMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectOrientation(simInt objectHandle,simInt relativeToObjectHandle,simFloat* eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.<br>
</div>
<div><strong>eulerAngles</strong>: Euler angles (alpha, beta and gamma)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 eulerAngles=simGetObjectOrientation(number objectHandle,number relativeToObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>eulerAngles</strong>: table of 3 values (Euler angles) or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectParent" id="simGetObjectParent"></a>simGetObjectParent
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjectParent">simxGetObjectParent</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjectParent">simRosGetObjectParent</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of an object's parent object. See also <a href="#simSetObjectParent">simSetObjectParent</a> and <a href="#simGetObjectChild">simGetObjectChild</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectParent(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of parent or -1 if the parent doesn't exist or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number parentHandle=simGetObjectParent(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectPosition" id="simGetObjectPosition"></a>simGetObjectPosition
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjectPosition">simxGetObjectPosition</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjectPose">simRosGetObjectPose</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the position of an object. See also <a href="#simSetObjectPosition">simSetObjectPosition</a>, <a href="#simGetObjectOrientation">simGetObjectOrientation</a> and <a href="#simGetObjectMatrix">simGetObjectMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectPosition(simInt objectHandle,simInt relativeToObjectHandle,simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the position. Specify -1 to retrieve the absolute position, sim_handle_parent to retrieve the position relative to the object's parent, or an object handle relative to whose reference frame we want the position.<br>
</div>
<div><strong>position</strong>: pointer to 3 values (x, y and z)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 position=simGetObjectPosition(number objectHandle,number relativeToObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>position</strong>: table of 3 values (x, y and z) or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectProperty" id="simGetObjectProperty"></a>simGetObjectProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the main properties of a scene object. See also <a href="#simSetObjectProperty">simSetObjectProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectProperty(simInt objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#sceneObjectProperties">object property values</a>, -1 if operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number property=simGetObjectProperty(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectQuaternion" id="simGetObjectQuaternion"></a>simGetObjectQuaternion (ROS API equivalent: <a href="rosServices.htm#simRosGetObjectPose">simRosGetObjectPose</a>)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the quaternion (x,y,z,w) of an object. See also <a href="#simGetObjectOrientation">simGetObjectOrientation</a> and <a href="#simGetObjectMatrix">simGetObjectMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectQuaternion(simInt objectHandle,simInt relativeToObjectHandle,simFloat* quaternion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.<br>
</div>
<div><strong>quaternion</strong>: the quaternion (x,y,z,w)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_4 quaternion=simGetObjectQuaternion(number objectHandle,number relativeToObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjects" id="simGetObjects"></a>simGetObjects
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjects">simxGetObjects</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjects">simRosGetObjects</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves object handles. Use this in a loop where index starts at 0 and is incremented to get all object handles in the scene<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjects(simInt index,simInt objectType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>index</strong>: object index (not handle!). First object is located at index 0</div>
<div><strong>objectType</strong>: object type (sim_object_shape_type, sim_object_joint_type, etc. (see the <a href="apiConstants.htm#sceneObjectTypes">object types</a>) or sim_handle_all for any type of object<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the object or -1 if no object is located at that index or in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectHandle=simGetObjects(number index,number objectType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectSelection" id="simGetObjectSelection"></a>simGetObjectSelection
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetObjectSelection">simxGetObjectSelection</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetObjectSelection">simRosGetObjectSelection</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves all selected object's handles. See also <a href="#simGetObjectSelectionSize">simGetObjectSelectionSize</a>, <a href="#simAddObjectToSelection">simAddObjectToSelection</a> and <a href="#simRemoveObjectFromSelection">simRemoveObjectFromSelection</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectSelection(simInt* objectHandles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandles</strong>: pointer to object handles. Make sure to have at least <a href="#simGetObjectSelectionSize">simGetObjectSelectionSize</a> simInts available<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>size of the selection (&gt;=0) if operation was successful, -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table selectedObjectHandles=simGetObjectSelection()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>selectedObjectHandles</strong>: table containing the handles of all selected objects, or nil if no object is selected or in case of an error <br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectSelectionSize" id="simGetObjectSelectionSize"></a>simGetObjectSelectionSize</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the size of the object selection. See also <a href="#simGetObjectSelection">simGetObjectSelection</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectSelectionSize()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>size of the selection, or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number selectionSize=simGetObjectSelectionSize()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectSizeFactor" id="simGetObjectSizeFactor"></a>simGetObjectSizeFactor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the size factor of a scene object. The size factor is different from the real object size. Use this to be able to react to scaling operations. See also the <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_instancepass</a> message.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetObjectSizeFactor(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the scene object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>size factor or negative value in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sizeFactor=simGetObjectSizeFactor(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectSpecialProperty" id="simGetObjectSpecialProperty"></a>simGetObjectSpecialProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the special properties of a scene object. See also <a href="#simSetObjectSpecialProperty">simSetObjectSpecialProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectSpecialProperty(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#sceneObjectSpecialProperties">object special property values</a>, -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number property=simGetObjectSpecialProperty(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectStringParameter" id="simGetObjectStringParameter"></a>simGetObjectStringParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a string parameter of a object. See also <a href="#simSetObjectStringParameter">simSetObjectStringParameter</a>, <a href="#simGetObjectIntParameter">simGetObjectIntParameter</a> and <a href="#simGetObjectFloatParameter">simGetObjectFloatParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetObjectStringParameter(simInt objectHandle,simInt parameterID,simInt* parameterLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a><br>
</div>
<div><strong>parameterLength</strong>: the length of the retrieved parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>A buffer containing the retrieved string, or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. The returned buffer might contain embedded zeros, and its length is specified by the parameterLength argument.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string parameter=simGetObjectStringParameter(number objectHandle,number parameterID)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectType" id="simGetObjectType"></a>simGetObjectType</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves the type of an object 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectType(simInt objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>type of the object (sim_object_shape_type, sim_object_joint_type, etc. (see the <a href="apiConstants.htm#sceneObjectTypes">object types</a>) or -1 in case of error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number objectType=simGetObjectType(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetObjectUniqueIdentifier" id="simGetObjectUniqueIdentifier"></a>simGetObjectUniqueIdentifier</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an object's unique identifier (an object handle is unique, but not across opened scenes. Additionally, if a huge amount of objects are created/destroyed (&gt;2000000), then handles of destroyed objects will be reused. This is not the case with unique identifiers).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetObjectUniqueIdentifier(simInt objectHandle,simInt* uniqueIdentifier)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: object handle, or sim_handle_all to retrieve all object identifiers<br>
</div>
<div><strong>uniqueIdentifier</strong>: pointer to the unique identifier, or if sim_handle_all is specified as the object handle, then the pointer points to several values. The user is in charge of reserving the buffer (size 1 if handle is specified, or number of objects in the scene if sim_handle_all is specified)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number uniqueId=simGetObjectUniqueIdentifier(number objectHandle)</div>
<div>(2) table uniqueIds=simGetObjectUniqueIdentifier(sim_handle_all)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>(1) <strong>uniqueId</strong>: the unique identifier or nil in case of an error</div>
<div>(2) <strong>uniqueIds</strong>: a table containing the unique identifiers or nil in case of an error</div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simGetOrientationOnPath" id="simGetOrientationOnPath"></a>simGetOrientationOnPath</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the absolute interpolated orientation of a point along a path object. See also <a href="#simGetPositionOnPath">simGetPositionOnPath</a>, <a href="#simGetPathPosition">simGetPathPosition</a> and <a href="#simGetClosestPositionOnPath">simGetClosestPositionOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetOrientationOnPath(simInt pathHandle,simFloat relativeDistance,simFloat* eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method (refer to the <a href="pathPositionCalculationMethod.htm">path position calculation method</a> section).<br>
</div>
<div><strong>eulerAngles</strong>: Euler angles (alpha, beta and gamma)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 eulerAngles=simGetOrientationOnPath (number pathHandle,number relativeDistance)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>eulerAngles</strong>: table of 3 values (alpha, beta and gamma) or nil in case of an error<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetPage" id="simGetPage"></a>simGetPage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the current page index (view). See also <a href="#simSetPage">simSetPage</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPage()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>page index or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number pageIndex=simGetPage()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetPathLength" id="simGetPathLength"></a>simGetPathLength</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the length of a path object. The length is given in meters, but the actual returned length is dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a> for the given path object. See also <a href="#simGetPathPosition">simGetPathPosition</a> and <a href="#simSetPathPosition">simSetPathPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPathLength(simInt objectHandle,simFloat* length)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div><strong>length</strong>: length of the path given in meters (but dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number length=simGetPathLength(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>length</strong>: length of the path given in meters (but dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>), or nil in case of an error<br>
</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetPathPlanningHandle" id="simGetPathPlanningHandle"></a>simGetPathPlanningHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a path planning object. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">simIsHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPathPlanningHandle(const simChar* pathPlanningObjectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathPlanningObjectName</strong>: name of the path planning object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the path planning object or -1 if operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number pathPlanningObjectHandle=simGetPathPlanningObject(string pathPlanningObjectName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetPathPosition" id="simGetPathPosition"></a>simGetPathPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the intrinsic position of a path object (a distance along the path). The position is given in meters, but the actual returned position is dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a> for the given path object. See also <a href="#simSetPathPosition">simSetPathPosition</a>, <a href="#simGetPathLength">simGetPathLength</a>, <a href="#simGetPositionOnPath">simGetPositionOnPath</a> and <a href="#simGetClosestPositionOnPath">simGetClosestPositionOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPathPosition(simInt objectHandle,simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div><strong>position</strong>: linear position on the path given in meters (but dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number position=simGetPathPosition(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>position</strong>: linear position on the path given in meters (but dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>), or nil in case of an error<br>
</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetPositionOnPath" id="simGetPositionOnPath"></a>simGetPositionOnPath</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the absolute interpolated position of a point along a path object. See also <a href="#simGetOrientationOnPath">simGetOrientationOnPath</a>, <a href="#simGetPathPosition">simGetPathPosition</a> and <a href="#simGetClosestPositionOnPath">simGetClosestPositionOnPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetPositionOnPath(simInt pathHandle,simFloat relativeDistance,simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>.<br>
</div>
<div><strong>position</strong>: pointer to 3 values (x, y and z)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 position=simGetPositionOnPath (number pathHandle,number relativeDistance)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>pathHandle</strong>: handle of the path object</div>
<div><strong>relativeDistance</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>position</strong>: table of 3 values (x, y and z) or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetQuaternionFromMatrix" id="simGetQuaternionFromMatrix"></a>simGetQuaternionFromMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the quaternion from a transformation matrix. See also <a href="#simGetEulerAnglesFromMatrix">simGetEulerAnglesFromMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetQuaternionFromMatrix(const simFloat* matrix,simFloat* quaternion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
<div><strong>quaternion</strong>: pointer to 4 simFloat values representing the quaternion in the matrix (x,y,z,w)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_4 quaternion=simGetQuaternionFromMatrix(table_12 matrix)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>matrix</strong>: table to 12 numbers (the last row of the 4x4 matrix (0,0,0,1) is not needed). Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>quaternion</strong>: table of 4 numbers representing the quaternion, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>











<h3><a name="simGetRealTimeSimulation" id="simGetRealTimeSimulation"></a>simGetRealTimeSimulation</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Indicates whether the simulation is real-time. See also <a href="#simIsRealTimeSimulationStepNeeded">simIsRealTimeSimulationStepNeeded</a> and <a href="#simAdjustRealTimeTimer">simAdjustRealTimeTimer</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetRealTimeSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if simulation is real-time, 0 if it is not, and -1 if the operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simGetRealTimeSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetRotationAxis" id="simGetRotationAxis"></a>simGetRotationAxis</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves an axis and rotation angle that brings one transformation matrix onto another one. The translation part of the transformation matrices is ignored. This function, when used in combination with <a href="#simRotateAroundAxis">simRotateAroundAxis</a>, can be used to build interpolations between transformation matrices. See also <a href="#simGetObjectMatrix">simGetObjectMatrix</a> and <a href="#simSetObjectMatrix">simSetObjectMatrix</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetRotationAxis(const simFloat* matrixStart,const simFloat* matrixGoal,simFloat* axis,simFloat* angle)  <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixStart</strong>: the <em>start</em> transformation matrix</div>
<div><strong>matrixGoal</strong>: the <em>goal</em> transformation matrix</div>
<div><strong>axis</strong>: the returned rotation axis in absolute coordinates</div>
<div><strong>angle</strong>: the returned rotation angle</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 axis,number angle=simGetRotationAxis(table_12 matrixStart,table_12 matrixGoal)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>axis</strong>: the rotation axis in absolute coordinates, or nil in case of an error</div>
<div><strong>angle</strong>: the rotation angle, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>







<h3><a name="simGetSceneCustomData" id="simGetSceneCustomData"></a>simGetSceneCustomData</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the scene custom data previously added with the <a href="#simAddSceneCustomData">simAddSceneCustomData</a> function. See also <a href="#simGetSceneCustomDataLength">simGetSceneCustomDataLength</a>, <a href="#simAddSceneCustomData">simAddSceneCustomData</a> and <a href="#simPersistentDataRead">simPersistentDataRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetSceneCustomData(simInt header,simChar* data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>header</strong>: identifier of the custom data. See <a href="#simAddSceneCustomData">simAddSceneCustomData</a> for details.</div>
<div><strong>data</strong>: pointer to a data buffer allocated by the user. Use <a href="#simGetSceneCustomDataLength">simGetSceneCustomDataLength</a> to adjust the buffer size.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=simGetSceneCustomData(number header)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>nil if operation was not successful. Otherwise the custom data (might be an empty string if custom data doesn't exist).</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetSceneCustomDataLength" id="simGetSceneCustomDataLength"></a>simGetSceneCustomDataLength</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the length of the scene custom data previously added with the <a href="#simAddSceneCustomData">simAddSceneCustomData</a> function. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetSceneCustomDataLength(simInt header)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>header</strong>: identifier of the custom data. See simAddSceneCustomData for details.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>length of the custom data, 0 if there is no data under that header, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScript" id="simGetScript"></a>simGetScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves script handles. Use this in a loop where index starts at 0 and is incremented to get all script handles. See also <a href="#simGetScriptHandle">simGetScriptHandle</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScript(simInt index)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>index</strong>: script index (not handle). First script is located at index 0<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of a script if function was successful and a script exists at the given index, or -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScriptAssociatedWithObject" id="simGetScriptAssociatedWithObject"></a>simGetScriptAssociatedWithObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a script's handle based on its associated object. See also <a href="#simGetObjectAssociatedWithScript">simGetObjectAssociatedWithScript</a> and <a href="#simAssociateScriptWithObject">simAssociateScriptWithObject</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScriptAssociatedWithObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that might have a script associated<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the script associated with the object, or -1 if the operation was not successful or the object doesn't have an associated script<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number scriptHandle=simGetScriptAssociatedWithObject(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScriptExecutionCount" id="simGetScriptExecutionCount"></a>simGetScriptExecutionCount</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the number of times the current script was called and returned. Useful to set-up initial values when the function returns 0 (the script was called for the first time in the current simulation). Child scripts should always use this function instead of testing whether <a href="#simGetSimulationState">simGetSimulationState</a>()==sim_simulation_advancing_firstafterstop (a child script might be created (through copy/paste operation for instance) in the middle of a simulation, in which case <a href="#simGetSimulationState">simGetSimulationState</a>() will not return sim_simulation_advancing_firstafterstop). When a threaded child script executes and finishes several times in a same simulation run, then this function always returns 0.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number executionCount=simGetScriptExecutionCount()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>executionCount</strong>: number of times the current script was called and returned, or -1 in case of an error<br>
</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScriptHandle" id="simGetScriptHandle"></a>simGetScriptHandle</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a script. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). A script doesn't directly have a name assigned, however if the script is a child script and associated with a scene object, then the script name is the name of the associated scene object. See also <a href="#simIsHandleValid">simIsHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScriptHandle(const simChar* scriptName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptName</strong>: name of the script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the script if operation was successful, -1 otherwise<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number scriptHandle=simGetScriptHandle(string scriptName)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function. Alternatively, scriptName can be nil or inexistent, in which case the current script's handle is returned<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScriptName" id="simGetScriptName"></a>simGetScriptName</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a script's name based on its handle. A script doesn't have a name assigned, however if the script is a child script and associated with a scene object, then this function will retrieve the name of the associated scene object. If the script is not a child script or is not associated with a scene object, then the returned value is NULL <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetScriptName(simInt scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>buffer to the script's name if function was successful and the name is valid, NULL otherwise. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string scriptName=simGetScriptName(number scriptHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>scriptHandle</strong>: handle of the script, or sim_handle_self for the handle of the current script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>scriptName</strong>: name of the script if associated with a scene object, empty string if the script is the main script, or the name of the <a href="addOns.htm">add-on</a> if the script is an add-on.</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScriptProperty" id="simGetScriptProperty"></a>simGetScriptProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves properties relative to a script. This function is not available in the Lua-API 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetScriptProperty(simInt scriptHandle,simInt* scriptProperty,simInt* associatedObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div><strong>scriptProperty</strong>: pointer to a script property value (see the <a href="apiConstants.htm#scriptTypes">script type values</a>))</div>
<div><strong>associatedObjectHandle</strong>: pointer to the handle of an associated object if script is a child script, -1 otherwise (if the child script doesn't have an associated object, the value is -1 also)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScriptRawBuffer" id="simGetScriptRawBuffer"></a>simGetScriptRawBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the raw data that is attached to a given script. See also <a href="#simSetScriptRawBuffer">simSetScriptRawBuffer</a> and <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetScriptRawBuffer(simInt scriptHandle,simInt bufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div><strong>bufferHandle</strong>: handle of the raw buffer</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a pointer to the raw buffer (the buffer is owned by the simulator and will be released by the simulator or through a call to <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a>) or NULL if the buffer doesn't exist or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScriptSimulationParameter" id="simGetScriptSimulationParameter"></a>simGetScriptSimulationParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a script's parameter from its simulation parameter list. Useful for simple interaction with the user, or for simple parameter exchange with other scripts. Only parameters from main or child scripts can be retrieved with this function. See also <a href="#simSetScriptSimulationParameter">simSetScriptSimulationParameter</a>, <a href="#simUnpackInts">simUnpackInts</a> and <a href="#simUnpackFloats">simUnpackFloats</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetScriptSimulationParameter(simInt scriptHandle,const simChar* parameterName,simInt* parameterLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script, or sim_handle_main_script or sim_handle_all. When scriptHandle is sim_handle_all, the function returns only one matching parameter encountered (other matching parameters might be different)<br>
</div>
<div><strong>parameterName</strong>: name of the parameter to retrieve</div>
<div><strong>parameterLength</strong>: the number of bytes that compose the value of the parameter (excluding the terminal zero)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>value of the parameter or NULL if parameterName does not exist for the given script, or in case of an error. The user is in charge of releasing the returned value with <a href="#simReleaseBuffer">simReleaseBuffer</a>. The returned pointer points to parameterLength byte values, terminated by a terminal zero (the returned buffer may however contain several embedded zeros).<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) boolean/number/string parameterValue=simGetScriptSimulationParameter(number scriptHandle,string parameterName,boolean forceStringReturn=false)</div>
<div>2) table parameterValues,table scriptHandles=simGetScriptSimulationParameter(number targetScripts,string parameterName,boolean forceStringReturn=false)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>(1) <strong>scriptHandle</strong>: handle of the script, or sim_handle_main_script or sim_handle_self.
</div>
<div>(2) <strong>targetScripts</strong>: sim_handle_all, sim_handle_tree or sim_handle_chain (with sim_handle_tree and sim_handle_chain the calling script is excluded).
</div>
<div>
 <strong>parameterName</strong>: name of the parameter to retrieve.
</div>
<div>
 <strong>forceStringReturn</strong>: forces the return of a string (i.e. raw value). False by default. If false, then the returned string will be converted to nil, false, true, a number or a string as appropriate (and in that order).
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>(1) <strong>parameterValue</strong>: value of the parameter, or nil in case of an error (or if that value is nil!).</div>
<div>(2) <strong>parameterValues</strong>: table of parameter values or nil if no such parameter was found or in case of an error. <strong>scriptHandles</strong>: table of script handles associated with the parameter values (i.e. parameterValue[i] comes from the script with handle scriptHandles[i]) or nil if no such parameter was found or in case of an error.<br>
</div>
<br>
<div>If the returned parameter value is a string, then it might contain any values (also embedded zeros)</div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simGetScriptText" id="simGetScriptText"></a>simGetScriptText</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the content of a script (i.e. Lua code). This function is not available in the Lua-API. See also <a href="#simSetScriptText">simSetScriptText</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetScriptText(simInt scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of a script</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to the script buffer (0-terminated buffer), or NULL in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetShapeColor" id="simGetShapeColor"></a>simGetShapeColor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Retrieves the color of a shapes. See also <a href="#simSetShapeColor">simSetShapeColor</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeColor(simInt shapeHandle,const simChar* colorName,simInt colorComponent,simFloat* rgbData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape<br>
</div>
<div><strong>colorName</strong>: name of a color. If a name is provided, a specific color component will be retrieved (e.g. if a shape is a grouped shape. Can be NULL.<br>
</div>
<div><strong>colorComponent</strong>: 0 for ambient, 1 for diffuse, 2 for specular, 3 for emmisive, and 4 for the transparency value<br>
</div>
<div><strong>rgbData</strong> (output): red, green and blue components of the color (3 values), or the transparency value (1 value)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the color name was not found in the shape. Otherwise, the operation was successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table_3 rgbData=simGetShapeColor(number shapeHandle,string colorName,number colorComponent)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetShapeMassAndInertia" id="simGetShapeMassAndInertia"></a>simGetShapeMassAndInertia</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves mass and inertia information from a shape. See also <a href="#simSetShapeMassAndInertia">simSetShapeMassAndInertia</a>, <a href="#simGetObjectMatrix">simGetObjectMatrix</a> and <a href="#simBuildMatrix">simBuildMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeMassAndInertia(simInt shapeHandle,simFloat* mass,simFloat* inertiaMatrix,simFloat* centerOfMass,const simFloat* transformation)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the <a href="shapes.htm">shape object</a></div>
<div><strong>mass</strong>: the mass of the object</div>
<div><strong>inertia matrix</strong> (output): the inertia matrix or tensor (9 values), expressed relative to the center of mass. The returned matrix is relative to the orientational frame of <strong>transformation</strong> (see further below). </div>
<div><strong>centerOfMass</strong> (output): the position of the center of mass, relative to the specified <strong>transformation</strong> (see next item).</div>
<div><strong>transformation</strong>: the transformation matrix (12 values) relative to which we want the data. Can be NULL, in which case the returned data is relative to the absolute reference frame. See <a href="#simGetObjectMatrix">here</a> to see how matrix transformations are specified in V-REP.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error<a href="#simReleaseBuffer"></a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number mass,table_9 inertiaMatrix,table_3 centerOfMass=simGetShapeMassAndInertia(number shapeHandle,table_12 transformation=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>See the C-function for details</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>See the C-function for details</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetShapeMesh" id="simGetShapeMesh"></a>simGetShapeMesh</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a shape's mesh information. See also <a href="#simCreateMeshShape">simCreateMeshShape</a> and <a href="#simExportMesh">simExportMesh</a> for a usage example.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetShapeMesh(simInt shapeHandle,simFloat** vertices,simInt* verticesSize,simInt** indices,simInt* indicesSize,simFloat** normals)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape</div>
<div><strong>vertices</strong>: receives the vertices. The user is in charge of destroying the array with <a href="#simReleaseBuffer">simReleaseBuffer</a>. See <a href="#simExportMesh">simExportMesh</a> for a usage example.<br>
</div>
<div><strong>verticesSize</strong>: receives the size of the vertices array. See <a href="#simExportMesh">simExportMesh</a> for a usage example.<br>
</div>
<div><strong>indices</strong>: receives the indices. The user is in charge of destroying the array with <a href="#simReleaseBuffer">simReleaseBuffer</a>. See <a href="#simExportMesh">simExportMesh</a> for a usage example.<br>
</div>
<div><strong>indicesSize</strong>: receives the size of the indice array. See <a href="#simExportMesh">simExportMesh</a> for a usage example.<br>
</div>
<div><strong>normals</strong>: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with <a href="#simReleaseBuffer">simReleaseBuffer</a>. Can be NULL.</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table vertices,table indices,table normals=simGetShapeMesh(number shapeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>shapeHandle</strong>: handle of the shape. See <a href="#simExportMesh">simExportMesh</a> for a usage example.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>vertices</strong>: table of vertices, or nil in case of an error</div>
<div><strong>indices</strong>: table of indices, or nil in case of an error</div>
<div><strong>normals</strong>: table of normals, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetSignalName" id="simGetSignalName"></a>simGetSignalName</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the signal name at the given index.  Use this function in a loop until return is NULL to read all set signals. Signals are values that are global to a given simulator scene and cleared at simulation start. See also <a href="#simGetStringSignal">simGetStringSignal</a>, <a href="#simGetFloatSignal">simGetFloatSignal</a>, <a href="#simGetIntegerSignal">simGetIntegerSignal</a> and <a href="#simWaitForSignal">simWaitForSignal</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetSignalName(simInt signalIndex,simInt signalType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalIndex</strong>: zero based index</div>
<div><strong>signalType</strong>: signal type. 0 is for integer signals, 1 for float signals and 2 for string signals</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or signal does not exist at this index, otherwise the name of the signal at the given index (the user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string signalName=simGetSignalName(number signalIndex,number signalType)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetSimulationPassesPerRenderingPass" id="simGetSimulationPassesPerRenderingPass"></a>simGetSimulationPassesPerRenderingPass</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Returns the number of simulation passes (calculation passes) per frame (display). This value might not be constant for a given simulation. This function is not available in the Lua-API. See also <a href="#simSetSimulationPassesPerRenderingPass">simSetSimulationPassesPerRenderingPass</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetSimulationPassesPerRenderingPass()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>&gt;0 if operation was successful (the number of simulation passes per rendering pass), -1 otherwise</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetSimulationState" id="simGetSimulationState"></a>simGetSimulationState</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves current simulation state. Use this function to prepare initial values, reset parameters, or to prepare for a simulation pause. In particular, scripts that run in a threaded mode should always watch out for sim_simulation_advancing_abouttostop (this means the simulation is about to stop and the threaded execution of the script should end)<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetSimulationState()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>The current state of the simulation (sim_simulation_stopped, sim_simulation_paused, etc. (see the <a href="apiConstants.htm#simulationStatus">simulation state values</a>)), or -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number simulationState=simGetSimulationState()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetSimulationTime" id="simGetSimulationTime"></a>simGetSimulationTime</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the current simulation time<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetSimulationTime()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>negative value (-1.0) if operation not successful, otherwise the simulation time<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number simulationTime=getSimulationTime()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetSimulationTimeStep" id="simGetSimulationTimeStep"></a>simGetSimulationTimeStep</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the simulation time step (the simulation time (i.e. not real-time) that passes at each main script simulation pass). This value might not be constant for a given simulation.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetSimulationTimeStep()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>negative value (-1.0) if operation not successful, otherwise the simulation time step</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number timeStep=getSimulationTimeStep()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetSimulatorMessage" id="simGetSimulatorMessage"></a>simGetSimulatorMessage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves and removes the next message in the C/C++ or Lua message queues. Use this in a while-loop until all messages have been extracted. While the C/C++ interface has one single message queue, each Lua script has its own message queue. A given message queue cannot hold more than 64 messages, unread messages will be discarded.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetSimulatorMessage(simInt* messageID,simInt* auxiliaryData,simInt* returnedDataSize)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>messageID</strong>: a simulator message (see the <a href="apiConstants.htm#simulatorMessages">simulator messages</a>) or -1 if no message is available or in case of an error<br>
</div>
<div><strong>auxiliaryData</strong>: table of 4 integers that can describe the returned message in more details</div>
<div><strong>returnedDataSize</strong>: size of the returned buffer</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if no buffer was returned, otherwise a buffer that should be released with <a href="#simReleaseBuffer">simReleaseBuffer</a></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number message,table_4 auxiliaryData=simGetSimulatorMessage()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>message</strong>: a simulator message (see the <a href="apiConstants.htm#simulatorMessages">simulator messages</a>) or -1 if no message is available or in case of an error<br>
</div>
<div><strong>auxiliaryData</strong>: table of 4 numbers that can describe the returned message in more details</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetStringParameter" id="simGetStringParameter"></a>simGetStringParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetStringParameter">simxGetStringParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetStringParameter">simRosGetStringParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves a string value. See the <a href="apiConstants.htm#stringParameters">string parameter identifiers</a>. See also <a href="#simGetBooleanParameter">simGetBooleanParameter</a>, <a href="#simGetIntegerParameter">simGetIntegerParameter</a>, <a href="#simGetArrayParameter">simGetArrayParameter</a> and <a href="#simGetFloatingParameter">simGetFloatingParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetStringParameter(simInt parameter)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#stringParameters">string parameter identifier</a></div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful. Otherwise the string parameter. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string parameterValue=simGetStringParameter(number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetStringSignal" id="simGetStringSignal"></a>simGetStringSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetStringSignal">simxGetStringSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetStringSignal">simRosGetStringSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the value of a string signal. Signals are cleared at simulation start.  See also <a href="#simSetStringSignal">simSetStringSignal</a>, <a href="#simClearStringSignal">simClearStringSignal</a>, <a href="#simGetIntegerSignal">simGetIntegerSignal</a>, <a href="#simGetFloatSignal">simGetFloatSignal</a>, <a href="#simGetSignalName">simGetSignalName</a>,  <a href="#simWaitForSignal">simWaitForSignal</a> and <a href="#simPersistentDataRead">simPersistentDataRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetStringSignal(const simChar* signalName,simInt* stringLength)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>stringLength</strong>: the size of the returned string, since it may contain any data (also embedded zeros).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or signal does not exist, otherwise the value of the string signal (which may contain any value, including embedded zeros). In that case the returned buffer should be released with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string signalValue=simGetStringSignal(string signalName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>

<div><strong>signalName</strong>: name of the signal</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>signalValue</strong>: value of the signal, or nil if operation was not successful or signal does not exist. The returned signal may contain any value, including embedded zeros.</div>
<div></div></td> 
</tr> 
</table> 
<br>

















<h3><a name="simGetSystemTime" id="simGetSystemTime"></a>simGetSystemTime</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the system time. The system time is the time is seconds that elapsed since Windows was started. See also <a href="#simGetSystemTimeInMilliseconds">simGetSystemTimeInMilliseconds</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat simGetSystemTime()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>system time in seconds, or a negative value (-1.0) in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number systemTime=simGetSystemTime()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetSystemTimeInMilliseconds" id="simGetSystemTimeInMilliseconds"></a>simGetSystemTimeInMilliseconds</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the system time in milliseconds. See also <a href="#simGetSystemTime">simGetSystemTime</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetSystemTimeInMilliseconds()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>system time in milliseconds, or a negative value (-1) in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number systemTime=simGetSystemTimeInMilliseconds()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetUIButtonLabel" id="simGetUIButtonLabel"></a>simGetUIButtonLabel</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the up-state label of a custom user interface button (useful to retrieve the text in an edit-box style button). See also <a href="#simSetUIButtonLabel">simSetUIButtonLabel</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simGetUIButtonLabel(simInt uiHandle,simInt buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: handle of a button inside the specified custom user interface</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>label of the button, or NULL in case of an error. The user is in charge of releasing the returned string with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string label=simGetUIButtonLabel(number uiHandle,number buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function (but nil instead of NULL, and <a href="#simReleaseBuffer">simReleaseBuffer</a> does not need to be called)</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetUIButtonProperty" id="simGetUIButtonProperty"></a>simGetUIButtonProperty
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetUIButtonProperty">simxGetUIButtonProperty</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetUIButtonProperty">simRosGetUIButtonProperty</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the properties of a custom user interface button. See also <a href="#simSetUIButtonProperty">simSetUIButtonProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetUIButtonProperty(simInt uiHandle,simInt buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: handle of a button inside the specified custom user interface</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div><a href="apiConstants.htm#uiButtonProperties">button property</a> values, -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number property=simGetUIButtonProperty(number uiHandle,number buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetUIButtonSize" id="simGetUIButtonSize"></a>simGetUIButtonSize</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the size (in terms of cell numbers) of a custom user interface button<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetUIButtonSize(simInt uiHandle,simInt buttonHandle,simInt* size)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: handle of a button inside the specified custom user interface</div>
<div><strong>size</strong>: size (in terms of cells (x and y))</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_2 size=simGetUIButtonSize(number uiHandle,number buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: handle of a button inside the specified custom user interface</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet><div><strong>size</strong>: table containing the x and y-size of the button (in terms of cells), or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetUIEventButton" id="simGetUIEventButton"></a>simGetUIEventButton
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetUIEventButton">simxGetUIEventButton</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetUIEventButton">simRosGetUIEventButton</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the button handle and some auxiliary values of the last occurred event in that custom user interface. The function will then <strong>clear</strong> the event. When a custom user interface button is pressed, a slider is moved or an edit box is changed, an event is registered and stored in the custom user interface. See also the <a href="apiConstants.htm#simulatorMessages">sim_message_ui_button_state_change</a> message.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetUIEventButton(simInt uiHandle,simInt* auxiliaryValues)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>auxiliaryValues</strong>: 2 values (can be NULL).</div>
<div class=tab>value1: the <a href="apiConstants.htm#uiButtonProperties">button property</a></div>
<div class=tab>value2: for sliders: slider state (0-1000), for stay down buttons: down state (0 or 1), for up/down event buttons: up/down events (0 or 1)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>button handle or -1 if no event occurred or if operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number buttonHandle, table_2 auxiliaryValues=simGetUIEventButton(number uiHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>buttonHandle</strong>: button handle or -1 if no event occurred or if operation was not successful<br>
</div>
<div><strong>auxiliaryValues</strong>: 2 values. Same as for the C-function.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetUIHandle" id="simGetUIHandle"></a>simGetUIHandle
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetUIHandle">simxGetUIHandle</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetUIHandle">simRosGetUIHandle</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the handle of a custom user interface. The operation of this function depends on the current name suffix settings (see <a href="#simGetNameSuffix">simGetNameSuffix</a>, <a href="#simSetNameSuffix">simSetNameSuffix</a>, and the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). See also <a href="#simIsHandleValid">simIsHandleValid</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetUIHandle(const simChar* uiName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiName</strong>: name of the custom user interface</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of custom user interface if value &gt;=0, -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number uiHandle=simGetUIHandle(string uiName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetUIPosition" id="simGetUIPosition"></a>simGetUIPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the position of a custom user interface. See also <a href="#simSetUIPosition">simSetUIPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetUIPosition(simInt uiHandle,simInt* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle of the custom user interface</div>
<div><strong>position</strong>: pointer to 2 values (x and y)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_2 position=simGetUIPosition(number uiHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>uiHandle</strong>: handle of the custom user interface</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>position</strong>: table of 2 values (x and y) or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetUIProperty" id="simGetUIProperty"></a>simGetUIProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the properties of a custom user interface. See also <a href="#simSetUIProperty">simSetUIProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetUIProperty(simInt uiHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle of a custom user interface</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Custom user interface property values, -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number property=simGetUIProperty(number uiHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simGetUISlider" id="simGetUISlider"></a>simGetUISlider
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetUISlider">simxGetUISlider</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetUISlider">simRosGetUISlider</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Gets the slider position of a custom user interface button (must be slider-type button). See also <a href="#simSetUISlider">simSetUISlider</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetUISlider(simInt uiHandle,simInt buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle of a custom user interface</div>
<div><strong>buttonHandle</strong>: handle of a button inside the specified custom user interface</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>slider position (value between 0 and 1000) or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number sliderPosition=simGetUISlider(number uiHandle,number buttonHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>







<h3><a name="simGetVelocity" id="simGetVelocity"></a>simGetVelocity</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the linear and/or angular velocity of the center of mass of a dynamically enabled shape object<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetVelocity(simInt shapeHandle,simFloat* linearVelocity,simFloat* angularVelocity)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of a dynamically enabled shape</div>
<div><strong>linearVelocity</strong>: pointer to 3 values that will receive the linear velocity in absolute coordinates. Can be NULL</div>
<div><strong>angularVelocity</strong>: pointer to 3 values that will receive the angular velocity in absolute coordinates. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 linearVelocity,table_3 angularVelocity=simGetVelocity(number shapeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>shapeHandle</strong>: handle of a dynamically enabled shape</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>linearVelocity</strong>: table containing 3 values that represent the linear velocity in absolute coordinates, or nil in case of an error<br>
</div>
<div><strong>angularVelocity</strong>: table containing 3 values that represent the angular velocity in absolute coordinates, or nil in case of an error<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simGetVisionSensorDepthBuffer" id="simGetVisionSensorDepthBuffer"></a>simGetVisionSensorDepthBuffer
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetVisionSensorDepthBuffer">simxGetVisionSensorDepthBuffer</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetVisionSensorDepthBuffer">simRosGetVisionSensorDepthBuffer</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the depth buffer (or a portion of it) of a vision sensor. Use <a href="#simGetVisionSensorResolution">simGetVisionSensorResolution</a> to know the resolution of the full depth buffer. The returned data doesn't make sense if <a href="#simHandleVisionSensor">simHandleVisionSensor</a> wasn't called previously (simHandleVisionSensor is called by default in the main script if the vision sensor is not tagged as <em>explicit handling</em>).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat* simGetVisionSensorDepthBuffer(simInt sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>depth buffer (buffer size is resolutionX*resolutionY) or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. Returned values are in the range of 0-1 (0=closest to sensor, 1=farthest from sensor)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table depthBuffer=simGetVisionSensorDepthBuffer(number sensorHandle,number posX=0,number posY=0,number sizeX=0,number sizeY=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor</div>
<div><strong>posX / posY</strong>: position of the depth buffer portion to retrieve. Zero by default.</div>
<div><strong>sizeX / sizeY</strong>: size of the depth buffer portion to retrieve. Zero by default, which means that the full depth buffer should be retrieved</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>depthBuffer</strong>: table containing depth values (table size is sizeX*sizeY) or nil in case of an error. Returned values are in the range of 0-1 (0=closest to sensor, 1=farthest from sensor)<br>
</div></td> 
</tr> 
</table> 
<br>














<h3><a name="simGetVisionSensorImage" id="simGetVisionSensorImage"></a>simGetVisionSensorImage
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxGetVisionSensorImage">simxGetVisionSensorImage</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetVisionSensorImage">simRosGetVisionSensorImage</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the rgb-image (or a portion of it) of a vision sensor. Use <a href="#simGetVisionSensorResolution">simGetVisionSensorResolution</a> to know the resolution of the full image. The returned data doesn't make sense if <a href="#simHandleVisionSensor">simHandleVisionSensor</a> wasn't called previously  (simHandleVisionSensor is called by default in the main script if the vision sensor is not tagged as <em>explicit handling</em>). See also <a href="#simSetVisionSensorImage">simSetVisionSensorImage</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simFloat* simGetVisionSensorImage(simInt sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>image buffer (buffer size is resolutionX*resolution*3) or NULL in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. Returned values are in the range of 0-1 (0=min. intensity, 1=max. intensity)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table/string imageBuffer=simGetVisionSensorImage(number sensorHandle,number posX=0,number posY=0,number sizeX=0,number sizeY=0,number returnType=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor</div>
<div><strong>posX / posY</strong>: position of the image portion to retrieve. Zero by default.</div>
<div><strong>sizeX / sizeY</strong>: size of the image portion to retrieve. Zero by default, which means that the full image should be retrieved</div>
<div><strong>returnType</strong>: the type of the returned buffer. 0 returns a table filled with rgb values in the range 0-1, 1 returns a string filled with rgb values in the range 0-255</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>imageBuffer</strong>: nil in case of an error. Otherwise a table containing rgb values (table size is sizeX*sizeY*3, rgb values in the range 0-1) or a string containing rgb values (table size is sizeX*sizeY*3, rgb values in the range 0-255)
</div></td> 
</tr> 
</table> 
<br>
















<h3><a name="simGetVisionSensorResolution" id="simGetVisionSensorResolution"></a>simGetVisionSensorResolution</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the resolution at which the given vision sensor operates (this might be different from what is indicated in the vision sensor dialog: should your graphic card model be rather old, then only resolutions a 2n will be supported). Useful in combination with <a href="#simGetVisionSensorImage">simGetVisionSensorImage</a>/<a href="#simGetVisionSensorDepthBuffer">simGetVisionSensorDepthBuffer</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGetVisionSensorResolution(simInt sensorHandle,simInt* resolution)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor</div>
<div><strong>resolution</strong>: 2 values for the x and y component</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_2 resolution=simGetVisionSensorResolution(number sensorHandle) <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of the vision sensor</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>resolution</strong>: table containing the x and y resolution, or nil in case of an error</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simGroupShapes" id="simGroupShapes"></a>simGroupShapes</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Groups (or merges) several shapes into a <a href="shapes.htm">grouped shape</a> (or <a href="shapes.htm">simple shape</a>). See also <a href="#simUngroupShape">simUngroupShape</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simGroupShapes(const simInt* shapeHandles,simInt shapeCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandles</strong>: the handles of the shapes you wish to group</div>
<div><strong>shapeCount</strong>: the size of the <strong>shapeHandles</strong> array. A negative number indicates that we want to merge the shapes instead of grouping them.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. Otherwise the handle of the resulting grouped shape.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number shapeHandle=simGroupShapes(table shapeHandles) <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to C-function</div></td> 
</tr> 
</table> 
<br>







<h3><a name="simHandleChildScript" id="simHandleChildScript"></a>simHandleChildScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calls one or several child scripts. Not available from the C-API. Only child scripts that are built onto the current script hierarchy will be called (that's why they are called &quot;child scripts&quot;!). Child scripts of a child script cannot be directly called, it is the responsibility of each child script to forward that call. For more details, see the description on <a href="scriptCallingMethodology.htm">how scripts are executed</a> in V-REP. See also the <a href="#simHandleSensingChildScripts">simHandleSensingChildScripts</a> function. This function is not available to <a href="addOns.htm">add-ons</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number executedScriptCount=simHandleChildScript(sim_handle_all/sim_handle_all_except_explicit, &lt;arguments&gt;)</div>
<div>(2) &lt;return values&gt;=simHandleChildScript(number childScriptHandle,&lt;arguments&gt;)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>(1) <strong>Argument1</strong>: sim_handle_all if all childscripts should be executed, also the ones marked as &quot;explicit handling&quot;, or sim_handle_all_except_explicit if all childscripts should be executed, except the ones marked as &quot;explicit handling&quot;. <strong>Argument2</strong>, etc.: &lt;arguments&gt; can be any arguments that you want to pass to the child scripts that will be called. Inside the called child scripts, the &lt;arguments&gt; can be retrieved with the &quot;arguments=â¦&quot; command. &lt;arguments&gt; can be omitted when calling simHandleChildScript.<br>
</div>
<div>(2) <strong>Argument1</strong>: childScriptHandle: handle of the childscript to be executed. <strong>Argument2</strong>, etc.: &lt;arguments&gt; can be any arguments that you want to pass to the child script that will be called. Inside the called child script, the &lt;arguments&gt; can be retrieved with the &quot;arguments=â¦&quot; command. &lt;arguments&gt; can be omitted when calling simHandleChildScript.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>(1) executedScriptCount: number of executed child scripts (including the called child scripts that are still in execution (e.g. if the childscript is marked as &quot;threaded execution&quot;)<br>
</div>
<div>(2) &lt;returned values&gt;: the values returned by the child script that was called. A child script can return values with following command: &quot;return argument1, argument2, etc.&quot;. Values returned by a child script marked as &quot;threaded execution&quot; will be ignored (i.e. nil is returned instead)<br>
</div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleCollision" id="simHandleCollision"></a>simHandleCollision</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (check for collision, etc.) a registered collision object. Collision objects can be registered while editing a scene. See also <a href="#simReadCollision">simReadCollision</a>, <a href="#simResetCollision">simResetCollision</a>, <a href="#simCheckCollision">simCheckCollision</a> and <a href="#simCheckCollisionEx">simCheckCollisionEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleCollision(simInt collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collisionObjectHandle</strong>: handle of the collision object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered collision objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>number of collisions or -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collisionCount=simHandleCollision(number collisionObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleDistance" id="simHandleDistance"></a>simHandleDistance</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (measures distances, etc.) a registered distance object. Distance objects can be registered while editing a scene. See also <a href="#simReadDistance">simReadDistance</a>, <a href="#simResetDistance">simResetDistance</a> and <a href="#simCheckDistance">simCheckDistance</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleDistance(simInt distanceObjectHandle,simFloat* smallestDistance)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>distanceObjectHandle</strong>: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered distance objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>smallestDistance</strong>: smallest measured distance. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if at least one distance was measured, 0 if no distance was measured, -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number smallestDistance=simHandleDistance(number distanceObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if at least one distance was measured, 0 if no distance was measured, -1 in case of an error</div>
<div><strong>smallestDistance</strong>: the smallest distance measured. Is nil if result is not 1</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleDynamics" id="simHandleDynamics"></a>simHandleDynamics</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles the dynamics functionality in a scene. This function is not available to <a href="addOns.htm">add-ons</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleDynamics(simFloat deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>deltaTime</strong>: the time that passed since the command was called last. Typically <a href="#simGetSimulationTimeStep">simGetSimulationTimeStep</a>()<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simHandleDynamics(number deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleGraph" id="simHandleGraph"></a>simHandleGraph</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles a graph object (i.e. records current values of registered data streams). Graphs and data streams can be added/registered while editing a scene. See also <a href="#simResetGraph">simResetGraph</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleGraph(simInt graphHandle,simFloat simulationTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>graphHandle</strong>: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all graph objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>simulationTime</strong>: simulation time. Usually you want to record data stream at the end of a simulation pass to record actualized value: then set simulationTime to <a href="#simGetSimulationTime">simGetSimulationTime</a>()+<a href="#simGetSimulationTimeStep">simGetSimulationTimeStep</a>(). <br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simHandleGraph(number graphHandle,number simulationTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleJoint" id="simHandleJoint"></a>simHandleJoint</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles the motion of a joint, when the joint is in motion mode. See also <a href="#simResetJoint">simResetJoint</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleJoint(simInt jointHandle,simFloat deltaTime)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointHandle</strong>: handle of the joint object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all joint objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>deltaTime</strong>: time variation between previous call (typically <a href="#simGetSimulationTimeStep">simGetSimulationTimeStep</a>())</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simHandleJoint(number jointHandle,number deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleIkGroup" id="simHandleIkGroup"></a>simHandleIkGroup</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (solves) a registered IK group. IK groups can be registered while editing a scene.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleIkGroup(simInt ikGroupHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of the IK group or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all IK groups, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>number of performed calculations (i.e. IK group calculation results are different from sim_ikresult_not_performed) if no specific IK group was specified, or a value of type <a href="apiConstants.htm#ikCalculationResults">IK result</a> if a specific IK group was specified, -1 in case of an error (a failed IK group calculation is not considered as an error)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number calculationCountOrResult=simHandleIkGroup(number ikGroupHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleMainScript" id="simHandleMainScript"></a>simHandleMainScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (executes) the main script (and child scripts if the main script contains appropriate calls). See also <a href="#simHandleChildScript">simHandleChildScript</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleMainScript()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>A <a href="apiConstants.htm#mainScriptExecutionResults">main script execution result</a>. If the return value contains sim_script_main_script_not_called, then the main script was not called (e.g. because a plugin hindered it when it received the <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_mainscriptabouttobecalled</a> message). Otherwise, the main script was called and <a href="#simAdvanceSimulationByOneStep">simAdvanceSimulationByOneStep</a> should be executed. </div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleMechanism" id="simHandleMechanism"></a>simHandleMechanism</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles a mechanism registered with the geometric constraint solver functionality. Mechanisms can be registered while editing a scene.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleMechanism(simInt mechanismHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>mechanismHandle</strong>: handle of the mechanism or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered mechanisms, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simHandleMechanism(number mechanismHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleMill" id="simHandleMill"></a>simHandleMill</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (performs cutting) a registered mill object. See also <a href="#simResetMill">simResetMill</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleMill(simInt millHandle,simFloat* removedSurfaceAndVolume)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>millHandle</strong>: handle of a mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all mill objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>removedSurfaceAndVolume</strong>: pointer to two floating point values indicating the total removed surface and volume by this call. Can be NULL<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>total number of cut objects, or -1 in case of an error</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number cutCount,table_2 removedSurfaceAndVolume=simHandleMill(number millHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>cutCount</strong>: total number of cut objects, or -1 in case of an error</div>
<div><strong>removedSurfaceAndVolume</strong>: table indicating the total removed surface and volume by this call</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleModule" id="simHandleModule"></a>simHandleModule</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles a plugin. This function is only available from the Lua API. Plugins, next to their registered custom Lua functions, might need to perform operations on a regular basis and not when called from a threaded script (e.g. for synchronization purposes). They can do it when <a href="#simHandleModule">simHandleModule</a> is called (<a href="#simOpenModule">simOpenModule</a> should however have been called previously). Refer to the <a href="apiConstants.htm#simulatorMessages">messages relayed to plugins</a> for more details. <a href="#simHandleModule">simHandleModule</a> can only be called from the <a href="mainScript.htm">main script</a> and is not available in the C-API. Look at the default main script to get an idea about how to use <a href="#simOpenModule">simOpenModule</a>, <a href="#simHandleModule">simHandleModule</a> and <a href="#simCloseModule">simCloseModule</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number result=simHandleModule(number sim_handle_all,boolean calledInSensingPart)</div>
<div>(2) number result=simHandleModule(string moduleName,boolean calledInSensingPart)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sim_handle_all</strong>: indicates that all plugins should be handled (called)</div>
<div><strong>moduleName</strong>: the name of the plugin that should be handled (called)</div>
<div><strong>calledInSensingPart</strong>: set to false when called in the &quot;actuation part&quot;. Set to true when called in the &quot;sensing part&quot; <br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, otherwise result is the number of plugins that executed the command.</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandlePath" id="simHandlePath"></a>simHandlePath</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles the motion along a path object (if the functionality is enabled for the given path). This function performs similarly with the <a href="#simHandleJoint">simHandleJoint</a> command, but for path objects.See also <a href="#simResetPath">simResetPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandlePath(simInt pathHandle,simFloat deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all path objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>deltaTime</strong>: time variation between previous call (typically <a href="#simGetSimulationTimeStep">simGetSimulationTimeStep</a>())<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simHandlePath(number pathHandle,number deltaTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleProximitySensor" id="simHandleProximitySensor"></a>simHandleProximitySensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (performs sensing, etc. of) a registered proximity sensor object. See also <a href="#simReadProximitySensor">simReadProximitySensor</a>, <a href="#simCheckProximitySensor">simCheckProximitySensor</a>, <a href="#simCheckProximitySensorEx">simCheckProximitySensorEx</a> and <a href="#simResetProximitySensor">simResetProximitySensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleProximitySensor(simInt sensorHandle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* detectedSurfaceNormalVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of a proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all proximity sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>detectedPoint</strong>: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULL<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of the object that was detected. Can be NULL<br>
</div>
<div><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULL<br>
</div>
<br>
<div>When several proximity sensors are handled at the same time (e.g. with the sim_handle_all argument), then the output values are relative to the closest detection distance</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>0 if nothing was detected, -1 in case of an error. In a future release, a more detailed return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint,number detectedObjectHandle,table_3 detectedSurfaceNormalVector=simHandleProximitySensor(number sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>sensorHandle</strong>: handle of a proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all proximity sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 0 if nothing was detected, -1 in case of an error. In a future release, a more detailed return value might be available<br>
</div>
<div><strong>distance</strong>: distance to the detected point if result is &gt;0, nil otherwise<br>
</div>
<div><strong>detectedPoint</strong>: table of 3 numbers indicating the relative coordinates of the detected point if result is &gt;0, nil otherwise<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of the object that was detected if result is &gt;0, nil otherwise<br>
</div>
<div><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Is nil if result is &lt;1<br>
</div>
<br>
<div>When several proximity sensors are handled at the same time (e.g. with the sim_handle_all argument), then the return values are relative to the closest detection distance<br>
</div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleSensingChildScripts" id="simHandleSensingChildScripts"></a>simHandleSensingChildScripts</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Calls all child scripts marked as &quot;execute in the sensing phase&quot;. Not available from the C-API. Can only be called from the main script, and only child scripts that are built onto the current script hierarchy will be called. While the <a href="#simHandleChildScript">simHandleChildScript</a> function, when called from the default main script executes all child scripts before or during object movement actually happens, the simHandleSensingChildScripts function allows to execute child scripts after object movement completion, and before rendering. For more information, refer to the main script section of the documentation. This function is not available to <a href="addOns.htm">add-ons</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number executedScriptCount=simHandleSensingChildScripts()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>executedScriptCount</strong>: the number of child scripts that the function executed.</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleVarious" id="simHandleVarious"></a>simHandleVarious</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles various functionalities (e.g. camera tracking during simulation, etc.). Should only be called once per simulation pass if possible.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleVarious()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simHandleVarious()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simHandleVisionSensor" id="simHandleVisionSensor"></a>simHandleVisionSensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Handles (performs sensing, etc. of) a registered vision sensor object. See also <a href="#simReadVisionSensor">simReadVisionSensor</a>, <a href="#simCheckVisionSensor">simCheckVisionSensor</a>, <a href="#simCheckVisionSensorEx">simCheckVisionSensorEx</a> and <a href="#simResetVisionSensor">simResetVisionSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simHandleVisionSensor(simInt visionSensorHandle,simFloat** auxValues,simInt** auxValuesCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>visionSensorHandle</strong>: handle of a vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all vision sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div><strong>auxValues</strong>: auxiliary values returned from the applied filters (refer to the <a href="visionSensorFilterComposition.htm">documentation</a> for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValues). If visionSensorHandle is sim_handle_all or sim_handle_all_except_explicit, nothing is returned in auxValues.<br>
</div>
<div><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValuesCount).<br>
</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
float* auxValues=NULL;
int* auxValuesCount=NULL;
float averageColor[3]={0.0f,0.0f,0.0f};
if (simHandleVisionSensor(visionSensorHandle,&auxValues,&auxValuesCount)>=0)
{
    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))
    {
        averageColor[0]=auxValues[11];
        averageColor[1]=auxValues[12];
        averageColor[2]=auxValues[13];
    }
    simReleaseBuffer((char*)auxValues);
    simReleaseBuffer((char*)auxValuesCount);
}</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>number of detections (number of vision sensors that triggered a detection), -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number detectionCount,table auxiliaryValuePacket1,table auxiliaryValuePacket2, etc.=simHandleVisionSensor(number visionSensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>detectionCount</strong>: number of detections (number of vision sensors that triggered a detection), -1 in case of an error<br>
</div>
<div><strong>auxiliaryValuePacket1</strong>: default auxiliary value packet (same as for the C-function)</div>
<div><strong>auxiliaryValuePacket2</strong>: additional auxiliary value packet (e.g. from a filter component)</div>
<div><strong>auxiliaryValuePacket3</strong>: etc. (the function returns as many tables as there are auxiliary value packets)</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simImportMesh" id="simImportMesh"></a>simImportMesh</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Imports a mesh from a file. See also <a href="#simExportMesh">simExportMesh</a>, <a href="#simImportShape">simImportShape</a> and <a href="#simCreateMeshShape">simCreateMeshShape</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simImportMesh(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat identicalVerticeTolerance,simFloat scalingFactor,simFloat*** vertices,simInt** verticesSizes,simInt*** indices,simInt** indicesSizes,simFloat*** reserved,simChar*** names)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>fileformat</strong>: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL format<br>
</div>
<div><strong>pathAndFilename</strong>: the location of the file to import.<br>
</div>
<div><strong>options</strong>: bit-coded: bit0 set: keep identical vertices, bit1 set: keep identical triangles, bit2 set: don't correct triangle windings<br>
</div>
<div><strong>identicalVerticeTolerance</strong>: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effect<br>
</div>
<div><strong>scalingFactor</strong>: the scaling factor to apply to the imported vertices<br>
</div>
<div><strong>vertices</strong>: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example below<br>
</div>
<div><strong>verticesSizes</strong>: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example below<br>
</div>
<div><strong>indices</strong>: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example below<br>
</div>
<div><strong>indicesSizes</strong>: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example below<br>
</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL.<br>
</div>
<div><strong>names</strong>: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example below<br>
</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightBlueBoxNoMarginAndSmall>
simFloat** vertices;
simInt* verticesSizes;
simInt** indices;
simInt* indicesSizes;
simChar** names;
simInt elementCount=simImportMesh(1,"d:\\example.dxf",0,0.0001f,1.0f,&vertices,
                            &verticesSizes,&indices,&indicesSizes,NULL,&names);
if (elementCount>0)
{
    const float grey[3]={0.5f,0.5f,0.5f};
    for (int i=0;i&#60;elementCount;i++)
    {
        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],
                               verticesSizes[i],indices[i],indicesSizes[i],NULL);
        simSetObjectName(shapeHandle,names[i]);
        simSetShapeColor(shapeHandle,"",0,grey);
        simReleaseBuffer(names[i]);
        simReleaseBuffer((simChar*)indices[i]);
        simReleaseBuffer((simChar*)vertices[i]);
    }
    simReleaseBuffer((simChar*)names);
    simReleaseBuffer((simChar*)indicesSizes);
    simReleaseBuffer((simChar*)indices);
    simReleaseBuffer((simChar*)verticesSizes);
    simReleaseBuffer((simChar*)vertices);
}</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Number of imported meshes, or 0 or -1 if the operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_of_table vertices,table_of_table indices,nil,table names=simImportMesh(number fileformat,string pathAndFilename,number options,number identicalVerticeTolerance,number scalingFactor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>vertices</strong>: a table to vertice tables, or nil if operation was not successful. The import operation may generate several meshes depending on the fileformat. See the example below<br>
</div>
<div><strong>indices</strong>: a table to indice tables, or nil if operation was not successful. The import operation may generate several meshes depending on the fileformat. See the example below<br>
</div>
<div><strong>nil</strong>: return value is reserved for future extensions</div>
<div><strong>names</strong>: a table to mesh names extracted from the file, or nil if operation was not successful. The import operation may generate several meshes depending on the fileformat. See the example below<br>
</div>
<br>
<div>USAGE EXAMPLE:</div>
<pre class=lightRedBoxNoMarginAndSmall>
if (simGetScriptExecutionCount()==0) then
    vertices,indices,reserved,names=simImportMesh(1,"d:\\example.dxf",0,0.0001,1)
    if (vertices) then
        for i=1,#vertices,1 do
            h=simCreateMeshShape(2,20*math.pi/180,vertices[i],indices[i])
            simSetShapeColor(h,"",0,{0.5,0.5,0.5})
            simSetObjectName(h,names[i])
        end
    end
end</pre>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simImportShape" id="simImportShape"></a>simImportShape</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Imports a <a href="shapes.htm">shape</a> from a file (first imports meshes, then groups/merges them into a shape). See also <a href="#simImportMesh">simImportMesh</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simImportShape(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat identicalVerticeTolerance,simFloat scalingFactor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>fileformat</strong>: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).<br>
</div>
<div><strong>pathAndFilename</strong>: the location of the file to import.<br>
</div>
<div><strong>options</strong>: bit-coded: bit0 set: keep identical vertices, bit1 set: keep identical triangles, bit2 set: don't correct triangle windings, bit3 set: do not preserve colors (only for COLLADA format for now)<br>
</div>
<div><strong>identicalVerticeTolerance</strong>: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effect<br>
</div>
<div><strong>scalingFactor</strong>: the scaling factor to apply to the imported vertices<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>The handle of the imported shape, or -1 if the operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number shapeHandle=simImportShape(number fileformat,string pathAndFilename,number options,number identicalVerticeTolerance,number scalingFactor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
</td> 
</tr> 
</table> 
<br>










<h3><a name="simInitializePathSearch" id="simInitializePathSearch"></a>simInitializePathSearch</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Initializes a temporary path search object that can be used for stepped path planning calculations. Useful in conjunction with <a href="#simPerformPathSearchStep">simPerformPathSearchStep</a> when path planning calculations need to be performed in several steps so as to keep the simulator unblocked. When operating from a threaded child script, rather use the <a href="#simSearchPath">simSearchPath</a> function. See also <a href="#simGetPathPlanningHandle">simGetPathPlanningHandle</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInitializePathSearch(simInt pathPlanningObjectHandle,simFloat maximumSearchTime,simFloat searchTimeStep)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathPlanningObjectHandle</strong>: handle of the path planning object</div>
<div><strong>maximumSearchTime</strong>: maximum search time in seconds</div>
<div><strong>searchTimeStep</strong>: the duration of each search step (when calling <a href="#simPerformPathSearchStep">simPerformPathSearchStep</a>)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise a handle to a temporary path search object<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number temporaryPathSearchObjectHandle=simInitializePathSearch(number pathPlanningObjectHandle,number maximumSearchTime,number searchTimeStep)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simInterpolateMatrices" id="simInterpolateMatrices"></a>simInterpolateMatrices</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Computes the interpolated transformation matrix between matrixIn1 and matrixIn2. Quaternions are used internally<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInterpolateMatrices(const simFloat* matrixIn1,const simFloat* matrixIn2,simFloat interpolFactor,simFloat* matrixOut)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixIn1</strong>: the first input matrix</div>
<div><strong>matrixIn2</strong>: the second input matrix</div>
<div><strong>interpolFactor</strong>: the interpolation factor, a value between 0.0 and 1.0 (0.0--&gt; matrixOut=matrixIn1, 1.0--&gt; matrixOut=matrixIn2)<br>
</div>
<div><strong>matrixOut</strong>: the output matrix (the result of the interpolation).</div>
<div>A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 resultMatrix=simInterpolateMatrices(table_12 matrixIn1,table_12 matrixIn2,number interpolFactor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div><strong>matrixIn1</strong>: the first input matrix (a table containing 12 values (the last row (0,0,0,1) is not required))</div>
<div><strong>matrixIn2</strong>: the second input matrix (a table containing 12 values (the last row (0,0,0,1) is not required))</div>
<div><strong>interpolFactor</strong>: the interpolation factor, a value between 0.0 and 1.0 (0.0--&gt; resultMatrix=matrixIn1, 1.0--&gt; resultMatrix=matrixIn2)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>resultMatrix</strong>: the result matrix (a table containing 12 values (the last row (0,0,0,1) is omitted)). Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simInvertMatrix" id="simInvertMatrix"></a>simInvertMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Inverts a transformation matrix. This function in the Lua-API has a different name: <a href="#simGetInvertedMatrix">simGetInvertedMatrix</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simInvertMatrix(simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: pointer to 12 simFloat values representing the matrix that should be inverted (the last row of the 4x4 matrix (0,0,0,1) is not needed)
</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>





<h3><a name="simIsHandleValid" id="simIsHandleValid"></a>simIsHandleValid</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether a general object handle is still valid. When a general object is destroyed (e.g. programmatically or via the user interface), then its related handle is not valid anymore and will trigger an error when used. Use this function to avoid triggering an error. See also <a href="#simGetObjectHandle">simGetObjectHandle</a>, <a href="#simGetUIHandle">simGetUIHandle</a>, <a href="#simGetCollectionHandle">simGetCollectionHandle</a>, <a href="#simGetCollisionHandle">simGetCollisionHandle</a>, <a href="#simGetDistanceHandle">simGetDistanceHandle</a>, <a href="#simGetMechanismHandle">simGetMechanismHandle</a>, <a href="#simGetIkGroupHandle">simGetIkGroupHandle</a>, <a href="#simGetScriptHandle">simGetScriptHandle</a>, <a href="#simGetPathPlanningHandle">simGetPathPlanningHandle</a> and <a href="#simGetObjectUniqueIdentifier">simGetObjectUniqueIdentifier</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simIsHandleValid(simInt generalObjectHandle,simInt generalObjectType)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>generalOjectHandle</strong>: handle of a general-type object (e.g. scene object, collision object, distance object, etc.)</div>
<div><strong>generalOjectType</strong>: type of the general object. Refer to the <a href="apiConstants.htm#generalObjectTypes">general object types</a>. Can be -1, in which case the specified handle is checked for validity in all types (handles of different types never overlap)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if the handle is not valid anymore, or 1 if the handle is still valid.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simIsHandleValid(number generalObjectHandle,number generalObjectType=-1)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simIsObjectInSelection" id="simIsObjectInSelection"></a>simIsObjectInSelection</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether an object is selected. See also <a href="#simAddObjectToSelection">simAddObjectToSelection</a> and <a href="#simRemoveObjectFromSelection">simRemoveObjectFromSelection</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simIsObjectInSelection(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>3 if object is the last selection,1 if object is in selection, 0 if not, -1 if operation was not successful<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number selectionState=simIsObjectInSelection(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simIsRealTimeSimulationStepNeeded" id="simIsRealTimeSimulationStepNeeded"></a>simIsRealTimeSimulationStepNeeded</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Indicates whether a call to <a href="#simAdvanceSimulationByOneStep">simAdvanceSimulationByOneStep</a> is needed (only useful during real-time simulations). This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simIsRealTimeSimulationStepNeeded()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if call is needed, 0 if not needed, and -1 if the operation was not successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simIsScriptExecutionThreaded" id="simIsScriptExecutionThreaded"></a>simIsScriptExecutionThreaded</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the current script is marked as &quot;threaded execution&quot;. This function is different from <a href="#simIsScriptRunningInThread">simIsScriptRunningInThread</a>. This function is not available in the C-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simIsScriptExecutionThreaded()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 if operation was not successful, 0 if script execution is not threaded, &gt;0 if script execution is threaded<br>
</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simIsScriptRunningInThread" id="simIsScriptRunningInThread"></a>simIsScriptRunningInThread</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks whether the current script is running in a thread (but the script might not be marked as &quot;threaded execution&quot; (i.e. the script might not have started the thread)). This function is different from <a href="#simIsScriptExecutionThreaded">simIsScriptExecutionThreaded</a>. This function is not available in the C-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simIsScriptRunningInThread()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 if operation was not successful, 0 if script is not running in a thread, &gt;0 if script is running in a thread<br>
</div></td> 
</tr> 
</table> 
<br>





<h3><a name="simJointGetForce" id="simJointGetForce"></a>simJointGetForce
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxJointGetForce">simxJointGetForce</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosGetJointState">simRosGetJointState</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Retrieves the force or torque a joint exerts along/about its active axis. This function retrieves meaningful information only if the joint is prismatic or revolute, and is dynamically enabled. With the Bullet engine, this function returns the force or torque the joint motor exerts (forces/torques from joint limits are not taken into account). With the ODE engine, this function returns the total force or torque a joint exerts along/about its z-axis. See also <a href="#simSetJointForce">simSetJointForce</a> and <a href="#simReadForceSensor">simReadForceSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simJointGetForce(simInt jointHandle,simFloat* forceOrTorque)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointHandle</strong>: handle of the joint</div>
<div><strong>forceOrTorque</strong>: the force or the torque the joint exerts along/about its z-axis.
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number forceOrTorque=simJointGetForce(number jointHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>forceOrTorque</strong>: the force or the torque the joint exerts along/about its z-axis.</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simLaunchExecutable" id="simLaunchExecutable"></a>simLaunchExecutable</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Launches an executable. Similar to os.execute or io.popen, but is system independent. This function is not available in the C-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simLaunchExecutable(string filename,string parameters='',number showStatus=1)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>filename</strong>: file name of the executable</div>
<div><strong>parameters</strong>: optional input arguments</div>
<div><strong>showStatus</strong>: 0 to hide the application's window, 1 to show it. Works only with Windows OS.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 if operation was not successful. Under Windows OS, if the application could not be launched, return value is -1. Under Mac OS or Linux, return value might be different from -1 even if the application could not be launched.<br>
</div></td> 
</tr> 
</table> 
<br>











<h3><a name="simLoadModel" id="simLoadModel"></a>simLoadModel
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxLoadModel">simxLoadModel</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosLoadModel">simRosLoadModel</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Loads a previously saved model. See also <a href="#simSaveModel">simSaveModel</a>, <a href="#simLoadUI">simLoadUI</a>, <a href="#simLoadScene">simLoadScene</a>, and <a href="#simSetBooleanParameter">simSetBooleanParameter</a> with <a href="apiConstants.htm#booleanParameters">sim_boolparam_scene_and_model_load_messages</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLoadModel(const simChar* filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: model filename. The filename extension is required (&quot;ttm&quot;)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simLoadModel(string filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simLoadModule" id="simLoadModule"></a>simLoadModule</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Loads a V-REP plugin. This should be done in the <a href="mainClientApplication.htm">main client application</a>, just after <a href="#simRunSimulator">simRunSimulator</a> was called. See also <a href="#simSendModuleMessage">simSendModuleMessage</a> and <a href="#simUnloadModule">simUnloadModule</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLoadModule(const simChar* filenameAndPath,const simChar* pluginName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><span class="apiTableRightCSyn"><strong>filenameAndPath</strong></span>: file name and path of the plugin</div>
<div><span class="apiTableRightCSyn"><strong>pluginName</strong></span>: name of the plugin. If the file name is v_repExtXXX.dll, then the name should be XXX</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>handle of the plugin if value is 0 or positive. otherwise:</div>
<div class=tab>-3: plugin could not be loaded</div>
<div class=tab>-2: plugin is missing entry points</div>
<div class=tab>-1: plugin could not initialize</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simLoadScene" id="simLoadScene"></a>simLoadScene
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxLoadScene">simxLoadScene</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosLoadScene">simRosLoadScene</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Loads a previously saved scene. If current scene is not empty, a new scene will be created before switching to it and loading the scene. See also <a href="#simSaveScene">simSaveScene</a>, <a href="#simLoadModel">simLoadModel</a>, <a href="#simLoadUI">simLoadUI</a>, <a href="#simCloseScene">simCloseScene</a> and <a href="#simSetBooleanParameter">simSetBooleanParameter</a> with <a href="apiConstants.htm#booleanParameters">sim_boolparam_scene_and_model_load_messages</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLoadScene(const simChar* filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: scene filename. The filename extension is required (&quot;ttt&quot;)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simLoadUI" id="simLoadUI"></a>simLoadUI
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxLoadUI">simxLoadUI</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosLoadUI">simRosLoadUI</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Loads a previously saved custom user interface file (*.ttb-files). See also <a href="#simSaveUI">simSaveUI</a>, <a href="#simLoadModel">simLoadModel</a>, <a href="#simLoadScene">simLoadScene</a>, and <a href="#simSetBooleanParameter">simSetBooleanParameter</a> with <a href="apiConstants.htm#booleanParameters">sim_boolparam_scene_and_model_load_messages</a>. When interacting with a UI from an <a href="addOns.htm">add-on</a>, you might have to add the property flag <a href="apiConstants.htm#uiProperties">sim_ui_property_pauseactive</a> to the UI, in order to also have it respond while simulation is paused.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLoadUI(const simChar* filename,int maxCount,int* uiHandles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: UI filename. The filename extension is required (&quot;ttb&quot;)</div>
<div><strong>maxCount</strong>: the maximum number of items that the uiHandles pointer can hold</div>
<div><strong>uiHandles</strong>: a pointer to integer values that will receive the handles of the loaded UIs (a single UI file can hold an unlimited number of UI elements)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of UI elements loaded.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table handles=simLoadUI(string filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>handles</strong>: a table containing the handles of all loaded UI elements, or nil in case of an error</div>
</td> 
</tr> 
</table> 
<br>





<h3><a name="simLockInterface" id="simLockInterface"></a>simLockInterface</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Locks or unlocks the C and Lua API interfaces for other threads. Use carefully and only in special situations. Locking the interface n times will require unlocking it n times as well. See also the <a href="#simSetThreadIsFree">simSetThreadIsFree</a> function.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simLockInterface(simBool locked)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>locked</strong>: indicates whether the interface should be locked or unlocked</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the return value represents the current degree of locking (0=unlocked, &gt;1 --&gt; locked).<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number lockDegree=simLockInterface(boolean locked)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simMoveToJointPositions" id="simMoveToJointPositions"></a>simMoveToJointPositions (DEPRECATED)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>DEPRECATED. See <a href="#simRMLMoveToJointPositions">simRMLMoveToJointPositions </a>instead. <br>
<br>
Moves (actuates) several joints at the same time. This function can only be called from child scripts running in a thread (since this is a blocking operation) and is not available from the C-API. See also <a href="#simMoveToPosition">simMoveToPosition</a>, <a href="#simMoveToObject">simMoveToObject</a> and <a href="#simFollowPath">simFollowPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number deltaTimeLeft=simMoveToJointPositions(table jointHandles,table jointPositions,number/table velocity,number/table accel,number angleToLinearCoeff)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>jointHandles</strong>: table containing the handles of the joints to be actuated. Only prismatic joints, revolute joints and screws can be actuated with this command. Depending on the joint operation mode and settings, results can be different than expected. When the joint is in torque/force mode, make sure its position control is enabled and the upper limit velocity is higher than what will be required. <br>
</div>
<div><strong>jointPositions</strong>: table containing the corresponding desired joint positions specified in meters or radians.<br>
</div>
<div><strong>velocity</strong>: the maximum target velocity at which the joints will move. Specified in meters/seconds. The velocity argument can be a number (1) or a table (2). (1): all joints will start and end movement at the same time, (2): each joint will move at its respective velocity (specified in the table). Revolute joint velocities are velocity/angleToLinearCoeff (see the angleToLinearCoeff argument description).<br>
</div>
<div><strong>accel</strong>: the maximum acceleration to apply in order to reach the target velocity, specified in meters/seconds^2. As for the velocity, this argument can be a number or a table. If the velocity argument is a number, this argument should also be a number, and if the velocity argument is a table, this argument should also be a table. 0 indicates an infinite acceleration. This argument can be omitted in which case an infinite acceleration is applied.<br>
</div>
<div><strong>angleToLinearCoeff</strong>: used with revolute joints to obtain the desired angular velocity or acceleration (since the velocity and accel arguments are always specified as linear values). This argument can be omitted in which case a value of 1 will be used.<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>deltaTimeLeft</strong>: if the time needed to reach the position is not a multiple of the simulation time step, then deltatimeLeft is the execution time left at current simulation time. deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is nil in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simMoveToObject" id="simMoveToObject"></a>simMoveToObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Moves an object to the position/orientation of another moving object (target object) by performing interpolations (i.e. the object will effectiviely follow the target object). If the target object is a path, a position on the path can be specified. If the target object is not moving, use rather <a href="#simGetObjectPosition">simGetObjectPosition</a>, <a href="#simGetObjectOrientation">simGetObjectOrientation</a> or <a href="#simGetPositionOnPath">simGetPositionOnPath</a>, <a href="#simGetOrientationOnPath">simGetOrientationOnPath</a> in conjunction with <a href="#simRMLMoveToPosition">simRMLMoveToPosition</a>. This function can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is a blocking operation) and is not available from the C-API. See also <a href="#simFollowPath">simFollowPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number deltaTimeLeft=simMoveToObject(number objectHandle,number targetObjectHandle,number positionAndOrOrientation,number relativeDistanceOnPath,number velocity,number acceleration)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the object to be moved</div>
<div><strong>targetObjectHandle</strong>: handle of the object to be followed</div>
<div><strong>positionAndOrOrientation</strong>: a value between 1 and 3 (1: only position is modified, 2: only orientation is modified, 3: position and orientation is modified). Can be nil in which case 3 is applied.<br>
</div>
<div><strong>relativeDistanceOnPath</strong>: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate <a href="pathPositionCalculationMethod.htm">path length calculation method</a>. Can be nil in which case the path object is treated as a regular object.<br>
</div>
<div><strong>velocity</strong>: movement velocity expressed in 1/s (i.e. the inverse of the velocity indicates the time that will be taken to reach the target object)<br>
</div>
<div><strong>acceleration</strong>: the acceleration/deceleration expressed in 1/s^2. Can be nil in which case an infinite acceleration is applied.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>deltaTimeLeft</strong>: if the time needed to reach the target object is not a multiple of the simulation time step, then deltatimeLeft is the execution time left at current simulation time. deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is nil in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simMoveToPosition" id="simMoveToPosition"></a>simMoveToPosition (DEPRECATED)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>DEPRECATED. Use <a href="#simRMLMoveToPosition">simRMLMoveToPosition</a> instead.
<br>
<br>
Moves an object to a given position and/or orientation. This function can only be called from child scripts running in a thread (since this is a blocking operation) and is not available from the C-API. If you want to move several objects at the same time from the same thread, you will have to attach the objects to joints and use the <a href="#simMoveToJointPositions">simMoveToJointPositions</a> function (or you could manually move all objects little by little with the <a href="#simSetObjectPosition">simSetObjectPosition</a> and <a href="#simSetObjectOrientation">simSetObjectOrientation</a> functions). See also <a href="#simMoveToObject">simMoveToObject</a> and <a href="#simFollowPath">simFollowPath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number deltaTimeLeft=simMoveToPosition(number objectHandle,number relativeToObjectHandle,table_3 position,table_3 orientation,number velocity,number acceleration,table_2 distanceCalculationMethod)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>objectHandle</strong>: handle of the object to be moved</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the movement should be performed. Specify -1 for a movement relative to the absolute reference frame, sim_handle_parent for a movement relative to the object's parent frame, or an object handle relative to whose reference frame the movement should be performed.<br>
</div>
<div><strong>position</strong>: target position. Can be nil, in which case the current position is kept<br>
</div>
<div><strong>orientation</strong>: target orientation (Euler angles). Can be nil, in which case the current orientation is kept<br>
</div>
<div><strong>velocity</strong>: the target velocity for the movement. Velocity is relative to the specified distanceCalculationMethod<br>
</div>
<div><strong>acceleration</strong>: the acceleration/deceleration. Can be nil in which case an infinite acceleration is applied<br>
</div>
<div><strong>distanceCalculationMethod</strong>: a table containing: 1) The <a href="apiConstants.htm#distanceCalculationMethods">distance calculation method</a> and 2) the angular to linear conversion coefficient. Can be nil in which case {sim_distcalcmethod_dl_if_nonzero,0.06366} is used. Refer to the <a href="pathPositionCalculationMethod.htm">path position calculation method</a> section for more information. <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>deltaTimeLeft</strong>: if the time needed to reach the position is not a multiple of the simulation time step, then deltatimeLeft is the execution time left at current simulation time. deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is nil in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simMsgBox" id="simMsgBox"></a>simMsgBox</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a modal message box for interaction with the user. Should only be called from the main thread. See also <a href="#simFileDialog">simFileDialog</a> and <a href="#simDisplayDialog">simDisplayDialog</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simMsgBox(simInt dlgType,simInt buttons,const simChar* title,const simChar* message)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dlgType</strong>: the <a href="apiConstants.htm#msgBoxTypes">message box type</a>.</div>
<div><strong>buttons</strong>: the <a href="apiConstants.htm#msgBoxButtons">buttons to display</a>.</div>
<div><strong>title</strong>: title of the dialog</div>
<div><strong>message</strong>: the message to display</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a <a href="apiConstants.htm#msgBoxReturn">message box return value</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number returnValue=simMsgBox(number dlgType,number buttons,string title,string message)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>









<h3><a name="simMultiplyMatrices" id="simMultiplyMatrices"></a>simMultiplyMatrices</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Multiplies two transformation matrices<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simMultiplyMatrices(const simFloat* matrixIn1,const simFloat* matrixIn2,simFloat* matrixOut)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixIn1</strong>: the first input matrix</div>
<div><strong>matrixIn2</strong>: the second input matrix</div>
<div><strong>matrixOut</strong>: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).</div>
<div class=tab>A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 resultMatrix=simMultiplyMatrices(table_12 matrixIn1,table_12 matrixIn2)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>resultMatrix</strong>: the result matrix (a table containing 12 values (the last row (0,0,0,1) is omitted)). Table values in Lua are indexed from 1, not 0!</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simMultiplyVector" id="simMultiplyVector"></a>simMultiplyVector</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Multiplies a vector with a transformation matrix (v=m*v). See <a href="#simTransformVector">simTransformVector</a> for the C-API version.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_3 resultVector=simMultiplyVector(table_12 matrix,table_3 vector)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>matrix</strong>: the transformation matrix (a table containing 12 values (the last row (0,0,0,1) is not required))</div>
<div><strong>vector</strong>: the original vector (a table containing 3 values (the last element (1) of the homogeneous coordinates is not required)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>resultVector</strong>: the result vector (a table containing 3 values (the last element (1) of the homogeneous coordinates is omitted))<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simOpenModule" id="simOpenModule"></a>simOpenModule</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>&quot;Opens&quot; a plugin (allowing it to reserve resources at the start of a simulation). This command can only be called from the main script. Call it from the <a href="mainScript.htm">main script</a> in the first simulation pass (usually with sim_handle_all argument). <a href="#simOpenModule">simOpenModule</a> is not available in the C-API. Look at the default main script to get an idea about how to use <a href="#simOpenModule">simOpenModule</a>, <a href="#simHandleModule">simHandleModule</a> and <a href="#simCloseModule">simCloseModule</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number result=simOpenModule(number sim_handle_all)</div>
<div>(2) number result=simOpenModule(string moduleName)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>sim_handle_all: indicates that all plugins should be opened</div>
<div>moduleName: the name of the plugin that should be opened</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, otherwise result is the number of plugins that executed the command.</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simPackFloats" id="simPackFloats"></a>simPackFloats</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Packs a table of floating-point numbers into a string. See also <a href="#simUnpackFloats">simUnpackFloats</a> and <a href="#simPackInts">simPackInts</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=simPackFloats(table floatingNumbers)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>floatingNumbers</strong>: a table containing floating-point numbers. Non-numbers will be packed as zero values<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed floating-point numbers from the table if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simPackInts" id="simPackInts"></a>simPackInts</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Packs a table of integer numbers into a string. See also <a href="#simUnpackInts">simUnpackInts</a> and <a href="#simPackFloats">simPackFloats</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=simPackInts(table integerNumbers)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>integerNumbers</strong>: a table containing integer numbers. Non-numbers will be packed as zero values</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed integer numbers from the table if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simPauseSimulation" id="simPauseSimulation"></a>simPauseSimulation
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxPauseSimulation">simxPauseSimulation</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosPauseSimulation">simRosPauseSimulation</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Requests a pause of a simulation. See also <a href="#simStartSimulation">simStartSimulation</a> and <a href="#simStopSimulation">simStopSimulation</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPauseSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simPauseSimulation()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simPerformPathSearchStep" id="simPerformPathSearchStep"></a>simPerformPathSearchStep</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Performs a path search in several sub-steps. <a href="#simInitializePathSearch">simInitializePathSearch</a> has to be called previously. Call this function in a loop until the return value is different from -2. When operating from a threaded child script, rather use the <a href="#simSearchPath">simSearchPath</a> function<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPerformPathSearchStep(simInt temporaryPathSearchObject,simBool abortSearch)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>temporaryPathSearchObject</strong>: handle of a temporary path search object (returned by <a href="#simInitializePathSearch">simInitializePathSearch</a>)</div>
<div><strong>abortSearch</strong>: 0 to continue the search, any other value to abort</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-2 if nothing was found but search can continue (by calling this function again), -1 in case of an error, 0 if no path was found, 1 if a partial path was found, and 2 if a full path was found. Unless the return value is -2, the temporary path search object will be destroyed<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simPerformPathSearchStep(number temporaryPathSearchObjectHandle,boolean abortSearch)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>





<h3><a name="simPersistentDataRead" id="simPersistentDataRead"></a>simPersistentDataRead</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads a block of persistent data. See also <a href="#simPersistentDataWrite">simPersistentDataWrite</a>, <a href="#simGetStringSignal">simGetStringSignal</a>, <a href="#simGetIntegerSignal">simGetIntegerSignal</a>,  <a href="#simGetFloatSignal">simGetFloatSignal</a> and <a href="#simGetSceneCustomData">simGetSceneCustomData</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simPersistentDataRead(const simChar* dataName,simInt* dataLength)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dataName</strong>: name of the data block</div>
<div><strong>dataLength</strong>: the size of the returned data block, since it may contain any data (also embedded zeros).</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>NULL if operation was not successful or data block does not exist, otherwise the data block (which may contain any value, including embedded zeros). In that case the returned buffer should be released with <a href="#simReleaseBuffer">simReleaseBuffer</a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string dataValue=simPersistentDataRead(string dataName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>

<div><strong>dataName</strong>: name of the data block</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>dataValue</strong>: value of the data block, or nil if operation was not successful or data block does not exist. The returned data block may contain any value, including embedded zeros.</div>
<div></div></td> 
</tr> 
</table> 
<br>





<h3><a name="simPersistentDataWrite" id="simPersistentDataWrite"></a>simPersistentDataWrite</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Writes a persistent data block. Persistent data, valid across all opened simulator scenes, remains until the simulator ends, or until it is cleared by writing an empty data block. If the options flag is set appropriately, then persistent data can also be stored on file, and be automatically reloaded next time V-REP starts. See also <a href="#simPersistentDataRead">simPersistentDataRead</a>, <a href="#simSetStringSignal">simSetStringSignal</a>, <a href="#simSetIntegerSignal">simSetIntegerSignal</a>, <a href="#simSetFloatSignal">simSetFloatSignal</a> and <a href="#simAddSceneCustomData">simAddSceneCustomData</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simPersistentDataWrite(const simChar* dataName,const simChar* dataValue,simInt dataLength,simInt options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dataName</strong>: name of the data block</div>
<div><strong>dataValue</strong>: content of the data block (which may contain any value, including embedded zeros). If dataValue is an empty string, then the data block is cleared (if present).</div>
<div><strong>dataLength</strong>: the size of the data block.</div>
<div><strong>options</strong>: bit-coded. If bit 0 is set, then the data is also stored on file ("system/persistentData.dat"), and automatically reloaded next time V-REP start.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simPersistentDataWrite(string dataName,string dataValue,number options=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simReadCollision" id="simReadCollision"></a>simReadCollision
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxReadCollision">simxReadCollision</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosReadCollision">simRosReadCollision</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the collision state of a registered collision object. This function doesn't perform collision detection, it merely reads the result from a previous call to <a href="#simHandleCollision">simHandleCollision</a> (simHandleCollision is called in the default main script). See also <a href="#simResetCollision">simResetCollision</a>, <a href="#simCheckCollision">simCheckCollision</a> and <a href="#simCheckCollisionEx">simCheckCollisionEx</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadCollision(simInt collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collisionObjectHandle</strong>: handle of the collision object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>collision state (0 or 1), or -1 if operation was not successful, or if <a href="#simHandleCollision">simHandleCollision</a> was never called, or if <a href="#simResetCollision">simResetCollision</a> was previously called.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number collisionState=simReadCollision(number collisionObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simReadDistance" id="simReadDistance"></a>simReadDistance
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxReadDistance">simxReadDistance</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosReadDistance">simRosReadDistance</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the distance of a registered distance object. This function doesn't perform distance measurement, it merely reads the result from a previous call to <a href="#simHandleDistance">simHandleDistance</a> (simHandleDistance is called in the default main script). See also <a href="#simResetDistance">simResetDistance</a> and <a href="#simCheckDistance">simCheckDistance</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadDistance(simInt distanceObjectHandle,simFloat* smallestDistance)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>distanceObjectHandle</strong>: handle of the distance object</div>
<div><strong>smallestDistance</strong>: smallest distance (valid only if return value is different from -1)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>different from -1 if distance was read, -1 in case of an error, or if <a href="#simHandleDistance">simHandleDistance</a> was never called, or if <a href="#simResetDistance">simResetDistance</a> was previously called.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number smallestDistance=simReadDistance(number distanceObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: different from -1 if distance was read, -1 in case of an error, or if <a href="#simHandleDistance">simHandleDistance</a> was never called, or if <a href="#simResetDistance">simResetDistance</a> was previously called.<br>
</div>
<div><strong>smallestDistance</strong>: the smallest distance. Is nil if result is -1</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simReadForceSensor" id="simReadForceSensor"></a>simReadForceSensor
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxReadForceSensor">simxReadForceSensor</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosReadForceSensor">simRosReadForceSensor</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the force and torque applied to a force sensor (filtered values are read), and its current state ('unbroken' or 'broken'). See also <a href="#simBreakForceSensor">simBreakForceSensor</a> and <a href="#simJointGetForce">simJointGetForce</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadForceSensor(simInt objectHandle,simFloat* forceVector,simFloat* torqueVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object (must be a force sensor)</div>
<div><strong>forceVector</strong>: pointer to 3 values (applied forces along the sensor's x, y and z-axes). Can be NULL</div>
<div><strong>torqueVector</strong>: pointer to 3 values (applied torques about the sensor's x, y and z-axes). Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, otherwise bit-coded:</div>
<div class=tab>bit 0 set: force and torque data is available, otherwise it is not (yet) available (e.g. when not enough values are present for the filter)<br>
</div>
<div class=tab>bit 1 set: force sensor is broken, otherwise it is still intact ('unbroken')<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result, table_3 forceVector,table_3 torqueVector=simReadForceSensor(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: -1 in case of an error, otherwise bit-coded (same as for the C-function return value)</div>
<div><strong>forceVector</strong>: table holding 3 values (applied forces along the sensor's x, y and z-axes)</div>
<div><strong>torqueVector</strong>: table holding 3 values (applied torques about the sensor's x, y and z-axes)</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simReadProximitySensor" id="simReadProximitySensor"></a>simReadProximitySensor
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxReadProximitySensor">simxReadProximitySensor</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosReadProximitySensor">simRosReadProximitySensor</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the state of a proximity sensor. This function doesn't perform detection, it merely reads the result from a previous call to <a href="#simHandleProximitySensor">simHandleProximitySensor</a> (simHandleProximitySensor is called in the default main script). See also <a href="#simCheckProximitySensor">simCheckProximitySensor</a>, <a href="#simCheckProximitySensorEx">simCheckProximitySensorEx</a> and <a href="#simResetProximitySensor">simResetProximitySensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadProximitySensor(simInt sensorHandle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* detectedSurfaceNormalVector)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of a proximity sensor object</div>
<div><strong>detectedPoint</strong>: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULL<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of the object that was detected. Can be NULL<br>
</div>
<div><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULL<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>detection state (0 or 1), or -1 in case of an error, or if <a href="#simHandleProximitySensor">simHandleProximitySensor</a> was never called, or if <a href="#simResetProximitySensor">simResetProximitySensor</a> was previously called.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,number distance,table_3 detectedPoint,number detectedObjectHandle,table_3 detectedSurfaceNormalVector=simReadProximitySensor(number sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: detection state (0 or 1), or -1 in case of an error, or if <a href="#simHandleProximitySensor">simHandleProximitySensor</a> was never called, or if <a href="#simResetProximitySensor">simResetProximitySensor</a> was previously called.<br>
</div>
<div><strong>distance</strong>: distance to the detected point if result is 1, nil otherwise<br>
</div>
<div><strong>detectedPoint</strong>: table of 3 numbers indicating the relative coordinates of the detected point if result is 1, nil otherwise<br>
</div>
<div><strong>detectedObjectHandle</strong>: handle of the object that was detected if result is 1, nil otherwise<br>
</div>
<div><strong>detectedSurfaceNormalVector</strong>: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Is nil if result is different from 1<br>
</div>
<div></div>
</td> 
</tr> 
</table> 
<br>








<h3><a name="simReadVisionSensor" id="simReadVisionSensor"></a>simReadVisionSensor
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxReadVisionSensor">simxReadVisionSensor</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosReadVisionSensor">simRosReadVisionSensor</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads the state of a vision sensor. This function doesn't perform detection, it merely reads the result from a previous call to <a href="#simHandleVisionSensor">simHandleVisionSensor</a> (simHandleVisionSensor is called in the default main script). See also <a href="#simCheckVisionSensor">simCheckVisionSensor</a>, <a href="#simCheckVisionSensorEx">simCheckVisionSensorEx</a> and <a href="#simResetVisionSensor">simResetVisionSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReadVisionSensor(simInt visionSensorHandle,simFloat** auxValues,simInt** auxValuesCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>visionSensorHandle</strong>: handle of a vision sensor object</div>
<div><strong>auxValues</strong>: auxiliary values returned from the <a href="visionSensorFilterComposition.htm">applied filters</a>. By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValues).<br>
</div>
<div><strong>auxValuesCount</strong>: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*auxValuesCount).<br>
</div>
<br>
<div>See <a href="#simHandleVisionSensor">simHandleVisionSensor</a> for a usage example</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>detection state (0 or 1), or -1 in case of an error, or if <a href="#simHandleVisionSensor">simHandleVisionSensor</a> was never called, or if <a href="#simResetVisionSensor">simResetVisionSensor</a> was previously called.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table auxiliaryValuePacket1,table auxiliaryValuePacket2, etc.=simReadVisionSensor(number visionSensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>visionSensorHandle</strong>: handle of a vision sensor object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: detection state (0 or 1), or -1 in case of an error, or if <a href="#simHandleVisionSensor">simHandleVisionSensor</a> was never called, or if <a href="#simResetVisionSensor">simResetVisionSensor</a> was previously called.<br>
</div>
<div><strong>auxiliaryValuePacket1</strong>: default auxiliary value packet (same as for the C-function)</div>
<div><strong>auxiliaryValuePacket2</strong>: additional auxiliary value packet (e.g. from a filter component)</div>
<div><strong>auxiliaryValuePacket3</strong>: etc. (the function returns as many tables as there are auxiliary value packets)</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simReceiveData" id="simReceiveData"></a>simReceiveData</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Receives wireless data (in a simulation). See also <a href="#simSendData">simSendData</a> and <a href="#simTubeOpen">simTubeOpen</a>. Cannot be called from <a href="addOns.htm">add-ons</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simReceiveData(simInt dataHeader,const simChar* dataName,simInt antennaHandle,simInt index,simInt* dataLength,simInt* senderID,simInt* dataHeaderR,simChar** dataNameR)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). For details on the dataHeader, also refer to <a href="#simAddObjectCustomData">simAddObjectCustomData</a>.<br>
</div>
<div><strong>dataName</strong>: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)<br>
</div>
<div><strong>antennaHandle</strong>: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.<br>
</div>
<div><strong>index</strong>: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.<br>
</div>
<div><strong>dataLength</strong>: length of the received data (if returned pointer is not NULL)<br>
</div>
<div><strong>senderID</strong>: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.<br>
</div>
<div><strong>dataHeaderR</strong>: dataHeader of the data that was read. Can be NULL.</div>
<div><strong>dataNameR</strong>: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>(*dataNameR).<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>pointer to the received data, or NULL if no data is available or in case of an error. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data,number senderID,number dataHeader,string dataName=simReceiveData(number dataHeader=-1,string dataName=nil,number antennaHandle=sim_handle_self,number index=-1)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). This value can be omitted (-1 will be used). For details on the dataHeader, also refer to <a href="#simAddObjectCustomData">simAddObjectCustomData</a>.<br>
</div>
<div><strong>dataName</strong>: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1). This value can be omitted (nill will be used)<br>
</div>
<div><strong>antennaHandle</strong>: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated. If sim_handle_self is specified, the object associated with the current child script is used as the antenna. This value can be omitted (sim_handle_self will be used)<br>
</div>
<div><strong>index</strong>: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read. This value can be omitted (-1 will be used)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: string containing the received data, or nil in case of an error or if no data is present. If received data is packed, see also <a href="#simUnpackInts">simUnpackInts</a> and <a href="#simUnpackFloats">simUnpackFloats</a><br>
</div>
<div><strong>senderID</strong>: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API.<br>
</div>
<div><strong>dataHeader</strong>: dataHeader of the data that was read.<br>
</div>
<div><strong>dataName</strong>: dataName of the data that was read.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRefreshDialogs" id="simRefreshDialogs"></a>simRefreshDialogs</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Refreshes V-REP's internal dialogs. Calling <a href="#simRefreshDialogs">simRefreshDialogs</a> will not trigger a <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_refreshdialogs</a> message<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRefreshDialogs(simInt refreshDegree)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>refreshDegree</strong>: refresh degree (0=light, 1=medium, 2=full)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simRefreshDialogs(number refreshDegree)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRegisterContactCallback" id="simRegisterContactCallback"></a>simRegisterContactCallback</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Registers or unregisters a contact callback function for customized contact handling. Several plugins can register a callback, and the callbacks will be cascaded if not interrupted. This function is not available in the Lua-API.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRegisterContactCallback(simInt(*callBack)(simInt,simInt,simInt,simInt*,simFloat*));<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>callback address. Specify the function you wish to resister/unregister as callback. When the function is already registered, it will be unregistered. Following describes the callback's arguments:<br>
</div>
<br>
<div><strong>first argument (int)</strong>: handle of the first object that is involved in the contact. Could also be the handle of a dynamic particle<br>
</div>
<div><strong>second argument (int)</strong>: handle of the second object that is involved in the contact. Could also be the handle of a dynamic particle<br>
</div>
<div><strong>third argument (int)</strong>: the selected <a href="apiConstants.htm#physicsEngineTypes">physics engine</a><br>
</div>
<br>
<div>The forth and fifth argument (allocated by V-REP) allow you to specify how the contact should behave (see also the respective Bullet and ODE reference manuals):<br>
</div>
<br>
<div><strong>forth argument (int*)</strong></div>
<div class=tab>[0] should be set to zero (indicates the function version, for future extensions)</div>
<div class=tab>[1] Bullet: not used (keep 0). ODE: contactCount (max. number of contact points to generate)</div>
<div class=tab>[2] Bullet: not used (keep 0). ODE: contactMode (can be bit-wise combined):</div>
<div class=tabTab>1=dContactMu2</div>
<div class=tabTab>2=dContactFDir1</div>
<div class=tabTab>4=dContactBounce</div>
<div class=tabTab>8=dContactSoftERP</div>
<div class=tabTab>16=dContactSoftCFM</div>
<div class=tabTab>32=dContactMotion1</div>
<div class=tabTab>64=dContactMotion2</div>
<div class=tabTab>128=dContactSlip1</div>
<div class=tabTab>256=dContactSlip2</div>
<div class=tabTab>512=dContactApprox1_1</div>
<div class=tabTab>1024=dContactApprox1_2</div>
<div class=tabTab>2048=dContactApprox1</div>




<div><strong>Fifth argument (float*)</strong></div>
<div class=tab>[0] Bullet: combined friction. ODE: mu</div>
<div class=tab>[1] Bullet: combined restitution. ODE: mu2</div>
<div class=tab>[2] Bullet: not used (keep 0.0). ODE: bounce</div>
<div class=tab>[3] Bullet: not used (keep 0.0). ODE: bounce_vel</div>
<div class=tab>[4] Bullet: not used (keep 0.0). ODE: soft_cfm</div>
<div class=tab>[5] Bullet: not used (keep 0.0). ODE: soft_erp</div>
<div class=tab>[6] Bullet: not used (keep 0.0). ODE: motion1</div>
<div class=tab>[7] Bullet: not used (keep 0.0). ODE: motion2</div>
<div class=tab>[8] Bullet: not used (keep 0.0). ODE: motionN</div>
<div class=tab>[9] Bullet: not used (keep 0.0). ODE: slip1</div>
<div class=tab>[10] Bullet: not used (keep 0.0). ODE: slip2</div>
<div class=tab>[11] Bullet: not used (keep 0.0). ODE: fdir1[0]</div>
<div class=tab>[12] Bullet: not used (keep 0.0). ODE: fdir1[1]</div>
<div class=tab>[13] Bullet: not used (keep 0.0). ODE: fdir1[2]</div>
<br>
<div>The callback return value can be:</div>
<div class=tab><strong>-1</strong>: the callback doesn't process the contact and hands the contact to the next callback. If no callback processes it, the default contact handling is used<br>
</div>
<div class=tab><strong>0</strong>: the contact is ignored and the two objects won't have a collision response</div>
<div class=tab><strong>&gt;0</strong>: the contact will be handled with above's values (the default values are overridden)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the callback was unregistered, 1 if the callback was registered<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRegisterCustomLuaFunction" id="simRegisterCustomLuaFunction"></a>simRegisterCustomLuaFunction</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Registers a customized lua function. This function is useful for plugins (or the main client application) that wish to provide their own or customized Lua functions. See also <a href="#simRegisterCustomLuaVariable">simRegisterCustomLuaVariable</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRegisterCustomLuaFunction(const simChar* funcName,const simChar* callTips,const simInt* inputArgumentTypes,simVoid(*callBack)(struct SLuaCallBack* p))<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>functName</strong>: name of the function. Avoid using too simple function names, otherwise they might clash with other plugins. Also, always use the &quot;simExt&quot; prefix (e.g. &quot;simExtMyCustomFunction&quot;).<br>
</div>
<div><strong>callTips</strong>: call tips: string (or several strings separated by '@') that indicates the input/output argument type/size. Call tips appear in the script editor when the function was typed followed by &quot;(&quot;. callTips Can be NULL<br>
</div>
<div><strong>inputArgumentTypes</strong>: array indicating the desired input arguments. This is important so that the simulator knows how to convert between Lua types (e.g. Lua value&quot;4.2&quot; can be converted to int 4, to float 4.2, to string &quot;4.2&quot; or to Boolean 1). Can be NULL, in that case no input argument is forwarded to the callback address. inputArgumentTypes[0] represents the number of input arguments we wish to be forwarded, inputArgumentTypes[1] is the type of the first argument, inputArgumentTypes[2] is the type of the second argument, etc. An input argument type can be sim_lua_arg_bool, sim_lua_arg_int, sim_lua_arg_float or sim_lua_arg_string, that can be combined (|) with sim_lua_arg_table if table values are desired. <br>
</div>
<div><strong>callback</strong>: callback address that is called when the &quot;functName&quot; function is called from Lua with the right arguments. The callback's first argument is a SLuaCallBack structure that holds:<br>
</div>
<br>
<div><strong>simInt objectID</strong>: handle of the object that the calling script is attached to, or -1 if the calling script is not a child script<br>
</div>
<div><strong>simChar* inputBool</strong>: pointer to all Boolean input arguments</div>
<div><strong>simInt* inputInt</strong>: pointer to all integer input arguments</div>
<div><strong>simFloat* inputFloat</strong>: pointer to all floating point input arguments</div>
<div><strong>simChar* inputChar</strong>: pointer to all string input arguments. Strings are separated by the &quot;zero-char&quot;</div>
<div><strong>simInt inputArgCount</strong>: number of input arguments.</div>
<div><strong>simInt* inputArgTypeAndSize</strong>: pointer to input argument's type and size (e.g. with &quot;inputArgCount==2&quot; we could have &quot;inputArgTypeAndSize[0]==sim_lua_arg_int|sim_lua_arg_table&quot;, &quot;inputArgTypeAndSize[1]==3&quot;, &quot;inputArgTypeAndSize[2]==sim_lua_arg_char&quot;, &quot;inputArgTypeAndSize[3]==1&quot;. This would mean that we have two input arguments: (1) an integer table of size 3 and (2) a string)<br>
</div>
<div><strong>simChar* outputBool</strong>: similar to inputBool, but for output values. The user is in charge of allocating the buffer with correct size with <a href="#simCreateBuffer">simCreateBuffer</a> (outputBool=new char[n] will not work!!). The simulator will automatically release the buffer when the callback returns.<br>
</div>
<div><strong>simInt* outputInt</strong>: similar to inputInt, but for output values. The user is in charge of allocating the buffer with correct size with <a href="#simCreateBuffer">simCreateBuffer</a> (outputInt=new int[n] will not work!!). The simulator will automatically release the buffer when the callback returns.<br>
</div>
<div><strong>simFloat* outputFloat</strong>: similar to inputFloat, but for output values. The user is in charge of allocating the buffer with correct size with <a href="#simCreateBuffer">simCreateBuffer</a> (outputBool=new float[n] will not work!!). The simulator will automatically release the buffer when the callback returns.<br>
</div>
<div><strong>simChar* outputChar</strong>: similar to inputChar, but for output values. The user is in charge of allocating the buffer with correct size with <a href="#simCreateBuffer">simCreateBuffer</a> (outputChar=new char[n] will not work!!). The simulator will automatically release the buffer when the callback returns. If you return 2 strings &quot;ab&quot; and &quot;cde&quot;, the buffer should look like: &quot;ab@cde@&quot; (@ being the zero char).<br>
</div>
<div><strong>simInt outputArgCount</strong>: similar to inputArgCount, but for output values</div>
<div><strong>simInt* outputArgTypeAndSize</strong>: similar to inputArgTypeAndSize, but for output values. The user is in charge of allocating the buffer with correct size with <a href="#simCreateBuffer">simCreateBuffer</a> (outputArgTypeAndSize=new int[n] will not work!!). The simulator will automatically release the buffer when the callback returns.<br>
</div>
<br>
<div>Values are stored in input or output arrays in the order they appear as arguments or return values e.g. with input arguments: number_int 1,table_2_float {2.0,3.0},string 'hello',number_int 4,string 'bye' we would have following input arrays:<br>
</div>
<br>
<pre class=lightBlueBoxNoMarginAndSmall>
inputBool==NULL
inputInt=={1,4}
inputFloat=={2.0,3.0}
inputChar=="hello@bye@"
inputArgCount==5
inputArgTypeAndSize=={sim_lua_arg_int,1,sim_lua_arg_float|sim_lua_arg_table,
            2,sim_lua_arg_string,1, sim_lua_arg_int,1, sim_lua_arg_string,1}</pre>

<div><strong>simChar waitUntilZero</strong>: this value can be used when threaded scripts call a custom Lua function in a plugin that shouldn't return until a condition is met (e.g. until the robot movement finished). For that puspose, the plugin should write a value different from zero to indicate a &quot;wait&quot; state. When the callback returns, the control is not given back to the script until some other thread calling the plugin writes zero to that location. Once zero was written, the memory location should not be used anymore (because it might be released anytime by the simulator). Also, when the user stops a simulation before zero was written to that location, the wait state is aborted. In that case however the memory location stays valid (i.e. writing zero will not result in a crash) until the simulation ended.<br>
</div>
<br>
<div>Make sure to also have a look at the various plugin projects (in the installation directory) to get an idea how to register custom Lua commands</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if function was registered, 0 if function was replaced (when that function name already existed), -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRegisterCustomLuaVariable" id="simRegisterCustomLuaVariable"></a>simRegisterCustomLuaVariable</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Registers a customized lua variable. Lua doesn't directly support constants, so the variables registered with this function can be changed during runtime. However, at each simulation start, the variables registered with this function are reset to their original values. See also <a href="#simRegisterCustomLuaFunction">simRegisterCustomLuaFunction</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRegisterCustomLuaVariable(const simChar* varName,const simChar* varValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>varName</strong>: name of the variable</div>
<div><strong>varValue</strong>: value of the variable</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if the variable was registered, 0 if the variable was replaced because it already existed, -1 in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>




















<h3><a name="simReleaseBuffer" id="simReleaseBuffer"></a>simReleaseBuffer (remote API equivalent: <a href="remoteApiFunctions.htm#simxReleaseBuffer">simxReleaseBuffer</a>)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Releases a buffer previously created with <a href="#simCreateBuffer">simCreateBuffer</a> or a buffer returned by the simulator. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReleaseBuffer(simChar* buffer)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>buffer</strong>: buffer to be released</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simReleaseScriptRawBuffer" id="simReleaseScriptRawBuffer"></a>simReleaseScriptRawBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes (destroys) a script's raw buffer. All raw buffers are automatically released at the end of a simulation, but depending on the extent of use of the raw buffers, it might be a good idea to release them when not needed anymore. See also <a href="#simGetScriptRawBuffer">simGetScriptRawBuffer</a> and <a href="#simSetScriptRawBuffer">simSetScriptRawBuffer</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simReleaseScriptRawBuffer(simInt scriptHandle,simInt bufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script. Can be sim_handle_main_script or sim_handle_all (in that case the bufferHandle is automatically also sim_handle_all)<br>
</div>
<div><strong>bufferHandle</strong>: handle of the raw buffer or sim_handle_all to release all raw buffers of the given script<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful (an unexisting buffer will not trigger an error). In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simReleaseScriptRawBuffer(number scriptHandle,number bufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>scriptHandle</strong>: handle of the script. Can be sim_handle_main_script, sim_handle_self, or sim_handle_all, sim_handle_tree and sim_handle_chain (in the last 3 cases the bufferHandle is automatically also sim_handle_all). With sim_handle_tree or sim_handle_chain, the calling script is not included.<br>
</div>
<div><strong>bufferHandle</strong>: handle of the raw buffer or sim_handle_all to release all raw buffers of the given script<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRemoveBanner" id="simRemoveBanner"></a>simRemoveBanner</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Removes a previously added banner. See also <a href="#simAddBanner">simAddBanner</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveBanner(simInt bannerID)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>bannerID</strong>: handle of a previously added banner. sim_handle_all removes all banners from the scene<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simRemoveBanner(number bannerID)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>bannerID</strong>: handle of a previously added banner. sim_handle_all removes all banners from the scene, that were created in a script (banners created from the C interface are not removed)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRemoveCollection" id="simRemoveCollection"></a>simRemoveCollection</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Removes a collection from the scene 
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveCollection(simInt collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: handle of the collection to remove. sim_handle_all removes all collections from the scene</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simRemoveCollection(number collectionHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






















<h3><a name="simRemoveDrawingObject" id="simRemoveDrawingObject"></a>simRemoveDrawingObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a previously added drawing object. See also <a href="#simAddDrawingObject">simAddDrawingObject</a> and <a href="#simAddDrawingObjectItem">simAddDrawingObjectItem</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveDrawingObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a previously added drawing object. sim_handle_all removes all drawing objects from the scene<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simRemoveDrawingObject(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>objectHandle</strong>: handle of a previously added drawing object. sim_handle_all removes all drawing objects from the scene, that were created in a script (drawing objects created from the C interface are not removed)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRemoveObject" id="simRemoveObject"></a>simRemoveObject
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxRemoveObject">simxRemoveObject</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosRemoveObject">simRosRemoveObject</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes an object from the scene<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object to remove. sim_handle_all removes all objects from the scene</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simRemoveObject(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRemoveObjectFromSelection" id="simRemoveObjectFromSelection"></a>simRemoveObjectFromSelection</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes an object from the selection. See also <a href="#simAddObjectToSelection">simAddObjectToSelection</a> and <a href="#simIsObjectInSelection">simIsObjectInSelection</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveObjectFromSelection(simInt what,simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>What</strong>: indicates what we wish to remove from the selection. Valid values are sim_handle_single (removes one object from the selection), sim_handle_all (removes all objects from the selection), sim_handle_tree (removes the tree with base objectHandle (inclusive) from the selection, sim_handle_chain (removes the chain with tip objectHandle (inclusive) from the selection.<br>
</div>
<div><strong>objectHandle</strong>: handle of the object to remove from the selection. If sim_handle_all is specifies in &quot;what&quot;, then objectHandle is ignored<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>(1) number result=simRemoveObjectFromSelection(number what,number objectHandle)</div>
<div>(2) number result=simRemoveObjectFromSelection(table objectHandles)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>(1) Same as C-function. The second argument can be omitted if &quot;what&quot; is sim_handle_all</div>
<div>(2) objectHandles: table containing the handles of objects to remove. Can be nil, in which case nothing happens<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRemoveParticleObject" id="simRemoveParticleObject"></a>simRemoveParticleObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a previously added particle object. See also <a href="#simAddParticleObject">simAddParticleObject</a> and <a href="#simAddParticleObjectItem">simAddParticleObjectItem</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveParticleObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of a previously added particle object. sim_handle_all removes all particle objects from the scene<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simRemoveParticleObject(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRemoveScript" id="simRemoveScript"></a>simRemoveScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a script. Cannot be called when a simulation is running. See also <a href="#simAddScript">simAddScript</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveScript(simInt scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script to remove or sim_handle_all to remove all scripts</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simRemoveUI" id="simRemoveUI"></a>simRemoveUI
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxRemoveUI">simxRemoveUI</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosRemoveUI">simRosRemoveUI</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Removes a custom user interface. See also <a href="#simCreateUI">simCreateUI</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRemoveUI(simInt uiHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle of the custom user interface to remove. sim_handle_all removes all custom user interfaces<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simRemoveUI(number uiHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simResetCollision" id="simResetCollision"></a>simResetCollision</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears the collision state, colors, intersections, etc. for a registered collision object. See also <a href="#simHandleCollision">simHandleCollision</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetCollision(simInt collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collisionObjectHandle</strong>: handle of the collision object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all registered collision objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetCollision(number collisionObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simResetDistance" id="simResetDistance"></a>simResetDistance</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears the distance state, the distance segment, etc. for a registered distance object. See also <a href="#simHandleDistance">simHandleDistance</a>. <br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetDistance(simInt distanceObjectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>distanceObjectHandle</strong>: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all registered distance objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetDistance(number distanceObjectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simResetDynamicObject" id="simResetDynamicObject"></a>simResetDynamicObject</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Dynamically resets an object that is dynamically simulated. This means that the object representation in the dynamics engine is removed, and added again. This can be useful when the set-up of a dynamically simulated chain needs to be modified during simulation (e.g. joint or shape attachement position/orientation changed). It should be noted that calling this on a dynamically simulated object might slightly change its position/orientation relative to its parent (since the object will be disconnected from the dynamics world in its current position/orientation), so the user is in charge of rectifying for that.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetDynamicObject(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object or sim_handle_all to reset all dynamic content in the scene</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetDynamicObject(number objectHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simResetGraph" id="simResetGraph"></a>simResetGraph</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears a graph object (resets all its data streams). See also <a href="#simHandleGraph">simHandleGraph</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetGraph(simInt graphHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>graphHandle</strong>: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all graph objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetGraph(number graphHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simResetJoint" id="simResetJoint"></a>simResetJoint</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Resets a joint's motion parameters as they were before starting the simulation. Has an effect only for joint in motion mode. See also <a href="#simHandleJoint">simHandleJoint</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetJoint(simInt jointHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointHandle</strong>: handle of the joint object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all joint objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetJoint(number jointHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simResetMill" id="simResetMill"></a>simResetMill</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears all previously set mill calculation results (list of cut objects, surface and volume that were cut). See also <a href="#simHandleMill">simHandleMill</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetMill(simInt millHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>millHandle</strong>: handle of the mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all mill objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetMill(number millHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simResetMilling" id="simResetMilling"></a>simResetMilling</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Resets a cuttable object (e.g. a shape) to its initial shape (before it was milled), thus cancelling milling changes. The calculation structure linked to the object is removed and an updated calculation structure might be calculated (might take some calculation time). See also <a href="#simApplyMilling">simApplyMilling</a>, <a href="#simHandleMill">simHandleMill</a> and <a href="#simResetMill">simResetMill</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetMilling(simInt objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the cut object or sim_handle_all to reset all cut objects.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetMilling(number objectHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>




<h3><a name="simResetPath" id="simResetPath"></a>simResetPath</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Resets the motion parameters along a path object as they were before starting the simulation. See also <a href="#simHandlePath">simHandlePath</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetPath(simInt pathHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathHandle</strong>: handle of the path object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all path objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetPath(number pathHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simResetProximitySensor" id="simResetProximitySensor"></a>simResetProximitySensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears the detection state, detection color, detection segments, etc. of a proximity sensor object. See also <a href="#simHandleProximitySensor">simHandleProximitySensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetProximitySensor(simInt sensorHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all proximity sensor objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetProximitySensor(number sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simResetScript" id="simResetScript"></a>simResetScript</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Resets a script interpreter linked to a specific script. See also <a href="#simHandleMainScript">simHandleMainScript</a> and <a href="#simHandleChildScript">simHandleChildScript</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetScript(simInt scriptHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script to reset or sim_handle_all to reset all scripts</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>





<h3><a name="simResetVisionSensor" id="simResetVisionSensor"></a>simResetVisionSensor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Clears the detection state, etc. of a proximity sensor object. See also <a href="#simHandleVisionSensor">simHandleVisionSensor</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simResetVisionSensor(simInt sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all vision sensor objects, while sim_handle_all_except_explicit will only reset those that are not marked as &quot;explicit handling&quot;)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simResetVisionSensor(number sensorHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simResumeThreads" id="simResumeThreads"></a>simResumeThreads</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>In conjunction with <a href="#simSetThreadResumeLocation">simSetThreadResumeLocation</a>, simResumeThreads allows specifying when and in which order threads are resumed. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. Once a thread switched to another thread, it will resume execution at the beginning of next simulation pass by default. In order to also have full synchronization control between threads, you can assign a resume location and order to each thread. When simResumeThreads(x) is called, all threads that were assigned a resume location of x will be resumed. See also <a href="#simSetThreadResumeLocation">simSetThreadResumeLocation</a>, <a href="#simSetThreadSwitchTiming">simSetThreadSwitchTiming</a>, <a href="#simSwitchThread">simSwitchThread</a> and <a href="#simSetThreadIsFree">simSetThreadIsFree</a>. This function is not available from the C-API, and can only be called in the <a href="mainScript.htm">main script</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number count=simResumeThreads(number location)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>location</strong>: indicates a location value associated with threads (through the <a href="#simSetThreadResumeLocation">simSetThreadResumeLocation</a> function). Only threads with the same location value will be resumed.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: number of resumed threads, or -1 in case of an error.</div>
<div></div></td> 
</tr> 
</table> 
<br>





<h3><a name="simRMLMoveToJointPositions" id="simRMLMoveToJointPositions"></a>simRMLMoveToJointPositions
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Moves (actuates) several joints at the same time using the <a href="http://www.reflexxes.com">Reflexxes Motion Library type IV</a>. This function   can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is   a blocking operation) and is not available from the C-API.  See also <a href="#simRMLMoveToPosition">simRMLMoveToPosition</a>, and <a href="#simRMLPosition">simRMLPosition</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
-
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table newPos,table newVel,table newAccel,number timeLeft=simRMLMoveToJointPositions(table jointHandles,number flags,table currentVel,table currentAccel,table maxVel,table maxAccel,table maxJerk,table targetPos,table targetVel)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>jointHandles</strong>: handles of the joints to actuate</div>
<div><strong>flags</strong>: <a href="apiConstants.htm#RMLFunctions">RML flags</a>. -1 for default flags.</div>
<div><strong>currentVel</strong>: the current velocity of the joints. Can be nil in which case a velocity vector of 0 is used.</div>
<div><strong>currentAccel</strong>: the current acceleration of the joints. Can be nil in which case an acceleration vector of 0 is used.</div>
<div><strong>maxVel</strong>: the maximum allowed velocity  of the joints</div>
<div><strong>maxAccel</strong>: the maximum allowed acceleration  of the joints</div>
<div><strong>maxJerk</strong>: the maximum allowed jerk  of the joints</div>
<div><strong>targetPos</strong>: the desired target positions of the joints</div>
<div><strong>targetVel</strong>: the desired velocity of the joints at the target. Can be nil in which case a velocity vector of 0 is used.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 if the function call was successful</div>
<div><strong>newPos</strong>: the new positions of the joints</div>
<div><strong>newVel</strong>: the new velocities of the joints</div>
<div><strong>newAccel</strong>: the new accelerations of the joints</div>
<div><strong>timeLeft</strong>: the time left for additional calculations in current simulation time step</div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simRMLMoveToPosition" id="simRMLMoveToPosition"></a>simRMLMoveToPosition
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Moves an object to a given position and/or orientation using the <a href="http://www.reflexxes.com">Reflexxes Motion Library type IV</a>. This function   can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is   a blocking operation) and is not available from the C-API.  See also <a href="#simRMLMoveToJointPositions">simRMLMoveToJointPositions</a>, <a href="#simRMLPosition">simRMLPosition</a>, <a href="#simMoveToObject">simMoveToObject</a> and <a href="#simFollowPath">simFollowPath</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
-
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table_3 newPos,table_4 newQuaternion,table_4 newVel,table_4 newAccel,number timeLeft=simRMLMoveToPosition(number objectHandle,number relativeToObjectHandle,number flags,table_4 currentVel,table_4 currentAccel,table_4 maxVel,table_4 maxAccel,table_4 maxJerk,table_3 targetPosition,table_4 targetQuaternion,table_4 targetVel)

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>objectHandle</strong>: handle of the object to be moved</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the movement data is specified. Specify -1 for a movement relative to the absolute reference   frame, sim_handle_parent for a movement relative to the object's parent   frame, or an object handle relative to whose reference frame the   movement should be performed.</div>
<div><strong>flags</strong>: <a href="apiConstants.htm#RMLFunctions">RML flags</a>. -1 for default flags.</div>
<div><strong>currentVel</strong>: the current velocity of the object (velX, velY, velZ, velAngle). Can be nil in which case a velocity vector of 0 is used.</div>
<div><strong>currentAccel</strong>: the current acceleration of the object (accelX, accelY, accelZ, accelAngle). Can be nil in which case an acceleration vector of 0 is used.</div>
<div><strong>maxVel</strong>: the maximum allowed velocity  of the object (maxVelX, maxVelY, maxVelZ, maxVelAngle)</div>
<div><strong>maxAccel</strong>: the maximum allowed acceleration  of the object (maxAccelX, maxAccelY, maxAccelZ, maxAccelAngle)</div>
<div><strong>maxJerk</strong>: the maximum allowed jerk  of the object (maxJerkX, maxJerkY, maxJerkZ, maxJerkAngle)</div>
<div><strong>targetPosition</strong>: the desired target position of the object (expressed relative to <em>relativeToObjectHandle</em>). Can be nil, in which case the position of the object will stay constant</div>
<div><strong>targetQuaternion</strong>: the desired target orientation of the object (expressed relative to <em>relativeToObjectHandle</em>). Can be nil, in which case the orientation of the object will stay constant</div>
<div><strong>targetVel</strong>: the desired velocity of the object at the target (targetVelX, targetVelY, targetVelZ, targetVelAngle). Can be nil in which case a velocity vector of 0 is used.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 if the function call was successful</div>
<div><strong>newPos</strong>: the new relative position of the object</div>
<div><strong>newQuaternion</strong>: the new relative orientation of the object</div>
<div><strong>newVel</strong>: the new velocity vector (velX, velY, velZ, velAngle)</div>
<div><strong>newAccel</strong>: the new acceleration vector (accelX, accelY, accelZ, accelAngle)</div>
<div><strong>timeLeft</strong>: the time left for additional calculations in current simulation time step</div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simRMLPosition" id="simRMLPosition"></a>simRMLPosition
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxRMLPosition">simxRMLPosition</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosRMLPosition">simRosRMLPosition</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Executes a call to the <a href="http://www.reflexxes.com">Reflexxes Motion Library type IV</a>. The Reflexxes Motion Library type IV provides instantaneous trajectory generation capabilities for motion control systems. This function executes the position-based trajectory generation algorithm (RMLPosition). See also <a href="#simRMLVelocity">simRMLVelocity</a>, <a href="#simRMLMoveToPosition">simRMLMoveToPosition</a> and <a href="#simRMLMoveToJointPositions">simRMLMoveToJointPositions</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRMLPosition(simInt dofs,simDouble timeStep,simInt flags,const simDouble* currentPosVelAccel,const simDouble* maxVelAccelJerk,const simBool* selection,const simDouble* targetPosVel,simDouble* newPosVelAccel,simVoid* auxData)  <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dofs</strong>: the number of degrees of freedom</div>
<div><strong>timeStep</strong>: the cycle time</div>
<div><strong>flags</strong>: <a href="apiConstants.htm#RMLFunctions">RML flags</a>. -1 for default flags.</div>
<div><strong>currentPosVelAccel</strong>: the current position, velocity and acceleration. Arrange values as {pos1,pos2,..,posN,vel1,vel2,..,velN,accel1,accel2,..,accelN}</div>

<div><strong>maxVelAccelJerk</strong>: the maximum allowed velocity, acceleration and jerk. Arrange values as {vel1,vel2,..,velN,accel1,accel2,..,accelN,jerk1,jerk2,..,jerkN}</div>
<div><strong>selection</strong>: the selection vector (one value for each DoF)</div>

<div><strong>targetPosVel</strong>: the  target position and velocity. Arrange values as {pos1,pos2,..,posN,vel1,vel2,..,velN}</div>
<div><strong>newPosVelAccl</strong>: the new position, velocity and acceleration (output values). Values are arranged as {pos1,pos2,..,posN,vel1,vel2,..,velN,accel1,accel2,..,accelN}</div>
<div><strong>auxData</strong>: can be NULL. Otherwise in/out extension data. The first byte indicates how many additional in/out values we wish to set/get. Following  auxiliary values can be set/get:</div>
<div class=tab>value 1 (output): Bytes 2-9 (double):  returns the <strong>synchronization time</strong> (the time needed to reach the desired state. This time includes the cycle time of the current call to simRMLPosition)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-42 if the corresponding plugin could not be found, otherwise the return value of function RMLPosition in the library (0=final state not yet reached, 1=final state reached, otherwise an error code)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table newPosVelAccel,number synchronizationTime=simRMLPosition(number dofs,number timeStep,number flags,table currentPosVelAccel,table maxVelAccelJerk,table selection,table targetPosVel)
<br>
<br>

<div>If you wish to use this function in a blocking mode, consider using <a href="#simRMLMoveToPosition">simRMLMoveToPosition</a> or <a href="#simRMLMoveToJointPositions">simRMLMoveToJointPositions</a> instead.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simRMLVelocity" id="simRMLVelocity"></a>simRMLVelocity
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxRMLVelocity">simxRMLVelocity</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosRMLVelocity">simRosRMLVelocity</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Executes a call to the <a href="http://www.reflexxes.com">Reflexxes Motion Library type IV</a>. The Reflexxes Motion Library type IV provides instantaneous trajectory generation capabilities for motion control systems. This function executes the velocity-based trajectory generation algorithm (RMLVelocity). See also <a href="#simRMLPosition">simRMLPosition</a>.</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRMLVelocity(simInt dofs,simDouble timeStep,simInt flags,const simDouble* currentPosVelAccel,const simDouble* maxAccelJerk,const simBool* selection,const simDouble* targetVel,simDouble* newPosVelAccel,simVoid* auxData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dofs</strong>: the number of degrees of freedom</div>
<div><strong>timeStep</strong>: the cycle time</div>
<div><strong>flags</strong>:  <a href="apiConstants.htm#RMLFunctions">RML flags</a>. -1 for default flags.</div>
<div><strong>currentPosVelAccel</strong>: the current position, velocity and acceleration. Arrange values as {pos1,pos2,..,posN,vel1,vel2,..,velN,accel1,accel2,..,accelN}</div>

<div><strong>maxAccelJerk</strong>: the maximum allowed acceleration and jerk. Arrange values as {accel1,accel2,..,accelN,jerk1,jerk2,..,jerkN}</div>
<div><strong>selection</strong>: the selection vector (one value for each DoF)</div>

<div><strong>targetVel</strong>: the  target velocity (one value for each DoF)</div>
<div><strong>newPosVelAccl</strong>: the new position, velocity and acceleration (output values). Values are arranged as {pos1,pos2,..,posN,vel1,vel2,..,velN,accel1,accel2,..,accelN}</div>
<div><strong>auxData</strong>: can be NULL. Otherwise a pointer to 64 bytes used for various extensions. Currently following positions are used:</div>
<div><strong>auxData</strong>: can be NULL. Otherwise in/out extension data. The first byte indicates how many additional in/out values we wish to set/get. Following  auxiliary values can be set/get:</div>
<div class=tab>value 1 (output): Bytes 2-9 (double):  returns the <strong>synchronization time</strong> (the time needed to reach the desired state. This time includes the cycle time of the current call to simRMLVelocity)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-42 if the corresponding plugin could not be found, otherwise the return value of function RMLVelocity in the library (0=final state not yet reached, 1=final state reached, otherwise an error code)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result,table newPosVelAccel,number synchronizationTime=simRMLVelocity(number dofs,number timeStep,number flags,table currentPosVelAccel,table maxAccelJerk,table selection,table targetVel)
<br>
<br>

<div>If you wish to use this function in a blocking mode (i.e. from a threaded script), refer to the example given for function <a href="#simRMLPosition">simRMLPosition</a>.</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Refer to the C-function documentation</div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simRotateAroundAxis" id="simRotateAroundAxis"></a>simRotateAroundAxis</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Rotates a transformation matrix around a random axis in space. This function, when used in combination with <a href="#simGetRotationAxis">simGetRotationAxis</a>, can be used to build interpolations between transformation matrices. See also <a href="#simGetObjectMatrix">simGetObjectMatrix</a> and <a href="#simSetObjectMatrix">simSetObjectMatrix</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRotateAroundAxis(const simFloat* matrixIn,const simFloat* axis,const simFloat* axisPos,simFloat angle,simFloat* matrixOut)  <br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrixIn</strong>: the transformation matrix to rotate</div>
<div><strong>axis</strong>: the axis vector in absolute coordinates to rotate around</div>
<div><strong>axisPos</strong>: the position of the rotation axis in absolute coordinates</div>
<div><strong>angle</strong>: the amount of rotation to perform</div>
<div><strong>matrixOut</strong>: the returned transformed (rotated) matrix</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table_12 matrixOut=simRotateAroundAxis(table_12 matrixIn,table_3 axis,table_3 axisPos,number angle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>matrixOut</strong>: the transformed (rotated) matrix, or nil in case of an error</div>
</td> 
</tr> 
</table> 
<br>









<h3><a name="simRunSimulator" id="simRunSimulator"></a>simRunSimulator</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Runs the simulator. Should be the first and last command run. This will launch the main simulator loop. See also the section on the <a href="mainClientApplication.htm">main client application</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simRunSimulator(const simChar* applicationName,simInt options,simVoid(*initCallBack)(),simVoid(*loopCallBack)(),simVoid(*deinitCallBack)())<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>applicationName</strong>: name of the application</div>
<div><strong>options</strong>: <a href="apiConstants.htm#startupOptions">start-up options</a> (combine them with the OR operator)</div>
<div><strong>initCallBack</strong>: the call-back address of the initialization routine. The initialization routine will be called just once, and should be used to load plugins for instance. Can be NULL</div>
<div><strong>loopCallBack</strong>: the call-back address of the main simulator loop. That routine is called continuously in a loop, and should react to simulator messages (<a href="#simGetSimulatorMessage">simGetSimulatorMessage</a>), and handle running simulations. Can be NULL</div>
<div><strong>deinitCallBack</strong>: the call-back address of the deinitialization routine. The deinitialization routine will be called just once, before the simulation ends, and should be used to unload plugins for instance. Can be NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if the command was successfull<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simSaveModel" id="simSaveModel"></a>simSaveModel</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Saves a model (an object marked as &quot;Object is model base&quot; and all other objects in its hierarchy tree). Any existing file with same name will be overwritten. See also <a href="#simLoadModel">simLoadModel</a>, <a href="#simSaveUI">simSaveUI</a> and <a href="#simSaveScene">simSaveScene</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSaveModel(int baseOfModelHandle,const simChar* filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>baseOfModelHandle</strong>: handle of an object marked as &quot;Object is model base&quot;</div>
<div><strong>filename</strong>: model filename. The filename extension is required (&quot;ttm&quot;)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSaveModel(number baseOfModelHandle,string filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSaveScene" id="simSaveScene"></a>simSaveScene</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Saves a scene. Any existing file with same name will be overwritten. See also <a href="#simLoadScene">simLoadScene</a>, <a href="#simCloseScene">simCloseScene</a>, <a href="#simSaveModel">simSaveModel</a> and <a href="#simSaveUI">simSaveUI</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSaveScene(const simChar* filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>filename</strong>: scene filename. The filename extension is required (&quot;ttt&quot;)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSaveScene(string filename)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>





<h3><a name="simSaveUI" id="simSaveUI"></a>simSaveUI</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Saves one or several custom user interfaces into a UI file (*.ttb-file). Any existing file with same name will be overwritten. See also <a href="#simLoadUI">simLoadUI</a>, <a href="#simSaveModel">simSaveModel</a> and <a href="#simSaveScene">simSaveScene</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSaveUI(int count,const int* uiHandles,const simChar* filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>count</strong>: the number of UIs to save. Can be 0, in which case all UIs in the scene will be saved</div>
<div><strong>uiHandles</strong>: a pointer to UI handles to save. Can be NULL if <strong>count</strong> is 0</div>
<div><strong>filename</strong>: UI filename. The filename extension is required (&quot;ttb&quot;)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSaveUI(table uiHandles,string filename)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>







<h3><a name="simScaleSelectedObjects" id="simScaleSelectedObjects"></a>simScaleSelectedObjects</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Scales (in dimensions) all selected objects. All related values are automatically scaled appropriately (e.g. masses, forces, etc.)
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simScaleSelectedObjects(simFloat scalingFactor,simBool scalePositionsToo)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scalingFactor</strong>: the scaling factor</div>
<div><strong>scalePositionsToo</strong>: if true, selected object's positions will also be scaled</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simScaleSelectedObjects(number scalingFactor,boolean scalePositionsToo)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSearchPath" id="simSearchPath"></a>simSearchPath</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Searches for a path. A registered path planning object is required (path planning objects can be registered in the scene editor). When called from C or from a non-threaded script, then this function will be blocking. When called from a threaded child script, this function is still blocking, but will switch to other threads at the specified time interval (subTimeStep). See also <a href="#simGetPathPlanningHandle">simGetPathPlanningHandle</a>, <a href="#simInitializePathSearch">simInitializePathSearch</a> and <a href="#simPerformPathSearchStep">simPerformPathSearchStep</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSearchPath(simInt pathPlanningObjectHandle,simFloat maxSearchTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>pathPlanningObjectHandle</strong>: handle of the path planning object</div>
<div><strong>maxSearchTime</strong>: maximum search time in seconds</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful (error), 0 if no path was found, 1 if a partial path was found or 2 if a full path was found (check the path planning task settings dialog)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSearchPath(number pathPlanningObjectHandle,number maxSearchTime,subTimeStep)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>pathPlanningObjectHandle</strong>: handle of the path planning object</div>
<div><strong>maxSearchTime</strong>: maximum search time in seconds</div>
<div><strong>subTimeStep</strong>: the delay after which the thread will switch to other threads (meaningful only for threaded child scripts). Can be nil or ignored, in which case a default value of 0.05 is used.<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-1 if operation was not successful (error), 0 if no path was found, 1 if a partial path was found or 2 if a full path was found (check the path planning task settings dialog)<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSendData" id="simSendData"></a>simSendData</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sends (or broadcasts) wireless data (in a simulation). See also <a href="#simReceiveData">simReceiveData</a> and <a href="#simTubeOpen">simTubeOpen</a>. Cannot be called from <a href="addOns.htm">add-ons</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSendData(simInt targetID,simInt dataHeader,const simChar* dataName,const simChar* data,simInt dataLength,simInt antennaHandle,simFloat actionRadius,simFloat emissionAngle1,simFloat emissionAngle2,simFloat persistence)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>targetID</strong>: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a script<br>
</div>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the &quot;Help&quot; menu, in the &quot;About&quot; item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.<br>
</div>
<div><strong>dataName</strong>: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see <a href="#simReceiveData">simReceiveData</a>)<br>
</div>
<div><strong>data</strong>: data to transmit</div>
<div><strong>dataLength</strong>: length of the data to transmit</div>
<div><strong>antennaHandle</strong>: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frame<br>
</div>
<div><strong>actionRadius</strong>: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the data<br>
</div>
<div><strong>emissionAngle1</strong>: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.<br>
</div>
<div><strong>emissionAngle2</strong>: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.<br>
</div>
<div><strong>persistence</strong>: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSendData(number targetID,number dataHeader,string dataName,string data,number antennaHandle=sim_handle_self,number actionRadius=100,number emissionAngle1=3.1415,number emissionAngle2=6.283,number persistence=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>targetID</strong>: indicates what receivers will receive the message. Can be sim_handle_all, sim_handle_tree, sim_handle_chain, or the handle of a script. If sim_handle_tree is specified, then only child scripts built on top of current script's hierarchy will be able to receive the message. If sim_handle_chain is specified, then only child scripts parented with current script (or the main script) will be able to receive the message<br>
</div>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the &quot;Help&quot; menu, in the &quot;About&quot; item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.<br>
</div>
<div><strong>dataName</strong>: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see <a href="#simReceiveData">simReceiveData</a>)<br>
</div>
<div><strong>data</strong>: data to transmit (each character can have values between 0 and 255). See also <a href="#simPackInts">simPackInts</a> and <a href="#simPackFloats">simPackFloats</a> if you wish to pack numbers into data.<br>
</div>
<div><strong>antennaHandle</strong>: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frame, or sim_handle_self to use the object associated with the child script as antenna. Can be omitted (in that case, sim_handle_self is used)<br>
</div>
<div><strong>actionRadius</strong>: same as C-function. Can be omitted (in that case 100 is used)</div>
<div><strong>emissionAngle1</strong>: same as C-function. Can be omitted (in that case, pi is used)</div>
<div><strong>emissionAngle2</strong>: same as C-function. Can be omitted (in that case, 2pi is used)</div>
<div><strong>persistence</strong>: same as C-function. Can be omitted (in that case, 0.0 is used)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSendModuleMessage" id="simSendModuleMessage"></a>simSendModuleMessage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sends a message to plugins. This function should normally only be used from the <a href="mainClientApplication.htm">main client application</a> side. See also <a href="#simLoadModule">simLoadModule</a> and <a href="#simBroadcastMessage">simBroadcastMessage</a>.
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simVoid* simSendModuleMessage(simInt message,simInt* auxiliaryData,simVoid* customData,simInt* replyData)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>message</strong>: the message to send. Refer to <a href="apiConstants.htm#simulatorMessages">sim_message_eventcallback_</a>-type messages.<br>
</div>
<div><strong>auxiliaryData</strong>: pointer to 4 integers. auxiliaryData[0] should be a unique identifier different from 0. Use the same identifier as the header you would use in the <a href="#simAddSceneCustomData">simAddSceneCustomData</a> or <a href="#simAddObjectCustomData">simAddObjectCustomData</a> function (i.e. your v-rep's serial number) if the message is yours. Otherwise, use the identifier of some other module. auxiliaryData[1] could be the messageID of the message you wish to send to another module. auxiliaryData[2] and auxiliaryData[3] can be any values specific to your application.<br>
</div>
<div><strong>customData</strong>: customData of your application (the broadcaster is in charge to release that buffer). Can be NULL.<br>
</div>
<div><strong>replyData</strong>: pointer to 4 integers that can be used by a module to reply to a broadcasted message. Can be NULL. If not NULL, all 4 values are automatically initialized to -1.<br>
</div>
<br>
<div>Broadcasted messages can be intercepted in a plugin's "v_repMessage"-function.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to custom reply data that can be used by a module to reply to a broadcasted message. The module that replies is in charge of allocating the data with <a href="#simCreateBuffer">simCreateBuffer</a> and the original broadcaster is in charge of releasing that data with <a href="#simReleaseBuffer">simReleaseBuffer</a>. A reply to a broadcasted message is triggered by a module that writes a value different from -1 into auxiliaryData[0]-auxiliaryData[3], thus aborting further broadcast of the original message and returning to the broadcaster. If the return value is different from NULL, the broadcast is also interrupted.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simSerialCheck" id="simSerialCheck"></a>simSerialCheck</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Reads how many bytes are waiting to be read on a serial port (RS-232). See also <a href="#simSerialRead">simSerialRead</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialCheck(simInt portHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the number of bytes that are waiting to be read<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSerialCheck(number portHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSerialClose" id="simSerialClose"></a>simSerialClose</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Closes a serial port (RS-232). See also <a href="#simSerialOpen">simSerialOpen</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialClose(simInt portHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSerialClose(number portHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSerialOpen" id="simSerialOpen"></a>simSerialOpen</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a serial port (RS-232) for communication. When called from a script, the function can only be called when the simulation is running (and in that case the port is automatically closed at simulation stop). See also <a href="#simSerialClose">simSerialClose</a>, <a href="#simSerialSend">simSerialSend</a>, <a href="#simSerialCheck">simSerialCheck</a> and <a href="#simSerialRead">simSerialRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialOpen(simChar* portString,simInt baudRate,simVoid* reserved1,simVoid* reserved2)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portString</strong>: a string specifying the port to open. Under Windows, use something similar to &quot;\\.\COM1&quot;. Under MacOS and Linux, use something similar to &quot;/dev/*&quot; (check the &quot;/dev&quot; folder to know what file to specify). Under Linux, you might have to launch V-REP with super user priviledges in order to access the serial port.</div>
<div><strong>baudRate</strong>: the baudrate</div>
<div><strong>reserved1</strong>: reserved for future extension. Keep at NULL.</div>
<div><strong>reserved2</strong>: reserved for future extension. Keep at NULL.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise a port handle<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSerialOpen(string portString,number baudRate)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSerialRead" id="simSerialRead"></a>simSerialRead</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Reads from a previously opened serial port (RS-232). The C version of the function cannot be blocking. See also <a href="#simSerialCheck">simSerialCheck</a> and <a href="#simSerialSend">simSerialSend</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialRead(simInt portHandle,simChar* buffer,simInt dataLengthToRead)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div><strong>buffer</strong>: a buffer that will be filled with read data<br>
</div>
<div><strong>dataLengthToRead</strong>: the maximum data length that should be read<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the effective data length that was read<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=simSerialRead(number portHandle,number dataLengthToRead,Boolean blockingOperation,string closingString='',number timeout=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div><strong>dataLengthToRead</strong>: the maximum data length that should be read</div>
<div><strong>blockingOperation</strong>: if true and the calling script is running in a thread, then the function only returns when the desired data length was read (or if the closingString was met, or if there was a timeout (see next arguments)<br>
</div>
<div><strong>closingString</strong>: a string (containing any byte value) can be specified, that will break from the blocking operation if a match was found in the incoming data. Useful when you know that a data packet is always ended with a given signature<br>
</div>
<div><strong>timeout</strong>: duration after which the blocking operation will be aborted</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: a string containing read data (excluding the closingString if it was specified and found)</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSerialSend" id="simSerialSend"></a>simSerialSend</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Writes data to a previously opened serial port (RS-232). See also <a href="#simSerialRead">simSerialRead</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSerialSend(simInt portHandle,const simChar* data,simInt dataLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>portHandle</strong>: the handle returned by the <a href="#simSerialOpen">simSerialOpen</a> function</div>
<div><strong>data</strong>: a pointer to the data that should be sent</div>
<div><strong>dataLength</strong>: length of the data to be sent</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the effective data length that was written</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number charsSent=simSerialSend(number portHandle,string data)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetArrayParameter" id="simSetArrayParameter"></a>simSetArrayParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetArrayParameter">simxSetArrayParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetArrayParameter">simRosSetArrayParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets 3 values of an <a href="apiConstants.htm#arrayParameters">array parameter</a>. See also <a href="#simGetArrayParameter">simGetArrayParameter</a>, <a href="#simSetBooleanParameter">simSetBooleanParameter</a>, <a href="#simSetIntegerParameter">simSetIntegerParameter</a> and <a href="#simSetFloatingParameter">simSetFloatingParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetArrayParameter(simInt parameter,const simVoid* parameterValues)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#arrayParameters">array parameter identifier</a></div>
<div><strong>parameterValues</strong>: array of 3 simFloat values related to the parameter (simVoid is kept for backward compatibility).</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetArrayParameter(number parameter,table parameterValues)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetBooleanParameter" id="simSetBooleanParameter"></a>simSetBooleanParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetBooleanParameter">simxSetBooleanParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetBooleanParameter">simRosSetBooleanParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a <a href="apiConstants.htm#booleanParameters">boolean parameter</a>. See also <a href="#simGetBooleanParameter">simGetBooleanParameter</a>, <a href="#simSetIntegerParameter">simSetIntegerParameter</a>, <a href="#simSetArrayParameter">simSetArrayParameter</a> and <a href="#simSetFloatingParameter">simSetFloatingParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetBooleanParameter(simInt parameter,simBool boolState)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#booleanParameters">Boolean parameter identifier</a></div>
<div><strong>boolState</strong>: new boolean state for the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetBooleanParameter(number parameter,boolean boolState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetCollectionName" id="simSetCollectionName"></a>simSetCollectionName</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the name of a collection based on its handle. See also <a href="#simGetCollectionName">simGetCollectionName</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetCollectionName(simInt collectionHandle,const simChar* collectionName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>collectionHandle</strong>: handle of the collection</div>
<div><strong>collectionName</strong>: new name of the collection</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetCollectionName(number collectionHandle,string collectionName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetConfigurationTree" id="simSetConfigurationTree"></a>simSetConfigurationTree</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Restores configuration information previously retrieved with <a href="#simGetConfigurationTree">simGetConfigurationTree</a> (object relative positions/orientations, joint/path values). Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">simResetDynamicObject</a> just before)<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetConfigurationTree(const simChar* data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>data</strong>: data returned by a previous call to <a href="#simGetConfigurationTree">simGetConfigurationTree</a></div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetConfigurationTree(number rawBufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>rawBufferHandle</strong>: handle to a block of memory previously returned by <a href="#simGetConfigurationTree">simGetConfigurationTree</a>. If not needed anymore, you can release the raw buffer with the <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a> (all raw buffers are however automatically released at the end of a simulation)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>











<h3><a name="simSetExplicitHandling" id="simSetExplicitHandling"></a>simSetExplicitHandling</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the explicit handling flags for a general object. See also <a href="#simGetExplicitHandling">simGetExplicitHandling</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetExplicitHandling(simInt generalObjectHandle,int explicitFlags)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>generalObjectHandle</strong>: handle of a general object (can be a scene object, a collision object, a distance object, etc.)<br>
</div>
<div><strong>explicitFlags</strong>: the explicit handling flags. For now only bit 0 is used<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetExplicitHandling(number generalObjectHandle,number explicitFlags)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetFloatingParameter" id="simSetFloatingParameter"></a>simSetFloatingParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetFloatingParameter">simxSetFloatingParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetFloatingParameter">simRosSetFloatingParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a <a href="apiConstants.htm#floatingParameters">floating point parameter</a>. See also <a href="#simGetFloatingParameter">simGetFloatingParameter</a>, <a href="#simSetBooleanParameter">simSetBooleanParameter</a>, <a href="#simSetArrayParameter">simSetArrayParameter</a> and <a href="#simSetIntegerParameter">simSetIntegerParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetFloatingParameter(simInt parameter,simFloat floatState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#floatingParameters">floating parameter identifier</a></div>
<div><strong>floatState</strong>: new state for the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetFloatingParameter(number parameter,number floatState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetFloatSignal" id="simSetFloatSignal"></a>simSetFloatSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetFloatSignal">simxSetFloatSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetFloatSignal">simRosSetFloatSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the value of a float signal. If that signal is not yet present, it is added. Signals created in the <a href="mainScript.htm">main script</a> or in a <a href="childScripts.htm">child script</a> are automatically cleared at simulation end. See also <a href="#simGetFloatSignal">simGetFloatSignal</a>, <a href="#simClearFloatSignal">simClearFloatSignal</a>, <a href="#simSetIntegerSignal">simSetIntegerSignal</a>, <a href="#simSetStringSignal">simSetStringSignal</a>, <a href="#simWaitForSignal">simWaitForSignal</a> and <a href="#simPersistentDataWrite">simPersistentDataWrite</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetFloatSignal(const simChar* signalName,simFloat signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetFloatSignal(string signalName,number signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetGraphUserData" id="simSetGraphUserData"></a>simSetGraphUserData</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets one value in a user-defined graph data stream. See also <a href="#simResetGraph">simResetGraph</a> and <a href="#simHandleGraph">simHandleGraph</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetGraphUserData(simInt graphHandle,const simChar* dataStreamName,simFloat data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>graphHandle</strong>: handle of the graph object</div>
<div><strong>dataStreamName</strong>: the name of the data stream. The data stream must be of type &quot;user-defined&quot;</div>
<div><strong>data</strong>: the value to set. If, for a given simulation step this function is not called for a user-defined data stream, then the data will be missing for that simulation step.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetGraphUserData(number graphHandle,string dataStreamName,number data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>





<h3><a name="simSetIkElementProperties" id="simSetIkElementProperties"></a>simSetIkElementProperties</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets properties of a specific inverse kinematics element (IK element). See also <a href="#simSetIkGroupProperties">simSetIkGroupProperties</a> and <a href="#simGetIkGroupHandle">simGetIkGroupHandle</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetIkElementProperties(simInt ikGroupHandle,simInt tipDummyHandle,simInt constraints,const simFloat* precision,const simFloat* weight,void* reserved)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of the IK group that contains the IK element to modify</div>
<div><strong>tipDummyHandle</strong>: handle of the tip dummy object of the IK element</div>
<div><strong>constraints</strong>: the <a href="apiConstants.htm#ikConstraints">constraints</a> of the ik element. sim_ik_avoidance_constraint is not allowed</div>
<div><strong>precision</strong>: an array of two values where the first represents the linear precision, and the second the angular precision. Can be NULL to keep current settings.</div>
<div><strong>weight</strong>: an array of two values that represent the linear and angular resolution weights. Can be NULL to keep current settings.</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>




<h3><a name="simSetIkGroupProperties" id="simSetIkGroupProperties"></a>simSetIkGroupProperties</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets properties of an inverse kinematics group (IK group). See also <a href="#simSetIkElementProperties">simSetIkElementProperties</a> and <a href="#simGetIkGroupHandle">simGetIkGroupHandle</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetIkGroupProperties(simInt ikGroupHandle,simInt resolutionMethod,simInt maxIterations,simFloat damping,void* reserved)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>ikGroupHandle</strong>: handle of the IK group </div>
<div><strong>resolutionMethod</strong>: the <a href="apiConstants.htm#ikCalculationMethods">IK resolution method</a></div>
<div><strong>maxIterations</strong>: the maximum number of iteractions for the calculations</div>
<div><strong>damping</strong>: the DLS damping factor.</div>
<div><strong>reserved</strong>: reserved for future extensions. Keep at NULL</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetIkGroupProperties(number ikGroupHandle,number resolutionMethod,number maxIterations,number damping)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetIntegerParameter" id="simSetIntegerParameter"></a>simSetIntegerParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetIntegerParameter">simxSetIntegerParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetIntegerParameter">simRosSetIntegerParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets an <a href="apiConstants.htm#integerParameters">integer parameter</a>. See also <a href="#simGetIntegerParameter">simGetIntegerParameter</a>, <a href="#simSetBooleanParameter">simSetBooleanParameter</a>, <a href="#simSetArrayParameter">simSetArrayParameter</a> and <a href="#simSetFloatingParameter">simSetFloatingParameter</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetIntegerParameter(simInt parameter,simInt intState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>parameter</strong>: <a href="apiConstants.htm#integerParameters">integer parameter identifier</a></div>
<div><strong>intState</strong>: new state for the parameter</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetIntegerParameter(number parameter,number intState)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetIntegerSignal" id="simSetIntegerSignal"></a>simSetIntegerSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetIntegerSignal">simxSetIntegerSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetIntegerSignal">simRosSetIntegerSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the value of an integer signal. If that signal is not yet present, it is added. Signals created in the <a href="mainScript.htm">main script</a> or in a <a href="childScripts.htm">child script</a> are automatically cleared at simulation end. See also <a href="#simGetIntegerSignal">simGetIntegerSignal</a>, <a href="#simClearIntegerSignal">simClearIntegerSignal</a>, <a href="#simSetFloatSignal">simSetFloatSignal</a>, <a href="#simSetStringSignal">simSetStringSignal</a>,  <a href="#simWaitForSignal">simWaitForSignal</a> and <a href="#simPersistentDataWrite">simPersistentDataWrite</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetIntegerSignal(const simChar* signalName,simInt signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetIntegerSignal(string signalName,number signalValue)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetJointForce" id="simSetJointForce"></a>simSetJointForce
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetJointForce">simxSetJointForce</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetJointForce">simRosSetJointForce</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the maximum force or torque that a joint can exert. This function has no effect when the joint is not dynamically enabled, or when it is a spherical joint. See also <a href="#simJointGetForce">simJointGetForce</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointForce(simInt objectHandle,simFloat forceOrTorque)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>forceOrTorque</strong>: the maximum force or torque that the joint can exert</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetJointForce(number objectHandle,number forceOrTorque)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetJointInterval" id="simSetJointInterval"></a>simSetJointInterval</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the interval parameters of a joint (i.e. range values). The attributes or interval parameters might have no effect, depending on the joint-type. See also <a href="#simGetJointInterval">simGetJointInterval</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointInterval(simInt objectHandle,simBool cyclic,const simFloat* interval)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>cyclic</strong>: indicates whether the joint is cyclic. Only revolute joints with a pitch of 0 can be cyclic<br>
</div>
<div><strong>interval</strong>: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (i.e. the maximum allowed value is interval[0]+interval[1])<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetJointInterval(number objectHandle,boolean cyclic,table_2 interval)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetJointMode" id="simSetJointMode"></a>simSetJointMode</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the operation mode of a joint. Might have as side-effect the change of additional properties of the joint.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointMode(simInt jointHandle,simInt jointMode,simInt options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>jointHandle</strong>: handle of the joint object</div>
<div><strong>jointMode</strong>: a <a href="apiConstants.htm#jointModes">joint mode</a> value</div>
<div><strong>options</strong>: bit-coded. For now only bit 0 is used (if set, the joint operates in hybrid mode)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetJointMode(number jointHandle,number jointMode,number options)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetJointPosition" id="simSetJointPosition"></a>simSetJointPosition
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetJointPosition">simxSetJointPosition</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetJointPosition">simRosSetJointPosition</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic position of a joint. May have no effect depending on the joint mode. This function cannot be used with spherical joints (use <a href="#simSetSphericalJointMatrix">simSetSphericalJointMatrix</a> instead). See also <a href="#simGetJointPosition">simGetJointPosition</a> and <a href="#simSetJointTargetPosition">simSetJointTargetPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointPosition(simInt objectHandle,simFloat position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>position</strong>: position of the joint (angular or linear value depending on the joint type)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetJointPosition(number objectHandle,number position)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetJointTargetPosition" id="simSetJointTargetPosition"></a>simSetJointTargetPosition
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetJointTargetPosition">simxSetJointTargetPosition</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetJointTargetPosition">simRosSetJointTargetPosition</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the target position of a joint if the joint is in torque/force mode (also make sure that the joint's motor and position control are enabled). See also <a href="#simSetJointPosition">simSetJointPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointTargetPosition(simInt objectHandle,simFloat targetPosition)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>targetPosition</strong>: target position of the joint (angular or linear value depending on the joint type)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetJointTargetPosition(number objectHandle,number targetPosition)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetJointTargetVelocity" id="simSetJointTargetVelocity"></a>simSetJointTargetVelocity
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetJointTargetVelocity">simxSetJointTargetVelocity</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetJointTargetVelocity">simRosSetJointTargetVelocity</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic target velocity of a non-spherical joint. This command makes only sense when the joint mode is: (a) motion mode: the joint's motion handling feature must be enabled (<a href="#simHandleJoint">simHandleJoint</a> must be called (is called by default in the main script), and the joint motion properties must be set in the joint settings dialog), (b) torque/force mode: the dynamics functionality and the joint motor have to be enabled (position control should however be disabled)<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetJointTargetVelocity(simInt objectHandle,simFloat targetVelocity)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>targetVelocity</strong>: target velocity of the joint (linear or angular velocity depending on the joint-type). </div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetJointTargetVelocity(number objectHandle,number targetVelocity)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetLastError" id="simSetLastError"></a>simSetLastError</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a custom error message. This function is useful for plugins which wish to generate custom error messages. Errors are set and memorized on a thread-basis (e.g. threads originating from threaded scripts have each an individual error handler). See also <a href="#simGetLastError">simGetLastError</a>, the sim_intparam_error_report_mode and the <a href="apiConstants.htm#errorReportModes">error report modes</a>.This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetLastError(const simChar* funcName,const simChar* errorMessage)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>funcName</strong>: name of the function where the error originated</div>
<div><strong>errorMessage</strong>: error message</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetLightParameters" id="simSetLightParameters"></a>simSetLightParameters</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets various parameters of a light object. See also <a href="#simGetLightParameters">simGetLightParameters</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetLightParameters(simInt objectHandle,simInt state,const simFloat* ambientPart,const simFloat* diffusePart,const simFloat* specularPart)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the light</div>
<div><strong>state</strong>: bit-coded. for now, only bit 0 is used: 1=light on</div>
<div><strong>ambientPart</strong>: red, green and blue component of the light's ambient part. Can be NULL</div>
<div><strong>diffusePart</strong>: red, green and blue component of the light's diffuse part. Can be NULL</div>
<div><strong>specularPart</strong>: red, green and blue component of the light's specular part. Can be NULL</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetLightParameters(number objectHandle,number state,table_3 ambientPart,table_3 diffusePart,table_3 specularPart)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetLinkDummy" id="simSetLinkDummy"></a>simSetLinkDummy</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Defines (or breaks) a dummy-dummy link pair. Useful to create dynamic loop closure constraints on the fly (among others). See also <a href="#simGetLinkDummy">simGetLinkDummy</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetLinkDummy(simInt dummyHandle,simInt linkedDummyHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dummyHandle</strong>: handle of the first dummy in the dummy-dummy link pair.</div>
<div><strong>linkedDummyHandle</strong>: handle of the second dummy in the dummy-dummy link pair. Set to -1 to unlink the first dummy.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simGetLinkDummy(number dummyHandle,number linkedDummyHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetModelProperty" id="simSetModelProperty"></a>simSetModelProperty
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetModelProperty">simxSetModelProperty</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetModelProperty">simRosSetModelProperty</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the properties of a model. See also <a href="#simGetModelProperty">simGetModelProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetModelProperty(simInt objectHandle,simInt prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that serves as the model base</div>
<div><strong>prop</strong>: model property. See the <a href="apiConstants.htm#modelProperties">model property values</a>. Combine them with the &quot;or&quot;-operator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetModelProperty(number objectHandle,number prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetModuleMenuItemState" id="simSetModuleMenuItemState"></a>simSetModuleMenuItemState</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Updates the state of a menu item added with the <a href="#simAddModuleMenuEntry">simAddModuleMenuEntry</a> command. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetModuleMenuItemState(simInt itemHandle,simInt state,const simChar* label)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>itemHandle</strong>: handle of the item as returned by the <a href="#simAddModuleMenuEntry">simAddModuleMenuEntry</a> function</div>
<div><strong>state</strong>: state of the item. Bit 0 indicates the enabled state, bit 1 indicates the checked state</div>
<div><strong>label</strong>: label of the item. Can be NULL in which case the label is kept unchanged. If label is &quot;&quot;, the item becomes a separator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetNameSuffix" id="simSetNameSuffix"></a>simSetNameSuffix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
<div>Sets the name suffix adjustment number (for detailed information on this, read also the section on <a href="accessingGeneralObjects.htm">accessing general-type objects</a>). In V-REP, all objects are identified by a name and a handle. When an object (scene object or general-type object) is copied at the same time as a child script, the newly created object's name will become &quot;oldName#0&quot;, should the same object be pasted another time, the next name will be &quot;oldName#1&quot;, etc. <br>
</div>
<br> 
<div>From within a child script, retrieving object handles is performed by automatically appending a name suffix to the object name (each script gets initialized with the name suffix number of the object it is attached to). This allows to copy-paste objects and scripts without having to manually adjust the scripts (the scripts will automatically know which object they have to access based on the set name suffix). From within a script, most of the time you won't need to set the name suffix, but in some special cases you might want to temporarily disable it (e.g. &quot;myChildScript#42&quot; (which has its name suffix automatically set to 42) copied itself together with its attached robot (&quot;myRobot#42&quot;) and now from within &quot;myChildScript#42&quot; you want to shift &quot;myRobot#43&quot; to avoid collision. In that case set the name suffix to 43, shift &quot;myRobot&quot; (retrieve its handle with <a href="#simGetObjectHandle">simGetObjectHandle</a>(&quot;myRobot&quot;) then set the suffix back to 42). From within a script, the <a href="#simSetNameSuffix">simSetNameSuffix</a> command is influencing only current script.<br>
</div>
<br> 
<div>When accessing the API from outside of a script however, the name adjustment mechanism needs to be adjusted manually (make sure you reset the name suffix to its initial state after you are done retrieving handles). Imagine you have one robot in your scene that is named &quot;robot&quot;. You can access the robot from a C/C++ application with <a href="#simGetObjectHandle">simGetObjectHandle</a>(&quot;robot&quot;). If the robot is duplicated, the second robot's name will be &quot;robot#0&quot;, the third will be &quot;robot#1&quot;, etc. From within you C/C++ application you can now access all robots with the same code, you just need to adjust the name suffix number. E.g. <a href="#simSetNameSuffix">simSetNameSuffix</a>(42), then <a href="#simGetObjectHandle">simGetObjectHandle</a>(&quot;robot&quot;) will retrieve the handle of &quot;robot#42&quot;. Once you are done accessing objects, reset the name suffix number to -1 (<a href="#simSetNameSuffix">simSetNameSuffix</a>(-1)).<br>
</div>
<br> 
<div>Setting the name suffix to -1 disables the name adjustment mechanism (default when accessing the API from outside of a script)<br>
</div>
<br> 
<div>See also the <a href="#simGetNameSuffix">simGetNameSuffix</a> function.<br>
</div>
</td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetNameSuffix(simInt nameSuffixNumber)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>nameSuffixNumber</strong>: a number starting from -1 (-1 is for no suffix, 0 is for the 0 suffix, etc.)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result simSetNameSuffix(number nameSuffixNumber)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetNavigationMode" id="simSetNavigationMode"></a>simSetNavigationMode</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the navigation and selection mode for the mouse. See also <a href="#simGetNavigationMode">simGetNavigationMode</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetNavigationMode(simInt navigationMode)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>navigationMode</strong>: <a href="apiConstants.htm#navigationModes">mouse navigation mode</a></div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetNavigationMode(number navigationMode)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectConfiguration" id="simSetObjectConfiguration"></a>simSetObjectConfiguration</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets configuration information for an object (object relative position/orientation, joint/path value). Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">simResetDynamicObject</a> just before). See also <a href="#simGetObjectConfiguration">simGetObjectConfiguration</a> and <a href="#simSetConfigurationTree">simSetConfigurationTree</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectConfiguration(const simChar* data)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>data</strong>: data returned by a previous call to <a href="#simGetObjectConfiguration">simGetObjectConfiguration</a><br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectConfiguration(number rawBufferHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>rawBufferHandle</strong>: handle to a raw data buffer (value returned by a previous call to <a href="#simGetObjectConfiguration">simGetObjectConfiguration</a>). If not needed anymore, you can release the raw buffer with the <a href="#simReleaseScriptRawBuffer">simReleaseScriptRawBuffer</a> (all raw buffers are however automatically released at the end of a simulation)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectFloatParameter" id="simSetObjectFloatParameter"></a>simSetObjectFloatParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetObjectFloatParameter">simxSetObjectFloatParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetObjectFloatParameter">simRosSetObjectFloatParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Set a floating-point parameter of a object. See also <a href="#simGetObjectFloatParameter">simGetObjectFloatParameter</a>, <a href="#simSetObjectIntParameter">simSetObjectIntParameter</a> and <a href="#simSetObjectStringParameter">simSetObjectStringParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectFloatParameter(simInt objectHandle,simInt parameterID,simFloat parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a><br>
</div>
<div><strong>parameter</strong>: parameter value</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectFloatParameter(number objectHandle,number parameterID,number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectIntParameter" id="simSetObjectIntParameter"></a>simSetObjectIntParameter
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetObjectIntParameter">simxSetObjectIntParameter</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetObjectIntParameter">simRosSetObjectIntParameter</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Set an integer parameter of a object. See also <a href="#simGetObjectIntParameter">simGetObjectIntParameter</a>, <a href="#simSetObjectFloatParameter">simSetObjectFloatParameter</a> and <a href="#simSetObjectStringParameter">simSetObjectStringParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectIntParameter(simInt objectHandle,simInt parameterID,simInt parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a></div>
<div><strong>parameter</strong>: parameter value</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectIntParameter(number objectHandle,number parameterID,number parameter)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectMatrix" id="simSetObjectMatrix"></a>simSetObjectMatrix</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the transformation matrix of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">simResetDynamicObject</a> just before). See also <a href="#simGetObjectMatrix">simGetObjectMatrix</a>, <a href="#simSetObjectPosition">simSetObjectPosition</a> and <a href="#simSetObjectOrientation">simSetObjectOrientation</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectMatrix(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.<br>
</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The translation component is (matrix[3],matrix[7],matrix[11])</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectMatrix(number objectHandle,number relativeToObjectHandle,table_12 matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectName" id="simSetObjectName"></a>simSetObjectName</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the name of an object based on its handle. See also <a href="#simGetObjectName">simGetObjectName</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectName(simInt objectHandle,const simChar* objectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>objectName</strong>: name of the object</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectName(number objectHandle,string objectName)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectOrientation" id="simSetObjectOrientation"></a>simSetObjectOrientation
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetObjectOrientation">simxSetObjectOrientation</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetObjectQuaternion">simRosSetObjectQuaternion</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the orientation (Euler angles) of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">simResetDynamicObject</a> just before). See also <a href="#simSetObjectQuaternion">simSetObjectQuaternion</a>, <a href="#simGetObjectOrientation">simGetObjectOrientation</a>, <a href="#simSetObjectPosition">simSetObjectPosition</a> and <a href="#simSetObjectMatrix">simSetObjectMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectOrientation(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* eulerAngles)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.<br>
</div>
<div><strong>eulerAngles</strong>: Euler angles (alpha, beta and gamma)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectOrientation(number objectHandle,number relativeToObjectHandle,table_3 eulerAngles)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectParent" id="simSetObjectParent"></a>simSetObjectParent
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetObjectParent">simxSetObjectParent</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetObjectParent">simRosSetObjectParent</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets an object's parent object. See also <a href="#simGetObjectParent">simGetObjectParent</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectParent(simInt objectHandle,simInt parentObjectHandle,simBool keepInPlace)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object that will become child of the parent object</div>
<div><strong>parentObjectHandle</strong>: handle of the object that will become parent, or -1 if the object should become parentless.</div>
<div><strong>keepInPlace</strong>: indicates whether the object's absolute position and orientation should stay same</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectParent(number objectHandle,number parentObjectHandle,boolean keepInPlace)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectPosition" id="simSetObjectPosition"></a>simSetObjectPosition
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetObjectPosition">simxSetObjectPosition</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetObjectPosition">simRosSetObjectPosition</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the position (x, y and z-coordinates) of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">simResetDynamicObject</a> just before). See also <a href="#simGetObjectPosition">simGetObjectPosition</a>, <a href="#simSetObjectOrientation">simSetObjectOrientation</a> and <a href="#simSetObjectMatrix">simSetObjectMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectPosition(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the position is specified. Specify -1 to set the absolute position, sim_handle_parent to set the position relative to the object's parent, or an object handle relative to whose reference frame the position is specified.<br>
</div>
<div><strong>position</strong>: coordinates of the object (x, y and z)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectPosition(number objectHandle,number relativeToObjectHandle,table_3 position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectProperty" id="simSetObjectProperty"></a>simSetObjectProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the properties of a scene object. See also <a href="#simGetObjectProperty">simGetObjectProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectProperty(simInt objectHandle,simInt prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: object handle</div>
<div><strong>prop</strong>: object property. See the <a href="apiConstants.htm#sceneObjectProperties">object property values</a>. Combine them with the &quot;or&quot;-operator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectProperty(number objectHandle,number prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectQuaternion" id="simSetObjectQuaternion"></a>simSetObjectQuaternion (ROS API equivalent: <a href="rosServices.htm#simRosSetObjectQuaternion">simRosSetObjectQuaternion</a>)</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the quaternion (x,y,z,w) of an object. Be very careful to set only valid value (i.e. normalized), otherwise you will experience strange effects. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  <a href="#simResetDynamicObject">simResetDynamicObject</a> just before). See also <a href="#simSetObjectOrientation">simSetObjectOrientation</a></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectQuaternion(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* quaternion)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>relativeToObjectHandle</strong>: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.<br>
</div>
<div><strong>quaternion</strong>: the quaternion (x,y,z,w)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectQuaternion(number objectHandle,number relativeToObjectHandle,table_4 quaternion)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectSpecialProperty" id="simSetObjectSpecialProperty"></a>simSetObjectSpecialProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the special properties of a scene object. See also <a href="#simGetObjectSpecialProperty">simGetObjectSpecialProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectSpecialProperty(simInt objectHandle,simInt prop)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: object handle</div>
<div><strong>prop</strong>: object special property. See the <a href="apiConstants.htm#sceneObjectSpecialProperties">object special property values</a>. Combine them with the &quot;or&quot;-operator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectSpecialProperty(number objectHandle,number prop)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetObjectStringParameter" id="simSetObjectStringParameter"></a>simSetObjectStringParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Set a string parameter of a object. See also <a href="#simGetObjectStringParameter">simGetObjectStringParameter</a>, <a href="#simSetObjectIntParameter">simSetObjectIntParameter</a> and <a href="#simSetObjectFloatParameter">simSetObjectFloatParameter</a><br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetObjectStringParameter(simInt objectHandle,simInt parameterID,simChar* parameter,simInt parameterLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the object</div>
<div><strong>parameterID</strong>: identifier of the parameter to retrieve. See the <a href="objectParameterIDs.htm">list of all possible object parameter identifiers</a></div>
<div><strong>parameter</strong>: parameter value (can contain embedded zeros)</div>
<div><strong>parameterLength</strong>: the length of the parameter value</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetObjectStringParameter(number objectHandle,number parameterID,string parameter)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
Same as C-function
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetPage" id="simSetPage"></a>simSetPage</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Switches between pages (main scene views). See also <a href="#simGetPage">simGetPage</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetPage(simInt index)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>index</strong>: index of the page. Valid values are 0-7</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetPage(number index)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetPathPosition" id="simSetPathPosition"></a>simSetPathPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic position of a path object (i.e. the position along the path). The position is given in meters, but the actual position is dependent on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a> for the given path object.This function is the equivalent of <a href="#simSetJointPosition">simSetJointPosition</a>, but for a path object. See also <a href="#simGetPathPosition">simGetPathPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetPathPosition(simInt objectHandle,simFloat position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div><strong>position</strong>: linear position on the path given in meters (but dependent on the selected path length calculation method)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetPathPosition(number objectHandle,number position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetPathTargetNominalVelocity" id="simSetPathTargetNominalVelocity"></a>simSetPathTargetNominalVelocity</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic target nominal velocity of a path object. The path's motion handling feature must be enabled for this to have an effect (i.e. <a href="#simHandlePath">simHandlePath</a> must be called and the path motion properties be set in the path settings dialog). The path intrinsic velocity is expressed in meters/seconds, but depending on the selected <a href="pathPositionCalculationMethod.htm">path length calculation method</a>, that velocity might be different from a &quot;regular&quot; linear velocity.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetPathTargetNominalVelocity(simInt objectHandle,simFloat targetNominalVelocity)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the path object</div>
<div><strong>targetNominalVelocity</strong>: the target nominal velocity (which is the velocity we wish, but that velocity might be modulated between the path's Bezier points depending on the selected velocity profile). Moreover, the targetNominalVelocity is expressed in meters/seconds, but depending on the selected path length calculation method, that velocity might be different from a &quot;regular&quot; linear velocity.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetPathTargetNominalVelocity(number objectHandle,number targetNominalVelocity)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetScriptRawBuffer" id="simSetScriptRawBuffer"></a>simSetScriptRawBuffer</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Attaches a raw buffer to a given script. All raw buffers are automatically released at the end of a simulation. See also <a href="#simGetScriptRawBuffer">simGetScriptRawBuffer</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetScriptRawBuffer(simInt scriptHandle,const simChar* buffer,simInt bufferSize)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script</div>
<div><strong>buffer</strong>: pointer to the buffer</div>
<div><strong>bufferSize</strong>: size of the buffer (the function will copy the buffer which can then immediately be released by the calling application)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a handle to the buffer. Using that handle and the <a href="#simGetScriptRawBuffer">simGetScriptRawBuffer</a>, the buffer can be retrieved. In case of an error, the return value is -1<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetScriptSimulationParameter" id="simSetScriptSimulationParameter"></a>simSetScriptSimulationParameter</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a script's parameter in its simulation parameter list. Useful for simple interaction with the user, for simple parameter exchange with other scripts, or for saving permanent data from a script. Only parameters of main or child scripts can be set with this function. See also <a href="#simGetScriptSimulationParameter">simGetScriptSimulationParameter</a>, <a href="#simPackInts">simPackInts</a> and <a href="#simPackFloats">simPackFloats</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetScriptSimulationParameter(simInt scriptHandle,const simChar* parameterName,const simChar* parameterValue,simInt parameterLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of the script, or sim_handle_main_script or sim_handle_all</div>
<div><strong>parameterName</strong>: name of the parameter to set</div>
<div><strong>parameterValue</strong>: value of the parameter (all parameters are treated as strings, but can be converted to number later on. Strings may contain any values (also embedded zeros))<br>
</div>
<div><strong>parameterLength</strong>: number of bytes that parameterValue contains. If parameterValue is a regular string (without embedded zeros), then this is strlen(parameterValue).<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>number of parameters that were set (can be &gt;1 if sim_handle_all was specified) or -1 if the parameterName could not be found or in case of an error<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number setCount=simSetScriptSimulationParameter(number scriptHandle,string parameterName,string/number parameterValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam><div><strong>scriptHandle</strong>: handle of the script, or sim_handle_main_script, sim_handle_all, sim_handle_tree, sim_handle_chain or sim_handle_self</div>
<div><strong>parameterName</strong>: Same as C-function</div>
<div><strong>parameterValue</strong>: Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetScriptText" id="simSetScriptText"></a>simSetScriptText</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets a new content for a script (i.e. attaches a new Lua code). This only works when simulation is not running. This function is not available in the Lua-API. See also <a href="#simGetScriptText">simGetScriptText</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetScriptText(simInt scriptHandle,const simChar* scriptText)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>scriptHandle</strong>: handle of a script</div>
<div><strong>scriptText</strong>: pointer to a script buffer (0-terminated buffer). This function will copy the buffer content, so that it can immediately be released after this call<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetShapeColor" id="simSetShapeColor"></a>simSetShapeColor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Sets the color of one or several shapes. See also <a href="#simGetShapeColor">simGetShapeColor</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetShapeColor(simInt shapeHandle,simChar* colorName,simInt colorComponent,simFloat* rgbData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the shape, or sim_handle_all if the command should be directed at all shapes<br>
</div>
<div><strong>colorName</strong>: name of a color. If a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. Can be NULL.<br>
</div>
<div><strong>colorComponent</strong>: 0 for ambient, 1 for diffuse, 2 for specular, 3 for emmisive, and 4 for the transparency value<br>
</div>
<div><strong>rgbData</strong>: red, green and blue components of the color (3 values), or the transparency value (1 value)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetShapeColor(number shapeHandle,string colorName,number colorComponent,table_3 rgbData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetShapeMassAndInertia" id="simSetShapeMassAndInertia"></a>simSetShapeMassAndInertia</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Applies mass and inertia information to a shape. See also <a href="#simGetShapeMassAndInertia">simGetShapeMassAndInertia</a>, <a href="#simGetObjectMatrix">simGetObjectMatrix</a> and <a href="#simBuildMatrix">simBuildMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetShapeMassAndInertia(simInt shapeHandle,simFloat mass,const simFloat* inertiaMatrix,const simFloat* centerOfMass,const simFloat* transformation)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: handle of the <a href="shapes.htm">shape object</a></div>
<div><strong>mass</strong>: the new mass of the object</div>
<div><strong>inertia matrix</strong>: the new inertia matrix or tensor (9 values), expressed relative to the center of mass. The matrix should be relative to the orientational frame of <strong>transformation</strong> (see further below). </div>
<div><strong>centerOfMass</strong>: the new position of the center of mass, relative to the specified <strong>transformation</strong> (see next item).</div>
<div><strong>transformation</strong>: the transformation matrix (12 values) relative to which we specify the data. Can be NULL, in which case the data is relative to the absolute reference frame. See <a href="#simGetObjectMatrix">here</a> to see how matrix transformations are specified in V-REP.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 in case of an error<a href="#simReleaseBuffer"></a><br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetShapeMassAndInertia(number shapeHandle,number mass,table_9 inertiaMatrix,table_3 centerOfMass,table_12 transformation=nil)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>See the C-function for details</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>See the C-function for details</div></td> 
</tr> 
</table> 
<br>








<h3><a name="simSetSimulationPassesPerRenderingPass" id="simSetSimulationPassesPerRenderingPass"></a>simSetSimulationPassesPerRenderingPass</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the number of simulation passes (calculation passes) per frame (display). This function is not available in the Lua-API. See also <a href="#simGetSimulationPassesPerRenderingPass">simGetSimulationPassesPerRenderingPass</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetSimulationPassesPerRenderingPass(simInt p)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>p</strong>: the number of simulation passes for one rendering pass</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>&gt;0 if operation was successful</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetSphericalJointMatrix" id="simSetSphericalJointMatrix"></a>simSetSphericalJointMatrix
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetSphericalJointMatrix">simxSetSphericalJointMatrix</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetSphericalJointMatrix">simRosSetSphericalJointMatrix</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the intrinsic orientation matrix of a spherical joint object. This function cannot be used with non-spherical joints (use <a href="#simSetJointPosition">simSetJointPosition</a> instead). See also <a href="#simGetJointMatrix">simGetJointMatrix</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetSphericalJointMatrix(simInt objectHandle,const simFloat* matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>objectHandle</strong>: handle of the joint object</div>
<div><strong>matrix</strong>: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])<br>
</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])<br>
</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])<br>
</div>
<div class=tab>The translation component is (matrix[3],matrix[7],matrix[11]) (the translational components will be ignored)<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetSphericalJointMatrix(number objectHandle,table_12 matrix)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetStringSignal" id="simSetStringSignal"></a>simSetStringSignal
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetStringSignal">simxSetStringSignal</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetStringSignal">simRosSetStringSignal</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the value of a string signal. If that signal is not yet present, it is added. Signals created in the <a href="mainScript.htm">main script</a> or in a <a href="childScripts.htm">child script</a> are automatically cleared at simulation end. See also <a href="#simGetStringSignal">simGetStringSignal</a>, <a href="#simClearStringSignal">simClearStringSignal</a>, <a href="#simSetIntegerSignal">simSetIntegerSignal</a>, <a href="#simSetFloatSignal">simSetFloatSignal</a>,  <a href="#simWaitForSignal">simWaitForSignal</a> and <a href="#simPersistentDataWrite">simPersistentDataWrite</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetStringSignal(const simChar* signalName,const simChar* signalValue,simInt stringLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>signalName</strong>: name of the signal</div>
<div><strong>signalValue</strong>: value of the signal (which may contain any value, including embedded zeros)</div>
<div><strong>stringLength</strong>: the size of the string value.</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetStringSignal(string signalName,string signalValue)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>

</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetThreadAutomaticSwitch" id="simSetThreadAutomaticSwitch"></a>simSetThreadAutomaticSwitch</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows to temporarily forbid thread switches. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. For complete control over the switching moment, see also <a href="#simSetThreadSwitchTiming">simSetThreadSwitchTiming</a>, <a href="#simSwitchThread">simSwitchThread</a>, <a href="#simSetThreadIsFree">simSetThreadIsFree</a> and <a href="#simSetThreadResumeLocation">simSetThreadResumeLocation</a>. This function is not available from the C-API.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetThreadAutomaticSwitch(Boolean switchIsAutomatic)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>switchIsAutomatic</strong>: if true, the thread will be able to automatically switch to another thread, otherwise the switching is temporarily disabled.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if the command was successful, 0 if it didn't have an effect (e.g. because the function was called from the main or application thread), or -1 in case of an error.<br>
</div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetThreadIsFree" id="simSetThreadIsFree"></a>simSetThreadIsFree</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Threads created by V-REP are never running concurrently, they rather behave like coroutines. This allows achieving same results as with &quot;pure threads&quot;, except when an external command is blocking (e.g. commands not directly supported by V-REP). Those can be lengthly image processing routines, or socket communication routines for example. When such external blocking commands are called, V-REP appears frozen until the external commands return. To avoid such a situation, you can declare a non-blocking section with the <a href="#simSetThreadIsFree">simSetThreadIsFree</a> command: <a href="#simSetThreadIsFree">simSetThreadIsFree</a>(true) starts a non-blocking section, and <a href="#simSetThreadIsFree">simSetThreadIsFree</a>(false) closes it. Try to avoid using V-REP commands when in a non-blocking section (bad synchronization), and never forget to close a non-blocking section, otherwise V-REP will hang indefinitely. Use <a href="#simSetThreadIsFree">simSetThreadIsFree</a> with extra care when calling it from C. A thread running in a non-blocking section cannot be paused nor stopped. This command has no effect when called from the main thread or a non-threaded script.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetThreadIsFree(simBool freeMode)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>freeMode</strong>: specify 1 to start a non-blocking section. Specify 0 to end a non-blocking section<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if operation was successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetThreadIsFree(Boolean freeMode)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>freeMode</strong>: specify true to start a non-blocking section. Specify false to end a non-blocking section<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetThreadResumeLocation" id="simSetThreadResumeLocation"></a>simSetThreadResumeLocation</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows specifying when and in which order threads are resumed. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. Once a thread switched to another thread, it will resume execution at the beginning of next simulation pass by default. In order to also have full synchronization control between threads, you can assign a resume location and order to each thread with this function. See also <a href="#simResumeThreads">simResumeThreads</a>, <a href="#simSetThreadSwitchTiming">simSetThreadSwitchTiming</a>, <a href="#simSetThreadAutomaticSwitch">simSetThreadAutomaticSwitch</a>, <a href="#simSwitchThread">simSwitchThread</a> and <a href="#simSetThreadIsFree">simSetThreadIsFree</a>. This function is not available from the C-API.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetThreadResumeLocation(number location,number order)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>location</strong>: indicates the location where the thread should resume. 0 indicates that the thread should resume before the main script is executed (this is also the default behavior of all threads). If another value than 0 is specified, then the thread will resume when <a href="#simResumeThreads">simResumeThreads</a> is called with the same location value. The default main script will resume threads with a location value of:
</div>
<br>
<div class=tab>1 : just before <a href="#simHandleChildScript">simHandleChildScript</a> is called</div>
<div class=tab>2 : just after <a href="#simHandleChildScript">simHandleChildScript</a> is called</div>
<div class=tab>3 : just before <a href="#simHandleSensingChildScripts">simHandleSensingChildScripts</a> is called</div>
<div class=tab>4 : just after <a href="#simHandleSensingChildScripts">simHandleSensingChildScripts</a> is called</div>
<br>
<div>If a location value (different from 0) is indicated that doesn't correspond to any <a href="#simResumeThreads">simResumeThreads</a> command with the same location value, then the thread is resumed after the main script was executed.<br>
</div>
<br>
<div><strong>order</strong>: indicates the resume order or priority:</div>
<br>
<div class=tab>-1 : the thread executes first (high priority)</div>
<div class=tab>0 : the thread executes second (normal priority, also the default behavior of threads)</div>
<div class=tab>1 : the thread executes last (low priority)</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if the command was applied, 0 if it was not (e.g. because the function was called from the main or application thread), or -1 in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetThreadSwitchTiming" id="simSetThreadSwitchTiming"></a>simSetThreadSwitchTiming</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows specifying a switching time for the thread in which the current script runs. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads: each thread (except for the main or application thread) has a switch timing associated, which specifies how long the thread will run before switching to other threads (the execution duration per calculation pass). By default this value is 2 millisecond, but this function allows changing that value (on a thread-basis). Acceptable values are between 0 and 200. For complete control over the switching moment, see also <a href="#simSetThreadAutomaticSwitch">simSetThreadAutomaticSwitch</a>, <a href="#simSwitchThread">simSwitchThread</a>, <a href="#simSetThreadIsFree">simSetThreadIsFree</a> and <a href="#simSetThreadResumeLocation">simSetThreadResumeLocation</a>. This function is not available from the C-API.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetThreadSwitchTiming(number deltaTimeInMilliseconds)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>deltaTimeInMilliseconds</strong>: desired non-stop execution time before a switching occurs. A value of x will let the thread execute for x-1 to x milliseconds before switching to another thread.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>result</strong>: 1 if the timing was set, 0 if it was not set (e.g. because the function was called from the main or application thread), or -1 in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetUIButtonArrayColor" id="simSetUIButtonArrayColor"></a>simSetUIButtonArrayColor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the color of an array element of a custom user interface. <a href="#simCreateUIButtonArray">simCreateUIButtonArray</a> needs to be called previously<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetUIButtonArrayColor(simInt uiHandle,simInt buttonHandle,const simInt* position,const simFloat* color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: button handle</div>
<div><strong>position</strong>: position in the array from left to right and top to bottom (x and y)</div>
<div><strong>color</strong>: color of the array element (red, green and blue values, 0=minimum intensity, 1=maximum intensity)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetUIButtonArrayColor(number uiHandle,number buttonHandle,table_2 position,table_3 color)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetUIButtonColor" id="simSetUIButtonColor"></a>simSetUIButtonColor</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the up-state, down-state and label colors of a custom user interface button<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetUIButtonColor(simInt uiHandle,simInt buttonHandle,const simFloat* upStateColor,const simFloat* downStateColor,const simFloat* labelColor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: button handle</div>
<div><strong>upStateColor</strong>: color of the button when up (red, green and blue values, 0=minimum intensity, 1=maximum intensity). Can be NULL<br>
</div>
<div><strong>downStateColor</strong>: color of the button when down (red, green and blue values, 0=minimum intensity, 1=maximum intensity). Can be NULL<br>
</div>
<div><strong>labelColor</strong>: color of the button label (red, green and blue values, 0=minimum intensity, 1=maximum intensity). Can be NULL<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetUIButtonColor(number uiHandle,number buttonHandle,table_3 upStateColor,table_3 downStateColor,table_3 labelColor)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div><strong>uiHandle</strong>: Same as C-function</div>
<div><strong>buttonHandle</strong>: Same as C-function</div>
<div><strong>upStateColor</strong>: Same as C-function. Can be nil or omitted</div>
<div><strong>downStateColor</strong>: Same as C-function. Can be nil or omitted</div>
<div><strong>labelColor</strong>: Same as C-function. Can be nil or omitted</div>
<div></div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetUIButtonLabel" id="simSetUIButtonLabel"></a>simSetUIButtonLabel
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetUIButtonLabel">simxSetUIButtonLabel</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetUIButtonLabel">simRosSetUIButtonLabel</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the up-state and down-state labels of a custom user interface button. See also <a href="#simGetUIButtonLabel">simGetUIButtonLabel</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetUIButtonLabel(simInt uiHandle,simInt buttonHandle,const simChar* upStateLabel,const simChar* downStateLabel)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: button handle</div>
<div><strong>upStateLabel</strong>: pointer to a string containing the label of the button when it is up. Can be NULL.</div>
<div><strong>downStateLabel</strong>: pointer to a string containing the label of the button when it is down. Can be NULL.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetUIButtonLabel(number uiHandle,number buttonHandle,string upStateLabel,string downStateLabel)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetUIButtonProperty" id="simSetUIButtonProperty"></a>simSetUIButtonProperty
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetUIButtonProperty">simxSetUIButtonProperty</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetUIButtonProperty">simRosSetUIButtonProperty</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>
Sets the properties of a custom user interface button. See also <a href="#simGetUIButtonProperty">simGetUIButtonProperty</a>. </td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetUIButtonProperty(simInt uiHandle,simInt buttonHandle,simInt buttonProperty)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: button handle</div>
<div><strong>buttonProperty</strong>: button property. See the <a href="apiConstants.htm#uiButtonProperties">button property values</a>. Combine them with the &quot;or&quot;-operator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetUIButtonProperty(number uiHandle,number buttonHandle,number buttonProperty)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetUIButtonTexture" id="simSetUIButtonTexture"></a>simSetUIButtonTexture</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets (or actualizes) the texture of a custom user interface button. This function is useful to display custom dynamic images (e.g. video camera images) inside of a custom user interface button. See also <a href="#simSetVisionSensorImage">simSetVisionSensorImage</a>. This function is not available in the Lua-API<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetUIButtonTexture(simInt uiHandle,simInt buttonHandle,const simInt* size,const simChar* textureData)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle of the custom user interface</div>
<div><strong>buttonHandle</strong>: handle of the button</div>
<div><strong>size</strong>: pointer to the x- and y-resolution of the texture. Can be NULL, in which case the texture is removed from the button.<br>
</div>
<div><strong>textureData</strong>: rgb data of the texture. Texture data will be copied internally, so the textureData can be released directly after this call. <br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetUIPosition" id="simSetUIPosition"></a>simSetUIPosition</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the position of a custom user interface. See also <a href="#simGetUIPosition">simGetUIPosition</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetUIPosition(simInt uiHandle,const simInt* position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: handle of the custom user interface</div>
<div><strong>position</strong>: pointer to 2 values (x and y)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetUIPosition(number uiHandle,table_2 position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetUIProperty" id="simSetUIProperty"></a>simSetUIProperty</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the properties of a custom user interface. See also <a href="#simGetUIProperty">simGetUIProperty</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetUIProperty(simInt uiHandle,simInt uiProperty)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>uiProperty</strong>: custom user interface property. See the <a href="apiConstants.htm#uiProperties">custom user interface properties</a>. Combine them with the &quot;or&quot;-operator</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetUIProperty(number uiHandle,number uiProperty)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetUISlider" id="simSetUISlider"></a>simSetUISlider
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetUISlider">simxSetUISlider</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetUISlider">simRosSetUISlider</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the slider position of a custom user interface button (must be a slider-type button). See also <a href="#simGetUISlider">simGetUISlider</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetUISlider(simInt uiHandle,simInt buttonHandle,simInt position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>uiHandle</strong>: custom user interface handle</div>
<div><strong>buttonHandle</strong>: button handle</div>
<div><strong>position</strong>: slider position. valid values are between 0 and 1000</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetUISlider(number uiHandle,number buttonHandle,number position)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSetVisionSensorImage" id="simSetVisionSensorImage"></a>simSetVisionSensorImage
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxSetVisionSensorImage">simxSetVisionSensorImage</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosSetVisionSensorImage">simRosSetVisionSensorImage</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sets the rgb-image of a vision sensor (and applies any image processing filter if specified in the vision sensor dialog). Make sure the vision sensor is flagged as <strong>use external image</strong>. Use <a href="#simGetVisionSensorResolution">simGetVisionSensorResolution</a> to know the size of the image buffer that you need to provide (buffer size=resolutionX *resolutionY*3). The &quot;regular&quot; use of this function is to first read the data from a vision sensor with <a href="#simGetVisionSensorImage">simGetVisionSensorImage</a>, do some custom filtering, then write the modified image back. The alternate use of this function is to display textures, video images, etc. by using a vision sensor object (without however making use of the vision sensor functionality), since a vision sensor can be &quot;looked through&quot; like camera objects.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simSetVisionSensorImage(simInt sensorHandle,const simFloat* image)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>sensorHandle</strong>: handle of the vision sensor object</div>
<div><strong>image</strong>: rgb buffer containing the image (buffer size must be resolutionX*resolutionY*3)</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. 0 if the applied filter didn't trigger anything, 1 if the appIied filter triggered a detection<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSetVisionSensorImage(number sensorHandle,table image)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>












<h3><a name="simStartSimulation" id="simStartSimulation"></a>simStartSimulation
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxStartSimulation">simxStartSimulation</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosStartSimulation">simRosStartSimulation</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Requests a start of a simulation (or a resume of a paused simulation). See also <a href="#simPauseSimulation">simPauseSimulation</a> and <a href="#simStopSimulation">simStopSimulation</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simStartSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simStartSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simStopSimulation" id="simStopSimulation"></a>simStopSimulation
<div class=tab>remote API equivalent: <a href="remoteApiFunctions.htm#simxStopSimulation">simxStopSimulation</a></div>
<div class=tab>ROS API equivalent: <a href="rosServices.htm#simRosStopSimulation">simRosStopSimulation</a></div>
</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Requests a stop of the running simulation. See also <a href="#simStartSimulation">simStartSimulation</a> and <a href="#simPauseSimulation">simPauseSimulation</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simStopSimulation()<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>None</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simStopSimulation()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simSwitchThread" id="simSwitchThread"></a>simSwitchThread</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Allows specifying the exact moment at which the current thread should switch to another thread. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use &quot;regular&quot; threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads: each thread (except for the main or application thread) has a switch timing associated, which specifies how long the thread will run before switching to other threads. By default this value is 2 millisecond, but can be modified with <a href="#simSetThreadSwitchTiming">simSetThreadSwitchTiming</a>. That timing can be shortened with <a href="#simSwitchThread">simSwitchThread</a>. This function is not available from the C-API. See also the <a href="#simSetThreadAutomaticSwitch">simSetThreadAutomaticSwitch</a>, <a href="#simSetThreadResumeLocation">simSetThreadResumeLocation</a> and <a href="#simSetThreadIsFree">simSetThreadIsFree</a> functions.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simSwitchThread()</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>None</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>result</strong>: 1 if the thread was switched (the current thread gave control to other threads until the next calculation pass), 0 if it was not switched (e.g. because the function was called from the main or application thread), or -1 in case of an error.<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simTransformVector" id="simTransformVector"></a>simTransformVector</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Multiplies a vector with a transformation matrix (v=m*v). See <a href="#simMultiplyVector">simMultiplyVector</a> for the Lua-API version.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTransformVector(const simFloat* matrix,simFloat* vect)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>matrix</strong>: the transformation matrix</div>
<div class=tab>The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])</div>
<div class=tab>The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])<br>
</div>
<div class=tab>The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])</div>
<div class=tab>The position component is (matrix[3],matrix[7],matrix[11])</div>
<div><strong>vect</strong>: the vector to be transformed (a pointer to 3 values (the last element of the homogeneous coordinates is not required (1)))<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simTubeClose" id="simTubeClose"></a>simTubeClose</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Closes a communication tube previously opened with <a href="#simTubeOpen">simTubeOpen</a>. Data written with <a href="#simTubeWrite">simTubeWrite</a> and that hasn't been read yet on the other side of the tube will persist.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTubeClose(simInt tubeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tubeHandle</strong>: the handle of the tube that was returned by the <a href="#simTubeOpen">simTubeOpen</a> function. Once a tube was closed on one side, it is again ready for a new connection.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simTubeClose(number tubeHandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simTubeOpen" id="simTubeOpen"></a>simTubeOpen</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Opens a tube for communication within V-REP. A tube is similar to a bidirectional communication pipe. Messages written on one side can be read on the other side in the same order as they were written. Tubes opened via a script will automatically close upon simulation end. A scene switch will close all communication tubes and tube handles will not be valid anymore. See also <a href="#simTubeClose">simTubeClose</a>, <a href="#simTubeWrite">simTubeWrite</a>, <a href="#simTubeRead">simTubeRead</a>, <a href="#simTubeStatus">simTubeStatus</a>, <a href="#simSendData">simSendData</a> and <a href="#simReceiveData">simReceiveData</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTubeOpen(simInt dataHeader,const simChar* dataName,simInt readBufferSize,simBool notUsedButKeepFalse)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>dataHeader</strong>: number indicating who &quot;designed&quot; the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the &quot;Help&quot; menu, in the &quot;About&quot; item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.<br>
</div>
<div><strong>dataName</strong>: name indicating the type of message. A tube will only be able to connect if its two sides have the same dataHeader and dataName<br>
</div>
<div><strong>readBufferSize</strong>: the number of data packets that can be stored in the input buffer of this side of the tube<br>
</div>
<div><strong>notUsedButKeepFalse</strong>: not used. Keep to false.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, otherwise the tube handle.</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number tubeHandle=simTubeOpen(number dataHeader,string dataName,number readBufferSize)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simTubeRead" id="simTubeRead"></a>simTubeRead</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Receives a data packet from a communication tube previously opened with <a href="#simTubeOpen">simTubeOpen</a>. The tube needs to be connected (see <a href="#simTubeStatus">simTubeStatus</a>).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simChar* simTubeRead(simInt tubeHandle,simInt* dataLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tubeHandle</strong>: the handle of the tube that was returned by the <a href="#simTubeOpen">simTubeOpen</a> function.</div>
<div><strong>dataLength</strong>: size of the returned data packet</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>Pointer to a data packet, or NULL if nothing could be read. The user is in charge of releasing the returned buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>.<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>string data=simTubeRead(number tubeHandle,boolean blockingOperation=false)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>tubeHandle</strong>: Same as C-function</div>
<div><strong>blockingOperation</strong>: if true, then the call will block until something can be read or until an error occurred. The script should be threaded in that case. Default value is false.<br>
</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>data</strong>: string containing the received data, or nil in case of an error or if no data is present. If received data is packed, see also <a href="#simUnpackInts">simUnpackInts</a> and <a href="#simUnpackFloats">simUnpackFloats</a><br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simTubeStatus" id="simTubeStatus"></a>simTubeStatus</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Checks the status of a communication tube previously opened with <a href="#simTubeOpen">simTubeOpen</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTubeStatus(simInt tubeHandle,simInt* readPacketsCount,simInt* writePacketsCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tubeHandle</strong>: the handle of the tube that was returned by the <a href="#simTubeOpen">simTubeOpen</a> function.</div>
<div><strong>readPacketsCount</strong>: pointer to an integer that will indicate the number of packets waiting to be read. Can be NULL</div>
<div><strong>writePacketsCount</strong>: pointer to an integer that will indicate the number of packets waiting to be read on the other side of the tube. Can be NULL<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-1 if operation was not successful, 0 if the tube is not connected, 1 if the tube is connected<br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number status,number readPacketsCount,number writePacketsCount=simTubeStatus(number tubeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>status</strong>: nil if operation was not successful, otherwise 0 if the tube is not connected, 1 if the tube is connected</div>
<div><strong>readPacketsCount</strong>: nil if operation was not successful, otherwise the number of packets waiting to be read</div>
<div><strong>writePacketsCount</strong>: nil if operation was not successful, otherwise the number of packets waiting to be read on the other side of the tube</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simTubeWrite" id="simTubeWrite"></a>simTubeWrite</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Sends a data packet into a communication tube previously opened with <a href="#simTubeOpen">simTubeOpen</a>. The tube needs to be connected (see <a href="#simTubeStatus">simTubeStatus</a>).<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simTubeWrite(simInt tubeHandle,const simChar* data,simInt dataLength)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>tubeHandle</strong>: the handle of the tube that was returned by the <a href="#simTubeOpen">simTubeOpen</a> function.</div>
<div><strong>data</strong>: pointer to a data packet. <a href="#simTubeWrite">simTubeWrite</a> will copy that packet so that it can directly be released</div>
<div><strong>dataLength</strong>: size of the data packet</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>1 if operation was successful. In a future release, a more differentiated return value might be available</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number result=simTubeWrite(number tubeHandle,string data)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>tubeHandle</strong>: Same as C-function</div>
<div><strong>data</strong>: string representing a data packet (each character can have values between 0 and 255). See also <a href="#simPackInts">simPackInts</a> and <a href="#simPackFloats">simPackFloats</a> if you wish to pack numbers into data.<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Same as C-function</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simUngroupShape" id="simUngroupShape"></a>simUngroupShape</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Ungroups a grouped shape into several <a href="shapes.htm">simple shapes</a>. See also <a href="#simGroupShapes">simGroupShapes</a> and <a href="#simConvexDecompose">simConvexDecompose</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt* simUngroupShape(simInt shapeHandle,simInt* shapeCount)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><strong>shapeHandle</strong>: the handles of the shape you wish to ungroup</div>
<div><strong>shapeCount</strong> (output): the size of the returned buffer.</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>a pointer to an array holding the handles of the resulting shapes, or NULL in case of an error. The user is in charge of releasing the array buffer with <a href="#simReleaseBuffer">simReleaseBuffer</a>. <br>
</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table simpleShapeHandles=simUngroupShape(number shapeHandle)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>Similar to C-function</div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>Similar to C-function</div></td> 
</tr> 
</table> 
<br>







<h3><a name="simUnloadModule" id="simUnloadModule"></a>simUnloadModule</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unloads a V-REP plugin. This should be done just before ending the simulator. See also <a href="#simSendModuleMessage">simSendModuleMessage</a> and <a href="#simLoadModule">simLoadModule</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>simInt simUnloadModule(simInt pluginhandle)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div><span class="apiTableRightCSyn"><strong>pluginhandle</strong></span>: handle of the plugin</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>0 if plugin was not unloaded (e.g. because it was not loaded, or because it was loaded more than once). Different from 0 if the plugin was successfully unloaded</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div>-</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div>-</div>
<div></div></td> 
</tr> 
</table> 
<br>








<h3><a name="simUnpackFloats" id="simUnpackFloats"></a>simUnpackFloats</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a string (or part of it) into a table of floating-point numbers. See also <a href="#simPackFloats">simPackFloats</a> and <a href="#simUnpackInts">simUnpackInts</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table floatingNumbers=simUnpackFloats(string data,number startIndex=0,number count=0)</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed floating-point numbers</div>
<div><strong>startIndex</strong>: the zero-based index from which on data should be unpacked (from data[4*startIndex+1]). Can be omitted in which case 0 is used<br>
</div>
<div><strong>count</strong>: the amount of floats that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of floats should be unpacked from the indicated startIndex)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>floatingNumbers</strong>: a table containing unpacked floating-point numbers if operation was successful, nil otherwise<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simUnpackInts" id="simUnpackInts"></a>simUnpackInts</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Unpacks a string (or part of it) into a table of integer numbers. See also <a href="#simPackInts">simPackInts</a> and <a href="#simUnpackFloats">simUnpackFloats</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>table integerNumbers=simUnpackInts(string data,number startIndex=0,number count=0)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>data</strong>: a string (values between 0 and 255) that contains packed integer numbers</div>
<div><strong>startIndex</strong>: the zero-based index from which on data should be unpacked (from data[4*startIndex+1]). Can be omitted in which case 0 is used<br>
</div>
<div><strong>count</strong>: the amount of ints that should be unpacked. Can be omitted in which case 0 is used (which indicates that the maximum of ints should be unpacked from the indicated startIndex)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>integerNumbers</strong>: a table containing unpacked integer numbers if operation was successful, nil otherwise</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simWait" id="simWait"></a>simWait</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Waits for a certain amount of time. This function can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is a blocking operation) and is not available from the C-API. See also <a href="#simWaitForSignal">simWaitForSignal</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>number deltaTimeLeft=simWait(number deltaTime,Boolean simulationTime)<br></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>deltaTime</strong>: the minimum time duration to wait. If the function was called at simulation time X (or real-time X), then the function will return when simulation time&gt;=X+deltaTime (or when real-time&gt;=X+deltaTime)<br>
</div>
<div><strong>simulationTime</strong>: indicates whether we want to wait in terms of simulation- or real-time. Can be omitted (is true by default)<br>
</div>
<div></div></td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div></div>
<div><strong>deltaTimeLeft</strong>: the &quot;wait resolution&quot; of this function is the simulation time step, and the simWait command may overshoot the requested waiting time. deltaTimeLeft is the negative overshoot time. If the function was called at simulation time X, and the function returned at simulation time Y, then deltaTimeLeft is deltaTime-(Y-X). In case of an error, deltaTimeLeft is nil. deltaTimeLeft is also memorized internally on a thread-basis and used as compensation or correction factor in subsequent blocking commands. deltaTimeLeft is 0 if the simulationTime argument was false<br>
</div>
<div></div></td> 
</tr> 
</table> 
<br>






<h3><a name="simWaitForSignal" id="simWaitForSignal"></a>simWaitForSignal</h3>
<table class=apiTable>
<tr class=apiTableTr> 
<td class=apiTableLeftDescr>
Description 
</td> 
<td class=apiTableRightDescr>Waits for a signal. Signals are cleared at simulation start. This function will first check whether an integer signal with that name is present, then if a float signal with that name is present and finally if a string signal with that name is present. The function only returns when the signal is present (defined). This function can only be called from <a href="childScripts.htm">child scripts</a> running in a thread (since this is a blocking operation) and is not available from the C-API. See also <a href="#simGetIntegerSignal">simGetIntegerSignal</a>, <a href="#simGetFloatSignal">simGetFloatSignal</a>, <a href="#simGetStringSignal">simGetStringSignal</a> and <a href="#simWait">simWait</a>.<br></td>
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCSyn>
C synopsis
</td> 
<td class=apiTableRightCSyn>-</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCParam>C parameters</td> 
<td class=apiTableRightCParam>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftCRet>
C return value
</td> 
<td class=apiTableRightCRet>
<div>-</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLSyn>
Lua synopsis
</td> 
<td class=apiTableRightLSyn>
<div>Number/string signalValue=simWaitForSignal(string signalName)</div>
<br>
<div>The function is equivalent to:</div>
<br>
<pre class=lightRedBoxNoMarginAndSmall>
signalValue=nil
while (signalValue==nil) and
        (simGetSimulationState()~=sim_simulation_advancing_abouttostop) do
    signalValue=simGetIntegerSignal(signalName) or simGetFloatSignal(signalName) or
                                                  simGetStringSignal(signalName)
    if (signalValue==nil) then
        simSwitchThread()
    end
end</pre>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLParam>Lua parameters</td> 
<td class=apiTableRightLParam>
<div></div>
<div><strong>signalName</strong>: name of the signal</div>
</td> 
</tr> 
<tr class=apiTableTr> 
<td class=apiTableLeftLRet>
Lua return values
</td> 
<td class=apiTableRightLRet>
<div><strong>signalValue</strong>: value of the signal, or nil when the command is cancelled by stopping the simulation</div>
<div></div></td> 
</tr> 
</table> 
<br>








<br>
<br>
</td>
</tr>
</table> 
</div>  
  
  
</body>

</html>
